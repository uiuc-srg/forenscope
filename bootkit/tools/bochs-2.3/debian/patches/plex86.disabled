diff -Nur bochs-2.0.2+20030829.old/config.h.in bochs-2.0.2+20030829/config.h.in
--- bochs-2.0.2+20030829.old/config.h.in	2003-08-24 23:39:33.000000000 +0000
+++ bochs-2.0.2+20030829/config.h.in	2003-08-29 14:31:40.000000000 +0000
@@ -914,4 +914,6 @@
 //#define BX_SCHEDULED_DIE_TIME 1162230000   // end of redhat6.0 boot
 
 
+#undef BX_USE_PLEX86
+
 #endif  // _BX_CONFIG_H
diff -Nur bochs-2.0.2+20030829.old/configure.in bochs-2.0.2+20030829/configure.in
--- bochs-2.0.2+20030829.old/configure.in	2003-08-29 14:14:48.000000000 +0000
+++ bochs-2.0.2+20030829/configure.in	2003-08-29 14:31:40.000000000 +0000
@@ -1715,6 +1715,20 @@
 AC_SUBST(INSTALL_DOCBOOK_VAR)
 AC_SUBST(DOCBOOK2HTML)
 
+AC_MSG_CHECKING(for Plex86 support)
+AC_ARG_ENABLE(plex86,
+  [  --enable-plex86                   support a Plex86 backend (i386 only)],
+  [if test "$enableval" = yes; then
+    AC_MSG_RESULT(yes)
+    AC_DEFINE(BX_USE_PLEX86, 1)
+    EXTRA_BX_OBJS="$EXTRA_BX_OBJS plex86.o"
+   else
+    AC_MSG_RESULT(no)
+    AC_DEFINE(BX_USE_PLEX86, 0)
+   fi
+   ]
+  )
+
 PRIMARY_TARGET='bochs'
 PLUGIN_LIBNAME_TRANSFORMATION='%.o=libbx_%.la'
 
diff -Nur bochs-2.0.2+20030829.old/main.cc bochs-2.0.2+20030829/main.cc
--- bochs-2.0.2+20030829.old/main.cc	2003-08-27 17:52:02.000000000 +0000
+++ bochs-2.0.2+20030829/main.cc	2003-08-29 14:31:40.000000000 +0000
@@ -28,6 +28,10 @@
 #include "bochs.h"
 #include <assert.h>
 #include "state_file.h"
+#if BX_USE_PLEX86
+#include "plex86.h"
+unsigned short int using_plex86;
+#endif
 
 #ifdef HAVE_LOCALE_H
 #include <locale.h>
@@ -60,6 +64,7 @@
 
 int bochsrc_include_count = 0;
 
+
 extern "C" {
 #include <signal.h>
 }
@@ -2202,6 +2207,17 @@
   bx_dbg_main(argc, argv);
 #else
 
+#if BX_USE_PLEX86
+  // If plex86 is requested, open plex86 device.
+  if (plex86Open() > -1)
+    using_plex86 = 1;
+  else
+    {
+      using_plex86 = 0;
+      BX_INFO(("Failed to open plex86 device."));
+    }
+#endif
+  
   bx_init_hardware();
 
   if (bx_options.load32bitOSImage.OwhichOS->get ()) {
@@ -2498,7 +2514,12 @@
   signal(SIGALRM, SIG_DFL);
 #endif
 #endif
-        return 0;
+
+#if BX_USE_PLEX86
+    if (using_plex86)
+      plex86TearDown();
+#endif
+    return 0;
 }
 
 #if BX_PROVIDE_MAIN
diff -Nur bochs-2.0.2+20030829.old/memory/misc_mem.cc bochs-2.0.2+20030829/memory/misc_mem.cc
--- bochs-2.0.2+20030829.old/memory/misc_mem.cc	2003-08-06 08:24:14.000000000 +0000
+++ bochs-2.0.2+20030829/memory/misc_mem.cc	2003-08-29 14:31:40.000000000 +0000
@@ -33,7 +33,10 @@
 #include "bochs.h"
 #define LOG_THIS BX_MEM(0)->
 
-
+#if BX_USE_PLEX86
+#include "plex86.h"
+extern unsigned short int using_plex86;
+#endif
 
 #if BX_PROVIDE_CPU_MEMORY
   Bit32u
@@ -68,10 +71,23 @@
 {
   if (actual_vector != NULL) {
     BX_INFO (("freeing existing memory vector"));
-    delete [] actual_vector;
+#if BX_USE_PLEX86
+    if (!using_plex86)
+#endif
+      delete [] actual_vector;
     actual_vector = NULL;
     vector = NULL;
   }
+#if BX_USE_PLEX86
+  if (plex86State == Plex86StateFDOpened) {
+    actual_vector = vector = plex86AllocateMemory(bytes >> 20);
+    if (vector == 0) {
+      BX_PANIC(("Failed allocation of memory from plex86 device.\n"));
+      return;
+    }
+  }
+  else {
+#endif
   Bit64u test_mask = alignment - 1;
   actual_vector = new Bit8u [bytes+test_mask];
   // round address forward to nearest multiple of alignment.  Alignment 
@@ -84,6 +100,9 @@
   BX_ASSERT (vector+bytes <= actual_vector+bytes+test_mask);
   BX_INFO (("allocated memory at %p. after alignment, vector=%p", 
 	actual_vector, vector));
+#if BX_USE_PLEX86
+  }
+#endif
 }
 #endif
 
@@ -114,7 +133,10 @@
 BX_MEM_C::~BX_MEM_C(void)
 {
   if (this-> vector != NULL) {
-    delete [] actual_vector;
+#if BX_USE_PLEX86
+    if (!using_plex86)
+#endif
+      delete [] actual_vector;
     actual_vector = NULL;
     vector = NULL;
     }
diff -Nur bochs-2.0.2+20030829.old/plex86/COPYING bochs-2.0.2+20030829/plex86/COPYING
--- bochs-2.0.2+20030829.old/plex86/COPYING	2003-01-01 17:32:04.000000000 +0000
+++ bochs-2.0.2+20030829/plex86/COPYING	1970-01-01 00:00:00.000000000 +0000
@@ -1,504 +0,0 @@
-		  GNU LESSER GENERAL PUBLIC LICENSE
-		       Version 2.1, February 1999
-
- Copyright (C) 1991, 1999 Free Software Foundation, Inc.
-     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-[This is the first released version of the Lesser GPL.  It also counts
- as the successor of the GNU Library Public License, version 2, hence
- the version number 2.1.]
-
-			    Preamble
-
-  The licenses for most software are designed to take away your
-freedom to share and change it.  By contrast, the GNU General Public
-Licenses are intended to guarantee your freedom to share and change
-free software--to make sure the software is free for all its users.
-
-  This license, the Lesser General Public License, applies to some
-specially designated software packages--typically libraries--of the
-Free Software Foundation and other authors who decide to use it.  You
-can use it too, but we suggest you first think carefully about whether
-this license or the ordinary General Public License is the better
-strategy to use in any particular case, based on the explanations below.
-
-  When we speak of free software, we are referring to freedom of use,
-not price.  Our General Public Licenses are designed to make sure that
-you have the freedom to distribute copies of free software (and charge
-for this service if you wish); that you receive source code or can get
-it if you want it; that you can change the software and use pieces of
-it in new free programs; and that you are informed that you can do
-these things.
-
-  To protect your rights, we need to make restrictions that forbid
-distributors to deny you these rights or to ask you to surrender these
-rights.  These restrictions translate to certain responsibilities for
-you if you distribute copies of the library or if you modify it.
-
-  For example, if you distribute copies of the library, whether gratis
-or for a fee, you must give the recipients all the rights that we gave
-you.  You must make sure that they, too, receive or can get the source
-code.  If you link other code with the library, you must provide
-complete object files to the recipients, so that they can relink them
-with the library after making changes to the library and recompiling
-it.  And you must show them these terms so they know their rights.
-
-  We protect your rights with a two-step method: (1) we copyright the
-library, and (2) we offer you this license, which gives you legal
-permission to copy, distribute and/or modify the library.
-
-  To protect each distributor, we want to make it very clear that
-there is no warranty for the free library.  Also, if the library is
-modified by someone else and passed on, the recipients should know
-that what they have is not the original version, so that the original
-author's reputation will not be affected by problems that might be
-introduced by others.
-
-  Finally, software patents pose a constant threat to the existence of
-any free program.  We wish to make sure that a company cannot
-effectively restrict the users of a free program by obtaining a
-restrictive license from a patent holder.  Therefore, we insist that
-any patent license obtained for a version of the library must be
-consistent with the full freedom of use specified in this license.
-
-  Most GNU software, including some libraries, is covered by the
-ordinary GNU General Public License.  This license, the GNU Lesser
-General Public License, applies to certain designated libraries, and
-is quite different from the ordinary General Public License.  We use
-this license for certain libraries in order to permit linking those
-libraries into non-free programs.
-
-  When a program is linked with a library, whether statically or using
-a shared library, the combination of the two is legally speaking a
-combined work, a derivative of the original library.  The ordinary
-General Public License therefore permits such linking only if the
-entire combination fits its criteria of freedom.  The Lesser General
-Public License permits more lax criteria for linking other code with
-the library.
-
-  We call this license the "Lesser" General Public License because it
-does Less to protect the user's freedom than the ordinary General
-Public License.  It also provides other free software developers Less
-of an advantage over competing non-free programs.  These disadvantages
-are the reason we use the ordinary General Public License for many
-libraries.  However, the Lesser license provides advantages in certain
-special circumstances.
-
-  For example, on rare occasions, there may be a special need to
-encourage the widest possible use of a certain library, so that it becomes
-a de-facto standard.  To achieve this, non-free programs must be
-allowed to use the library.  A more frequent case is that a free
-library does the same job as widely used non-free libraries.  In this
-case, there is little to gain by limiting the free library to free
-software only, so we use the Lesser General Public License.
-
-  In other cases, permission to use a particular library in non-free
-programs enables a greater number of people to use a large body of
-free software.  For example, permission to use the GNU C Library in
-non-free programs enables many more people to use the whole GNU
-operating system, as well as its variant, the GNU/Linux operating
-system.
-
-  Although the Lesser General Public License is Less protective of the
-users' freedom, it does ensure that the user of a program that is
-linked with the Library has the freedom and the wherewithal to run
-that program using a modified version of the Library.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.  Pay close attention to the difference between a
-"work based on the library" and a "work that uses the library".  The
-former contains code derived from the library, whereas the latter must
-be combined with the library in order to run.
-
-		  GNU LESSER GENERAL PUBLIC LICENSE
-   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
-
-  0. This License Agreement applies to any software library or other
-program which contains a notice placed by the copyright holder or
-other authorized party saying it may be distributed under the terms of
-this Lesser General Public License (also called "this License").
-Each licensee is addressed as "you".
-
-  A "library" means a collection of software functions and/or data
-prepared so as to be conveniently linked with application programs
-(which use some of those functions and data) to form executables.
-
-  The "Library", below, refers to any such software library or work
-which has been distributed under these terms.  A "work based on the
-Library" means either the Library or any derivative work under
-copyright law: that is to say, a work containing the Library or a
-portion of it, either verbatim or with modifications and/or translated
-straightforwardly into another language.  (Hereinafter, translation is
-included without limitation in the term "modification".)
-
-  "Source code" for a work means the preferred form of the work for
-making modifications to it.  For a library, complete source code means
-all the source code for all modules it contains, plus any associated
-interface definition files, plus the scripts used to control compilation
-and installation of the library.
-
-  Activities other than copying, distribution and modification are not
-covered by this License; they are outside its scope.  The act of
-running a program using the Library is not restricted, and output from
-such a program is covered only if its contents constitute a work based
-on the Library (independent of the use of the Library in a tool for
-writing it).  Whether that is true depends on what the Library does
-and what the program that uses the Library does.
-  
-  1. You may copy and distribute verbatim copies of the Library's
-complete source code as you receive it, in any medium, provided that
-you conspicuously and appropriately publish on each copy an
-appropriate copyright notice and disclaimer of warranty; keep intact
-all the notices that refer to this License and to the absence of any
-warranty; and distribute a copy of this License along with the
-Library.
-
-  You may charge a fee for the physical act of transferring a copy,
-and you may at your option offer warranty protection in exchange for a
-fee.
-
-  2. You may modify your copy or copies of the Library or any portion
-of it, thus forming a work based on the Library, and copy and
-distribute such modifications or work under the terms of Section 1
-above, provided that you also meet all of these conditions:
-
-    a) The modified work must itself be a software library.
-
-    b) You must cause the files modified to carry prominent notices
-    stating that you changed the files and the date of any change.
-
-    c) You must cause the whole of the work to be licensed at no
-    charge to all third parties under the terms of this License.
-
-    d) If a facility in the modified Library refers to a function or a
-    table of data to be supplied by an application program that uses
-    the facility, other than as an argument passed when the facility
-    is invoked, then you must make a good faith effort to ensure that,
-    in the event an application does not supply such function or
-    table, the facility still operates, and performs whatever part of
-    its purpose remains meaningful.
-
-    (For example, a function in a library to compute square roots has
-    a purpose that is entirely well-defined independent of the
-    application.  Therefore, Subsection 2d requires that any
-    application-supplied function or table used by this function must
-    be optional: if the application does not supply it, the square
-    root function must still compute square roots.)
-
-These requirements apply to the modified work as a whole.  If
-identifiable sections of that work are not derived from the Library,
-and can be reasonably considered independent and separate works in
-themselves, then this License, and its terms, do not apply to those
-sections when you distribute them as separate works.  But when you
-distribute the same sections as part of a whole which is a work based
-on the Library, the distribution of the whole must be on the terms of
-this License, whose permissions for other licensees extend to the
-entire whole, and thus to each and every part regardless of who wrote
-it.
-
-Thus, it is not the intent of this section to claim rights or contest
-your rights to work written entirely by you; rather, the intent is to
-exercise the right to control the distribution of derivative or
-collective works based on the Library.
-
-In addition, mere aggregation of another work not based on the Library
-with the Library (or with a work based on the Library) on a volume of
-a storage or distribution medium does not bring the other work under
-the scope of this License.
-
-  3. You may opt to apply the terms of the ordinary GNU General Public
-License instead of this License to a given copy of the Library.  To do
-this, you must alter all the notices that refer to this License, so
-that they refer to the ordinary GNU General Public License, version 2,
-instead of to this License.  (If a newer version than version 2 of the
-ordinary GNU General Public License has appeared, then you can specify
-that version instead if you wish.)  Do not make any other change in
-these notices.
-
-  Once this change is made in a given copy, it is irreversible for
-that copy, so the ordinary GNU General Public License applies to all
-subsequent copies and derivative works made from that copy.
-
-  This option is useful when you wish to copy part of the code of
-the Library into a program that is not a library.
-
-  4. You may copy and distribute the Library (or a portion or
-derivative of it, under Section 2) in object code or executable form
-under the terms of Sections 1 and 2 above provided that you accompany
-it with the complete corresponding machine-readable source code, which
-must be distributed under the terms of Sections 1 and 2 above on a
-medium customarily used for software interchange.
-
-  If distribution of object code is made by offering access to copy
-from a designated place, then offering equivalent access to copy the
-source code from the same place satisfies the requirement to
-distribute the source code, even though third parties are not
-compelled to copy the source along with the object code.
-
-  5. A program that contains no derivative of any portion of the
-Library, but is designed to work with the Library by being compiled or
-linked with it, is called a "work that uses the Library".  Such a
-work, in isolation, is not a derivative work of the Library, and
-therefore falls outside the scope of this License.
-
-  However, linking a "work that uses the Library" with the Library
-creates an executable that is a derivative of the Library (because it
-contains portions of the Library), rather than a "work that uses the
-library".  The executable is therefore covered by this License.
-Section 6 states terms for distribution of such executables.
-
-  When a "work that uses the Library" uses material from a header file
-that is part of the Library, the object code for the work may be a
-derivative work of the Library even though the source code is not.
-Whether this is true is especially significant if the work can be
-linked without the Library, or if the work is itself a library.  The
-threshold for this to be true is not precisely defined by law.
-
-  If such an object file uses only numerical parameters, data
-structure layouts and accessors, and small macros and small inline
-functions (ten lines or less in length), then the use of the object
-file is unrestricted, regardless of whether it is legally a derivative
-work.  (Executables containing this object code plus portions of the
-Library will still fall under Section 6.)
-
-  Otherwise, if the work is a derivative of the Library, you may
-distribute the object code for the work under the terms of Section 6.
-Any executables containing that work also fall under Section 6,
-whether or not they are linked directly with the Library itself.
-
-  6. As an exception to the Sections above, you may also combine or
-link a "work that uses the Library" with the Library to produce a
-work containing portions of the Library, and distribute that work
-under terms of your choice, provided that the terms permit
-modification of the work for the customer's own use and reverse
-engineering for debugging such modifications.
-
-  You must give prominent notice with each copy of the work that the
-Library is used in it and that the Library and its use are covered by
-this License.  You must supply a copy of this License.  If the work
-during execution displays copyright notices, you must include the
-copyright notice for the Library among them, as well as a reference
-directing the user to the copy of this License.  Also, you must do one
-of these things:
-
-    a) Accompany the work with the complete corresponding
-    machine-readable source code for the Library including whatever
-    changes were used in the work (which must be distributed under
-    Sections 1 and 2 above); and, if the work is an executable linked
-    with the Library, with the complete machine-readable "work that
-    uses the Library", as object code and/or source code, so that the
-    user can modify the Library and then relink to produce a modified
-    executable containing the modified Library.  (It is understood
-    that the user who changes the contents of definitions files in the
-    Library will not necessarily be able to recompile the application
-    to use the modified definitions.)
-
-    b) Use a suitable shared library mechanism for linking with the
-    Library.  A suitable mechanism is one that (1) uses at run time a
-    copy of the library already present on the user's computer system,
-    rather than copying library functions into the executable, and (2)
-    will operate properly with a modified version of the library, if
-    the user installs one, as long as the modified version is
-    interface-compatible with the version that the work was made with.
-
-    c) Accompany the work with a written offer, valid for at
-    least three years, to give the same user the materials
-    specified in Subsection 6a, above, for a charge no more
-    than the cost of performing this distribution.
-
-    d) If distribution of the work is made by offering access to copy
-    from a designated place, offer equivalent access to copy the above
-    specified materials from the same place.
-
-    e) Verify that the user has already received a copy of these
-    materials or that you have already sent this user a copy.
-
-  For an executable, the required form of the "work that uses the
-Library" must include any data and utility programs needed for
-reproducing the executable from it.  However, as a special exception,
-the materials to be distributed need not include anything that is
-normally distributed (in either source or binary form) with the major
-components (compiler, kernel, and so on) of the operating system on
-which the executable runs, unless that component itself accompanies
-the executable.
-
-  It may happen that this requirement contradicts the license
-restrictions of other proprietary libraries that do not normally
-accompany the operating system.  Such a contradiction means you cannot
-use both them and the Library together in an executable that you
-distribute.
-
-  7. You may place library facilities that are a work based on the
-Library side-by-side in a single library together with other library
-facilities not covered by this License, and distribute such a combined
-library, provided that the separate distribution of the work based on
-the Library and of the other library facilities is otherwise
-permitted, and provided that you do these two things:
-
-    a) Accompany the combined library with a copy of the same work
-    based on the Library, uncombined with any other library
-    facilities.  This must be distributed under the terms of the
-    Sections above.
-
-    b) Give prominent notice with the combined library of the fact
-    that part of it is a work based on the Library, and explaining
-    where to find the accompanying uncombined form of the same work.
-
-  8. You may not copy, modify, sublicense, link with, or distribute
-the Library except as expressly provided under this License.  Any
-attempt otherwise to copy, modify, sublicense, link with, or
-distribute the Library is void, and will automatically terminate your
-rights under this License.  However, parties who have received copies,
-or rights, from you under this License will not have their licenses
-terminated so long as such parties remain in full compliance.
-
-  9. You are not required to accept this License, since you have not
-signed it.  However, nothing else grants you permission to modify or
-distribute the Library or its derivative works.  These actions are
-prohibited by law if you do not accept this License.  Therefore, by
-modifying or distributing the Library (or any work based on the
-Library), you indicate your acceptance of this License to do so, and
-all its terms and conditions for copying, distributing or modifying
-the Library or works based on it.
-
-  10. Each time you redistribute the Library (or any work based on the
-Library), the recipient automatically receives a license from the
-original licensor to copy, distribute, link with or modify the Library
-subject to these terms and conditions.  You may not impose any further
-restrictions on the recipients' exercise of the rights granted herein.
-You are not responsible for enforcing compliance by third parties with
-this License.
-
-  11. If, as a consequence of a court judgment or allegation of patent
-infringement or for any other reason (not limited to patent issues),
-conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot
-distribute so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you
-may not distribute the Library at all.  For example, if a patent
-license would not permit royalty-free redistribution of the Library by
-all those who receive copies directly or indirectly through you, then
-the only way you could satisfy both it and this License would be to
-refrain entirely from distribution of the Library.
-
-If any portion of this section is held invalid or unenforceable under any
-particular circumstance, the balance of the section is intended to apply,
-and the section as a whole is intended to apply in other circumstances.
-
-It is not the purpose of this section to induce you to infringe any
-patents or other property right claims or to contest validity of any
-such claims; this section has the sole purpose of protecting the
-integrity of the free software distribution system which is
-implemented by public license practices.  Many people have made
-generous contributions to the wide range of software distributed
-through that system in reliance on consistent application of that
-system; it is up to the author/donor to decide if he or she is willing
-to distribute software through any other system and a licensee cannot
-impose that choice.
-
-This section is intended to make thoroughly clear what is believed to
-be a consequence of the rest of this License.
-
-  12. If the distribution and/or use of the Library is restricted in
-certain countries either by patents or by copyrighted interfaces, the
-original copyright holder who places the Library under this License may add
-an explicit geographical distribution limitation excluding those countries,
-so that distribution is permitted only in or among countries not thus
-excluded.  In such case, this License incorporates the limitation as if
-written in the body of this License.
-
-  13. The Free Software Foundation may publish revised and/or new
-versions of the Lesser General Public License from time to time.
-Such new versions will be similar in spirit to the present version,
-but may differ in detail to address new problems or concerns.
-
-Each version is given a distinguishing version number.  If the Library
-specifies a version number of this License which applies to it and
-"any later version", you have the option of following the terms and
-conditions either of that version or of any later version published by
-the Free Software Foundation.  If the Library does not specify a
-license version number, you may choose any version ever published by
-the Free Software Foundation.
-
-  14. If you wish to incorporate parts of the Library into other free
-programs whose distribution conditions are incompatible with these,
-write to the author to ask for permission.  For software which is
-copyrighted by the Free Software Foundation, write to the Free
-Software Foundation; we sometimes make exceptions for this.  Our
-decision will be guided by the two goals of preserving the free status
-of all derivatives of our free software and of promoting the sharing
-and reuse of software generally.
-
-			    NO WARRANTY
-
-  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
-WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
-EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
-OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
-KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
-PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
-LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
-THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
-
-  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
-WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
-AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
-FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
-CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
-LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
-RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
-FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
-SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
-DAMAGES.
-
-		     END OF TERMS AND CONDITIONS
-
-           How to Apply These Terms to Your New Libraries
-
-  If you develop a new library, and you want it to be of the greatest
-possible use to the public, we recommend making it free software that
-everyone can redistribute and change.  You can do so by permitting
-redistribution under these terms (or, alternatively, under the terms of the
-ordinary General Public License).
-
-  To apply these terms, attach the following notices to the library.  It is
-safest to attach them to the start of each source file to most effectively
-convey the exclusion of warranty; and each file should have at least the
-"copyright" line and a pointer to where the full notice is found.
-
-    <one line to give the library's name and a brief idea of what it does.>
-    Copyright (C) <year>  <name of author>
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Lesser General Public
-    License as published by the Free Software Foundation; either
-    version 2 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public
-    License along with this library; if not, write to the Free Software
-    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-
-Also add information on how to contact you by electronic and paper mail.
-
-You should also get your employer (if you work as a programmer) or your
-school, if any, to sign a "copyright disclaimer" for the library, if
-necessary.  Here is a sample; alter the names:
-
-  Yoyodyne, Inc., hereby disclaims all copyright interest in the
-  library `Frob' (a library for tweaking knobs) written by James Random Hacker.
-
-  <signature of Ty Coon>, 1 April 1990
-  Ty Coon, President of Vice
-
-That's all there is to it!
-
-
diff -Nur bochs-2.0.2+20030829.old/plex86/Makefile.in bochs-2.0.2+20030829/plex86/Makefile.in
--- bochs-2.0.2+20030829.old/plex86/Makefile.in	2003-01-01 17:32:04.000000000 +0000
+++ bochs-2.0.2+20030829/plex86/Makefile.in	1970-01-01 00:00:00.000000000 +0000
@@ -1,46 +0,0 @@
-#  plex86: run multiple x86 operating systems concurrently
-#  Copyright (C) 1999-2000  Kevin P. Lawton
-#
-#  This library is free software; you can redistribute it and/or
-#  modify it under the terms of the GNU Lesser General Public
-#  License as published by the Free Software Foundation; either
-#  version 2 of the License, or (at your option) any later version.
-#
-#  This library is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-#  Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public
-#  License along with this library; if not, write to the Free Software
-#  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-
-.PHONY: all clean dist-clean
-
-
-# Get variables from shell, or override if specified to make
-CC      = @CC@
-CFLAGS  = @CFLAGS@
-LDFLAGS = @LDFLAGS@
-
-srcdir	= @srcdir@
-VPATH	= @srcdir@
-
-MDEFINES = CC="$(CC)" CFLAGS="$(CFLAGS)" \
-           LDFLAGS="$(LDFLAGS)"
-
-all:
-	$(MAKE) -C kernel $(MDEFINES)
-
-
-clean: 
-	$(MAKE) -C kernel clean
-
-dist-clean: 
-	$(MAKE) -C kernel dist-clean
-	/bin/rm -f config.status config.cache config.log
-	/bin/rm -f Makefile config.h
-
-Makefile:	Makefile.in config.status
-		CONFIG_FILES=Makefile CONFIG_HEADERS= $(SHELL) config.status
-
diff -Nur bochs-2.0.2+20030829.old/plex86/PERFORMANCE bochs-2.0.2+20030829/plex86/PERFORMANCE
--- bochs-2.0.2+20030829.old/plex86/PERFORMANCE	2003-01-01 17:32:04.000000000 +0000
+++ bochs-2.0.2+20030829/plex86/PERFORMANCE	1970-01-01 00:00:00.000000000 +0000
@@ -1,17 +0,0 @@
-PERFORMANCE
-===========
-
-Optimize functions in util-nexus.c: mon_memzero, mon_memcpy, mon_memset
-  They could be done a lot more efficiently.
-  Perhaps make mon_memzero function specifically for pages.
-
-Pseudo devices and special guest-OS specific device drivers for
-  disk/network/video/etc and an associated architecture.  This would
-  let us pass data more quickly and prevent a lot of emulation overhead.
-  The real device emulation could plug into the same architecture as
-  the pseudo devices.
-
-
-Fix extra CR3 reload in nexus.S
-
-Alignment of routines in mon-fault.c
diff -Nur bochs-2.0.2+20030829.old/plex86/TODO bochs-2.0.2+20030829/plex86/TODO
--- bochs-2.0.2+20030829.old/plex86/TODO	2003-01-09 04:02:30.000000000 +0000
+++ bochs-2.0.2+20030829/plex86/TODO	1970-01-01 00:00:00.000000000 +0000
@@ -1,80 +0,0 @@
-Main monitor loop should compare cycles burned thus far vs
-  cycles requested, so it doesn't keep bopping back and forth
-  between host-kernel and monitor spaces without returning to
-  user space.
-
-Fix monPrint and friends.
-monpanic breaks up into 2 monprints which hit user space twice.
-
-Could put the GDT/LDT in linear memory where the guest
-  expects them.
-
-Synchronize page writes with iCache in bochs.
-
-Deal with cycle counts of guest execution in VM, and in
-  bochs/plex86 shim.
-
-Deal with page_usage.  How do we update this between timeslices?
-  Do we always clear it?  Maybe we should keep a log of things to
-  clear (page_usage, GDT entries, PDE entries, ...) and clear those
-  before returning to user space.
-
-GDT entries for guest need to be cleared upon return from guest
-  execution, or just cleared before invocation of the guest.
-
-Task segment must be a 32-bit'er.
-
-Save/restore floating point state of host/VM.
-
-deduct off some cycles for the IRET/int sequence.
-
-Conditions for bochs compile using plex86:
-  - Not compiled for debug
-  - x86 host
-  - Not PCI supported (for now).
-
-paging-mon.c:  We can eliminate any code other than CPL==3.
-
-Fix extra PDBR reload in nexus.S
-
-Manipulation/reading of host page tables needs to be SMP/preempt
-  compatible.  Need to do spin-lock (big kernel lock for old Linux)
-  on vma.
-
-==================== From previous plex86 TODO file ====================
-
-  This is a list of the major tasks/achievements/milestones yet to-do.
-  We should keep this list prioritized, creating sort of a road map.
-  Hopefully, this will reduce duplicate suggestions on the developers
-  channels, and let people know where we are in the development process.
-  Entries listed first have highest priority.
-
-  <NEAR-TERM>
-  - Fix plex86 on Linux 2.4.x/SMP or with 1P and LAPIC enabled.
-
-  - Save FPU state on host <--> monitor context switch.
-
-  - Special guest-specific drivers and special emulated pseudo-devices
-    for faster graphics/network/disk access.
-
-  - Allow some of the inactive guest pages be host swappable.
-    Currently, all pages are locked down.
-
-  - Many performance enhancements (see PERFORMANCE)
-
-  - Allow memory to be mapped anywhere in the physical address
-    space.
-
-  - Allow certain guest pages to be swap eligible by the host.
-    This means they will have to be unavailable by the guest
-    during that time.  Need a dynamic algorith for this.
-
-  - Test on 2.4 with SMP/APIC enabled on single processor machine.
-
-  - Deal with guest use of TF.
-
-  - Deal with LDT
-
-
-unallocVmPages/unreserve_guest_pages called twice,
-  release & teardown.
diff -Nur bochs-2.0.2+20030829.old/plex86/bochs-plex86-notes bochs-2.0.2+20030829/plex86/bochs-plex86-notes
--- bochs-2.0.2+20030829.old/plex86/bochs-plex86-notes	1970-01-01 00:00:00.000000000 +0000
+++ bochs-2.0.2+20030829/plex86/bochs-plex86-notes	2003-08-29 14:31:40.000000000 +0000
@@ -0,0 +1,30 @@
+
+
+  To get Bochs using a Plex86 backend, you'll have to:
+
+    - build bochs with --enable-plex86
+    - build plex86 [1]
+    - use [plex86]/misc/load_module to insert the plex86 kernel module
+      and setup the plex86 device (/dev/plex86)
+    - run bochs
+
+[1] http://savannah.nongnu.org/projects/plex86
+
+  Some notes from Kevin:
+
+	  Likely, bochs+plex86 will panic on OSes other than the one I tried
+	  due to a matrix of CR0/CR4/EFLAGS values which we can support over
+	  time.  I have things duct-taped together to demo this.  Please stick
+	  to just this test, or else your machine will likely erupt into
+	  flames.
+
+	  Don't run this on a machine with important data!!!  It's experimental
+	  Need I say more?
+	
+	  The new plex86 VM is user-level only.  It will only kick in when
+	  Pragma mounts the filesystem embedded in the floppy image.
+
+	  I'd like to get confirmation that of performance on your native
+	  machine vs the bochs+plex86VM for that a.out test.
+
+	-Kevin
diff -Nur bochs-2.0.2+20030829.old/plex86/config.h.in bochs-2.0.2+20030829/plex86/config.h.in
--- bochs-2.0.2+20030829.old/plex86/config.h.in	2003-01-01 17:32:04.000000000 +0000
+++ bochs-2.0.2+20030829/plex86/config.h.in	1970-01-01 00:00:00.000000000 +0000
@@ -1,63 +0,0 @@
-/* our plex86 compile time configuration options will go here */
-
-#ifndef _CONFIG_H_
-#define _CONFIG_H_
-
-#define VERSION "Plex86 2002/07/11"
-#define BUGSMAIL "plex86-devel@mail.freesoftware.fsf.org"
-
-/* Might need these for some host OS. */
-#define SIZEOF_UNSIGNED_CHAR      0
-#define SIZEOF_UNSIGNED_SHORT     0
-#define SIZEOF_UNSIGNED_INT       0
-#define SIZEOF_UNSIGNED_LONG      0
-#define SIZEOF_UNSIGNED_LONG_LONG 0
-
-#if SIZEOF_UNSIGNED_CHAR != 1
-#  error "sizeof (unsigned char) != 1"
-#else
-  typedef unsigned char Bit8u;
-  typedef   signed char Bit8s;
-#endif
-
-#if SIZEOF_UNSIGNED_SHORT != 2
-#  error "sizeof (unsigned short) != 2"
-#else
-  typedef unsigned short Bit16u;
-  typedef   signed short Bit16s;
-#endif
-
-#if SIZEOF_UNSIGNED_INT == 4
-  typedef unsigned int Bit32u;
-  typedef   signed int Bit32s;
-#elif SIZEOF_UNSIGNED_LONG == 4
-  typedef unsigned long Bit32u;
-  typedef   signed long Bit32s;
-#else
-#  error "can't find sizeof(type) of 4 bytes!"
-#endif
-
-#if SIZEOF_UNSIGNED_LONG == 8
-  typedef unsigned long Bit64u;
-  typedef   signed long Bit64s;
-#elif SIZEOF_UNSIGNED_LONG_LONG == 8
-  typedef unsigned long long Bit64u;
-  typedef   signed long long Bit64s;
-#else
-#  error "can't find data type of 8 bytes"
-#endif
-
-typedef unsigned int Boolean;
-
-/*
- * NetBSD just has off_t, which is 64 bits, not loff_t.
- */
-#ifdef __NetBSD__
-typedef unsigned long long loff_t;
-#endif
-
-
-/* Some plex86 customization options. */
-#define ANAL_CHECKS 1
-
-#endif /* _CONFIG_H_ */
diff -Nur bochs-2.0.2+20030829.old/plex86/configure bochs-2.0.2+20030829/plex86/configure
--- bochs-2.0.2+20030829.old/plex86/configure	2003-01-01 17:32:04.000000000 +0000
+++ bochs-2.0.2+20030829/plex86/configure	1970-01-01 00:00:00.000000000 +0000
@@ -1,2535 +0,0 @@
-#! /bin/sh
-
-# Guess values for system-dependent variables and create Makefiles.
-# Generated automatically using autoconf version 2.13 
-# Copyright (C) 1992, 93, 94, 95, 96 Free Software Foundation, Inc.
-#
-# This configure script is free software; the Free Software Foundation
-# gives unlimited permission to copy, distribute and modify it.
-
-# Defaults:
-ac_help=
-ac_default_prefix=/usr/local
-# Any additions from configure.in:
-ac_help="$ac_help
-  --with-x                use the X Window System"
-ac_help="$ac_help
-  --with-WinNT                      WinNT host"
-ac_help="$ac_help
-  --with-BeOS                       BeOS host"
-ac_help="$ac_help
-  --with-Linux                      Linux host"
-ac_help="$ac_help
-  --with-NetBSD                     NetBSD host"
-ac_help="$ac_help
-  --with-FreeBSD                    FreeBSD host"
-ac_help="$ac_help
-  --with-null                       No real host"
-ac_help="$ac_help
-  --with-linux-source=dir           Linux kernel source dir"
-ac_help="$ac_help
-  --with-netbsd-source=dir          NetBSD kernel source dir"
-ac_help="$ac_help
-  --with-freebsd-source=dir          FreeBSD kernel source dir"
-
-# Initialize some variables set by options.
-# The variables have the same names as the options, with
-# dashes changed to underlines.
-build=NONE
-cache_file=./config.cache
-exec_prefix=NONE
-host=NONE
-no_create=
-nonopt=NONE
-no_recursion=
-prefix=NONE
-program_prefix=NONE
-program_suffix=NONE
-program_transform_name=s,x,x,
-silent=
-site=
-srcdir=
-target=NONE
-verbose=
-x_includes=NONE
-x_libraries=NONE
-bindir='${exec_prefix}/bin'
-sbindir='${exec_prefix}/sbin'
-libexecdir='${exec_prefix}/libexec'
-datadir='${prefix}/share'
-sysconfdir='${prefix}/etc'
-sharedstatedir='${prefix}/com'
-localstatedir='${prefix}/var'
-libdir='${exec_prefix}/lib'
-includedir='${prefix}/include'
-oldincludedir='/usr/include'
-infodir='${prefix}/info'
-mandir='${prefix}/man'
-
-# Initialize some other variables.
-subdirs=
-MFLAGS= MAKEFLAGS=
-SHELL=${CONFIG_SHELL-/bin/sh}
-# Maximum number of lines to put in a shell here document.
-ac_max_here_lines=12
-
-ac_prev=
-for ac_option
-do
-
-  # If the previous option needs an argument, assign it.
-  if test -n "$ac_prev"; then
-    eval "$ac_prev=\$ac_option"
-    ac_prev=
-    continue
-  fi
-
-  case "$ac_option" in
-  -*=*) ac_optarg=`echo "$ac_option" | sed 's/[-_a-zA-Z0-9]*=//'` ;;
-  *) ac_optarg= ;;
-  esac
-
-  # Accept the important Cygnus configure options, so we can diagnose typos.
-
-  case "$ac_option" in
-
-  -bindir | --bindir | --bindi | --bind | --bin | --bi)
-    ac_prev=bindir ;;
-  -bindir=* | --bindir=* | --bindi=* | --bind=* | --bin=* | --bi=*)
-    bindir="$ac_optarg" ;;
-
-  -build | --build | --buil | --bui | --bu)
-    ac_prev=build ;;
-  -build=* | --build=* | --buil=* | --bui=* | --bu=*)
-    build="$ac_optarg" ;;
-
-  -cache-file | --cache-file | --cache-fil | --cache-fi \
-  | --cache-f | --cache- | --cache | --cach | --cac | --ca | --c)
-    ac_prev=cache_file ;;
-  -cache-file=* | --cache-file=* | --cache-fil=* | --cache-fi=* \
-  | --cache-f=* | --cache-=* | --cache=* | --cach=* | --cac=* | --ca=* | --c=*)
-    cache_file="$ac_optarg" ;;
-
-  -datadir | --datadir | --datadi | --datad | --data | --dat | --da)
-    ac_prev=datadir ;;
-  -datadir=* | --datadir=* | --datadi=* | --datad=* | --data=* | --dat=* \
-  | --da=*)
-    datadir="$ac_optarg" ;;
-
-  -disable-* | --disable-*)
-    ac_feature=`echo $ac_option|sed -e 's/-*disable-//'`
-    # Reject names that are not valid shell variable names.
-    if test -n "`echo $ac_feature| sed 's/[-a-zA-Z0-9_]//g'`"; then
-      { echo "configure: error: $ac_feature: invalid feature name" 1>&2; exit 1; }
-    fi
-    ac_feature=`echo $ac_feature| sed 's/-/_/g'`
-    eval "enable_${ac_feature}=no" ;;
-
-  -enable-* | --enable-*)
-    ac_feature=`echo $ac_option|sed -e 's/-*enable-//' -e 's/=.*//'`
-    # Reject names that are not valid shell variable names.
-    if test -n "`echo $ac_feature| sed 's/[-_a-zA-Z0-9]//g'`"; then
-      { echo "configure: error: $ac_feature: invalid feature name" 1>&2; exit 1; }
-    fi
-    ac_feature=`echo $ac_feature| sed 's/-/_/g'`
-    case "$ac_option" in
-      *=*) ;;
-      *) ac_optarg=yes ;;
-    esac
-    eval "enable_${ac_feature}='$ac_optarg'" ;;
-
-  -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi \
-  | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- \
-  | --exec | --exe | --ex)
-    ac_prev=exec_prefix ;;
-  -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* \
-  | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* \
-  | --exec=* | --exe=* | --ex=*)
-    exec_prefix="$ac_optarg" ;;
-
-  -gas | --gas | --ga | --g)
-    # Obsolete; use --with-gas.
-    with_gas=yes ;;
-
-  -help | --help | --hel | --he)
-    # Omit some internal or obsolete options to make the list less imposing.
-    # This message is too long to be a string in the A/UX 3.1 sh.
-    cat << EOF
-Usage: configure [options] [host]
-Options: [defaults in brackets after descriptions]
-Configuration:
-  --cache-file=FILE       cache test results in FILE
-  --help                  print this message
-  --no-create             do not create output files
-  --quiet, --silent       do not print \`checking...' messages
-  --version               print the version of autoconf that created configure
-Directory and file names:
-  --prefix=PREFIX         install architecture-independent files in PREFIX
-                          [$ac_default_prefix]
-  --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX
-                          [same as prefix]
-  --bindir=DIR            user executables in DIR [EPREFIX/bin]
-  --sbindir=DIR           system admin executables in DIR [EPREFIX/sbin]
-  --libexecdir=DIR        program executables in DIR [EPREFIX/libexec]
-  --datadir=DIR           read-only architecture-independent data in DIR
-                          [PREFIX/share]
-  --sysconfdir=DIR        read-only single-machine data in DIR [PREFIX/etc]
-  --sharedstatedir=DIR    modifiable architecture-independent data in DIR
-                          [PREFIX/com]
-  --localstatedir=DIR     modifiable single-machine data in DIR [PREFIX/var]
-  --libdir=DIR            object code libraries in DIR [EPREFIX/lib]
-  --includedir=DIR        C header files in DIR [PREFIX/include]
-  --oldincludedir=DIR     C header files for non-gcc in DIR [/usr/include]
-  --infodir=DIR           info documentation in DIR [PREFIX/info]
-  --mandir=DIR            man documentation in DIR [PREFIX/man]
-  --srcdir=DIR            find the sources in DIR [configure dir or ..]
-  --program-prefix=PREFIX prepend PREFIX to installed program names
-  --program-suffix=SUFFIX append SUFFIX to installed program names
-  --program-transform-name=PROGRAM
-                          run sed PROGRAM on installed program names
-EOF
-    cat << EOF
-Host type:
-  --build=BUILD           configure for building on BUILD [BUILD=HOST]
-  --host=HOST             configure for HOST [guessed]
-  --target=TARGET         configure for TARGET [TARGET=HOST]
-Features and packages:
-  --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
-  --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
-  --with-PACKAGE[=ARG]    use PACKAGE [ARG=yes]
-  --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
-  --x-includes=DIR        X include files are in DIR
-  --x-libraries=DIR       X library files are in DIR
-EOF
-    if test -n "$ac_help"; then
-      echo "--enable and --with options recognized:$ac_help"
-    fi
-    exit 0 ;;
-
-  -host | --host | --hos | --ho)
-    ac_prev=host ;;
-  -host=* | --host=* | --hos=* | --ho=*)
-    host="$ac_optarg" ;;
-
-  -includedir | --includedir | --includedi | --included | --include \
-  | --includ | --inclu | --incl | --inc)
-    ac_prev=includedir ;;
-  -includedir=* | --includedir=* | --includedi=* | --included=* | --include=* \
-  | --includ=* | --inclu=* | --incl=* | --inc=*)
-    includedir="$ac_optarg" ;;
-
-  -infodir | --infodir | --infodi | --infod | --info | --inf)
-    ac_prev=infodir ;;
-  -infodir=* | --infodir=* | --infodi=* | --infod=* | --info=* | --inf=*)
-    infodir="$ac_optarg" ;;
-
-  -libdir | --libdir | --libdi | --libd)
-    ac_prev=libdir ;;
-  -libdir=* | --libdir=* | --libdi=* | --libd=*)
-    libdir="$ac_optarg" ;;
-
-  -libexecdir | --libexecdir | --libexecdi | --libexecd | --libexec \
-  | --libexe | --libex | --libe)
-    ac_prev=libexecdir ;;
-  -libexecdir=* | --libexecdir=* | --libexecdi=* | --libexecd=* | --libexec=* \
-  | --libexe=* | --libex=* | --libe=*)
-    libexecdir="$ac_optarg" ;;
-
-  -localstatedir | --localstatedir | --localstatedi | --localstated \
-  | --localstate | --localstat | --localsta | --localst \
-  | --locals | --local | --loca | --loc | --lo)
-    ac_prev=localstatedir ;;
-  -localstatedir=* | --localstatedir=* | --localstatedi=* | --localstated=* \
-  | --localstate=* | --localstat=* | --localsta=* | --localst=* \
-  | --locals=* | --local=* | --loca=* | --loc=* | --lo=*)
-    localstatedir="$ac_optarg" ;;
-
-  -mandir | --mandir | --mandi | --mand | --man | --ma | --m)
-    ac_prev=mandir ;;
-  -mandir=* | --mandir=* | --mandi=* | --mand=* | --man=* | --ma=* | --m=*)
-    mandir="$ac_optarg" ;;
-
-  -nfp | --nfp | --nf)
-    # Obsolete; use --without-fp.
-    with_fp=no ;;
-
-  -no-create | --no-create | --no-creat | --no-crea | --no-cre \
-  | --no-cr | --no-c)
-    no_create=yes ;;
-
-  -no-recursion | --no-recursion | --no-recursio | --no-recursi \
-  | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r)
-    no_recursion=yes ;;
-
-  -oldincludedir | --oldincludedir | --oldincludedi | --oldincluded \
-  | --oldinclude | --oldinclud | --oldinclu | --oldincl | --oldinc \
-  | --oldin | --oldi | --old | --ol | --o)
-    ac_prev=oldincludedir ;;
-  -oldincludedir=* | --oldincludedir=* | --oldincludedi=* | --oldincluded=* \
-  | --oldinclude=* | --oldinclud=* | --oldinclu=* | --oldincl=* | --oldinc=* \
-  | --oldin=* | --oldi=* | --old=* | --ol=* | --o=*)
-    oldincludedir="$ac_optarg" ;;
-
-  -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
-    ac_prev=prefix ;;
-  -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
-    prefix="$ac_optarg" ;;
-
-  -program-prefix | --program-prefix | --program-prefi | --program-pref \
-  | --program-pre | --program-pr | --program-p)
-    ac_prev=program_prefix ;;
-  -program-prefix=* | --program-prefix=* | --program-prefi=* \
-  | --program-pref=* | --program-pre=* | --program-pr=* | --program-p=*)
-    program_prefix="$ac_optarg" ;;
-
-  -program-suffix | --program-suffix | --program-suffi | --program-suff \
-  | --program-suf | --program-su | --program-s)
-    ac_prev=program_suffix ;;
-  -program-suffix=* | --program-suffix=* | --program-suffi=* \
-  | --program-suff=* | --program-suf=* | --program-su=* | --program-s=*)
-    program_suffix="$ac_optarg" ;;
-
-  -program-transform-name | --program-transform-name \
-  | --program-transform-nam | --program-transform-na \
-  | --program-transform-n | --program-transform- \
-  | --program-transform | --program-transfor \
-  | --program-transfo | --program-transf \
-  | --program-trans | --program-tran \
-  | --progr-tra | --program-tr | --program-t)
-    ac_prev=program_transform_name ;;
-  -program-transform-name=* | --program-transform-name=* \
-  | --program-transform-nam=* | --program-transform-na=* \
-  | --program-transform-n=* | --program-transform-=* \
-  | --program-transform=* | --program-transfor=* \
-  | --program-transfo=* | --program-transf=* \
-  | --program-trans=* | --program-tran=* \
-  | --progr-tra=* | --program-tr=* | --program-t=*)
-    program_transform_name="$ac_optarg" ;;
-
-  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
-  | -silent | --silent | --silen | --sile | --sil)
-    silent=yes ;;
-
-  -sbindir | --sbindir | --sbindi | --sbind | --sbin | --sbi | --sb)
-    ac_prev=sbindir ;;
-  -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \
-  | --sbi=* | --sb=*)
-    sbindir="$ac_optarg" ;;
-
-  -sharedstatedir | --sharedstatedir | --sharedstatedi \
-  | --sharedstated | --sharedstate | --sharedstat | --sharedsta \
-  | --sharedst | --shareds | --shared | --share | --shar \
-  | --sha | --sh)
-    ac_prev=sharedstatedir ;;
-  -sharedstatedir=* | --sharedstatedir=* | --sharedstatedi=* \
-  | --sharedstated=* | --sharedstate=* | --sharedstat=* | --sharedsta=* \
-  | --sharedst=* | --shareds=* | --shared=* | --share=* | --shar=* \
-  | --sha=* | --sh=*)
-    sharedstatedir="$ac_optarg" ;;
-
-  -site | --site | --sit)
-    ac_prev=site ;;
-  -site=* | --site=* | --sit=*)
-    site="$ac_optarg" ;;
-
-  -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)
-    ac_prev=srcdir ;;
-  -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)
-    srcdir="$ac_optarg" ;;
-
-  -sysconfdir | --sysconfdir | --sysconfdi | --sysconfd | --sysconf \
-  | --syscon | --sysco | --sysc | --sys | --sy)
-    ac_prev=sysconfdir ;;
-  -sysconfdir=* | --sysconfdir=* | --sysconfdi=* | --sysconfd=* | --sysconf=* \
-  | --syscon=* | --sysco=* | --sysc=* | --sys=* | --sy=*)
-    sysconfdir="$ac_optarg" ;;
-
-  -target | --target | --targe | --targ | --tar | --ta | --t)
-    ac_prev=target ;;
-  -target=* | --target=* | --targe=* | --targ=* | --tar=* | --ta=* | --t=*)
-    target="$ac_optarg" ;;
-
-  -v | -verbose | --verbose | --verbos | --verbo | --verb)
-    verbose=yes ;;
-
-  -version | --version | --versio | --versi | --vers)
-    echo "configure generated by autoconf version 2.13"
-    exit 0 ;;
-
-  -with-* | --with-*)
-    ac_package=`echo $ac_option|sed -e 's/-*with-//' -e 's/=.*//'`
-    # Reject names that are not valid shell variable names.
-    if test -n "`echo $ac_package| sed 's/[-_a-zA-Z0-9]//g'`"; then
-      { echo "configure: error: $ac_package: invalid package name" 1>&2; exit 1; }
-    fi
-    ac_package=`echo $ac_package| sed 's/-/_/g'`
-    case "$ac_option" in
-      *=*) ;;
-      *) ac_optarg=yes ;;
-    esac
-    eval "with_${ac_package}='$ac_optarg'" ;;
-
-  -without-* | --without-*)
-    ac_package=`echo $ac_option|sed -e 's/-*without-//'`
-    # Reject names that are not valid shell variable names.
-    if test -n "`echo $ac_package| sed 's/[-a-zA-Z0-9_]//g'`"; then
-      { echo "configure: error: $ac_package: invalid package name" 1>&2; exit 1; }
-    fi
-    ac_package=`echo $ac_package| sed 's/-/_/g'`
-    eval "with_${ac_package}=no" ;;
-
-  --x)
-    # Obsolete; use --with-x.
-    with_x=yes ;;
-
-  -x-includes | --x-includes | --x-include | --x-includ | --x-inclu \
-  | --x-incl | --x-inc | --x-in | --x-i)
-    ac_prev=x_includes ;;
-  -x-includes=* | --x-includes=* | --x-include=* | --x-includ=* | --x-inclu=* \
-  | --x-incl=* | --x-inc=* | --x-in=* | --x-i=*)
-    x_includes="$ac_optarg" ;;
-
-  -x-libraries | --x-libraries | --x-librarie | --x-librari \
-  | --x-librar | --x-libra | --x-libr | --x-lib | --x-li | --x-l)
-    ac_prev=x_libraries ;;
-  -x-libraries=* | --x-libraries=* | --x-librarie=* | --x-librari=* \
-  | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)
-    x_libraries="$ac_optarg" ;;
-
-  -*) { echo "configure: error: $ac_option: invalid option; use --help to show usage" 1>&2; exit 1; }
-    ;;
-
-  *)
-    if test -n "`echo $ac_option| sed 's/[-a-z0-9.]//g'`"; then
-      echo "configure: warning: $ac_option: invalid host type" 1>&2
-    fi
-    if test "x$nonopt" != xNONE; then
-      { echo "configure: error: can only configure for one host and one target at a time" 1>&2; exit 1; }
-    fi
-    nonopt="$ac_option"
-    ;;
-
-  esac
-done
-
-if test -n "$ac_prev"; then
-  { echo "configure: error: missing argument to --`echo $ac_prev | sed 's/_/-/g'`" 1>&2; exit 1; }
-fi
-
-trap 'rm -fr conftest* confdefs* core core.* *.core $ac_clean_files; exit 1' 1 2 15
-
-# File descriptor usage:
-# 0 standard input
-# 1 file creation
-# 2 errors and warnings
-# 3 some systems may open it to /dev/tty
-# 4 used on the Kubota Titan
-# 6 checking for... messages and results
-# 5 compiler messages saved in config.log
-if test "$silent" = yes; then
-  exec 6>/dev/null
-else
-  exec 6>&1
-fi
-exec 5>./config.log
-
-echo "\
-This file contains any messages produced by compilers while
-running configure, to aid debugging if configure makes a mistake.
-" 1>&5
-
-# Strip out --no-create and --no-recursion so they do not pile up.
-# Also quote any args containing shell metacharacters.
-ac_configure_args=
-for ac_arg
-do
-  case "$ac_arg" in
-  -no-create | --no-create | --no-creat | --no-crea | --no-cre \
-  | --no-cr | --no-c) ;;
-  -no-recursion | --no-recursion | --no-recursio | --no-recursi \
-  | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r) ;;
-  *" "*|*"	"*|*[\[\]\~\#\$\^\&\*\(\)\{\}\\\|\;\<\>\?]*)
-  ac_configure_args="$ac_configure_args '$ac_arg'" ;;
-  *) ac_configure_args="$ac_configure_args $ac_arg" ;;
-  esac
-done
-
-# NLS nuisances.
-# Only set these to C if already set.  These must not be set unconditionally
-# because not all systems understand e.g. LANG=C (notably SCO).
-# Fixing LC_MESSAGES prevents Solaris sh from translating var values in `set'!
-# Non-C LC_CTYPE values break the ctype check.
-if test "${LANG+set}"   = set; then LANG=C;   export LANG;   fi
-if test "${LC_ALL+set}" = set; then LC_ALL=C; export LC_ALL; fi
-if test "${LC_MESSAGES+set}" = set; then LC_MESSAGES=C; export LC_MESSAGES; fi
-if test "${LC_CTYPE+set}"    = set; then LC_CTYPE=C;    export LC_CTYPE;    fi
-
-# confdefs.h avoids OS command line length limits that DEFS can exceed.
-rm -rf conftest* confdefs.h
-# AIX cpp loses on an empty file, so make sure it contains at least a newline.
-echo > confdefs.h
-
-# A filename unique to this package, relative to the directory that
-# configure is in, which we can look for to find out if srcdir is correct.
-ac_unique_file=COPYING
-
-# Find the source files, if location was not specified.
-if test -z "$srcdir"; then
-  ac_srcdir_defaulted=yes
-  # Try the directory containing this script, then its parent.
-  ac_prog=$0
-  ac_confdir=`echo $ac_prog|sed 's%/[^/][^/]*$%%'`
-  test "x$ac_confdir" = "x$ac_prog" && ac_confdir=.
-  srcdir=$ac_confdir
-  if test ! -r $srcdir/$ac_unique_file; then
-    srcdir=..
-  fi
-else
-  ac_srcdir_defaulted=no
-fi
-if test ! -r $srcdir/$ac_unique_file; then
-  if test "$ac_srcdir_defaulted" = yes; then
-    { echo "configure: error: can not find sources in $ac_confdir or .." 1>&2; exit 1; }
-  else
-    { echo "configure: error: can not find sources in $srcdir" 1>&2; exit 1; }
-  fi
-fi
-srcdir=`echo "${srcdir}" | sed 's%\([^/]\)/*$%\1%'`
-
-# Prefer explicitly selected file to automatically selected ones.
-if test -z "$CONFIG_SITE"; then
-  if test "x$prefix" != xNONE; then
-    CONFIG_SITE="$prefix/share/config.site $prefix/etc/config.site"
-  else
-    CONFIG_SITE="$ac_default_prefix/share/config.site $ac_default_prefix/etc/config.site"
-  fi
-fi
-for ac_site_file in $CONFIG_SITE; do
-  if test -r "$ac_site_file"; then
-    echo "loading site script $ac_site_file"
-    . "$ac_site_file"
-  fi
-done
-
-if test -r "$cache_file"; then
-  echo "loading cache $cache_file"
-  . $cache_file
-else
-  echo "creating cache $cache_file"
-  > $cache_file
-fi
-
-ac_ext=c
-# CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='${CC-cc} -c $CFLAGS $CPPFLAGS conftest.$ac_ext 1>&5'
-ac_link='${CC-cc} -o conftest${ac_exeext} $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS 1>&5'
-cross_compiling=$ac_cv_prog_cc_cross
-
-ac_exeext=
-ac_objext=o
-if (echo "testing\c"; echo 1,2,3) | grep c >/dev/null; then
-  # Stardent Vistra SVR4 grep lacks -e, says ghazi@caip.rutgers.edu.
-  if (echo -n testing; echo 1,2,3) | sed s/-n/xn/ | grep xn >/dev/null; then
-    ac_n= ac_c='
-' ac_t='	'
-  else
-    ac_n=-n ac_c= ac_t=
-  fi
-else
-  ac_n= ac_c='\c' ac_t=
-fi
-
-
-
-
-
-
-
-# Extract the first word of "gcc", so it can be a program name with args.
-set dummy gcc; ac_word=$2
-echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:553: checking for $ac_word" >&5
-if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
-  echo $ac_n "(cached) $ac_c" 1>&6
-else
-  if test -n "$CC"; then
-  ac_cv_prog_CC="$CC" # Let the user override the test.
-else
-  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS=":"
-  ac_dummy="$PATH"
-  for ac_dir in $ac_dummy; do
-    test -z "$ac_dir" && ac_dir=.
-    if test -f $ac_dir/$ac_word; then
-      ac_cv_prog_CC="gcc"
-      break
-    fi
-  done
-  IFS="$ac_save_ifs"
-fi
-fi
-CC="$ac_cv_prog_CC"
-if test -n "$CC"; then
-  echo "$ac_t""$CC" 1>&6
-else
-  echo "$ac_t""no" 1>&6
-fi
-
-if test -z "$CC"; then
-  # Extract the first word of "cc", so it can be a program name with args.
-set dummy cc; ac_word=$2
-echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:583: checking for $ac_word" >&5
-if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
-  echo $ac_n "(cached) $ac_c" 1>&6
-else
-  if test -n "$CC"; then
-  ac_cv_prog_CC="$CC" # Let the user override the test.
-else
-  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS=":"
-  ac_prog_rejected=no
-  ac_dummy="$PATH"
-  for ac_dir in $ac_dummy; do
-    test -z "$ac_dir" && ac_dir=.
-    if test -f $ac_dir/$ac_word; then
-      if test "$ac_dir/$ac_word" = "/usr/ucb/cc"; then
-        ac_prog_rejected=yes
-	continue
-      fi
-      ac_cv_prog_CC="cc"
-      break
-    fi
-  done
-  IFS="$ac_save_ifs"
-if test $ac_prog_rejected = yes; then
-  # We found a bogon in the path, so make sure we never use it.
-  set dummy $ac_cv_prog_CC
-  shift
-  if test $# -gt 0; then
-    # We chose a different compiler from the bogus one.
-    # However, it has the same basename, so the bogon will be chosen
-    # first if we set CC to just the basename; use the full file name.
-    shift
-    set dummy "$ac_dir/$ac_word" "$@"
-    shift
-    ac_cv_prog_CC="$@"
-  fi
-fi
-fi
-fi
-CC="$ac_cv_prog_CC"
-if test -n "$CC"; then
-  echo "$ac_t""$CC" 1>&6
-else
-  echo "$ac_t""no" 1>&6
-fi
-
-  if test -z "$CC"; then
-    case "`uname -s`" in
-    *win32* | *WIN32*)
-      # Extract the first word of "cl", so it can be a program name with args.
-set dummy cl; ac_word=$2
-echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:634: checking for $ac_word" >&5
-if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
-  echo $ac_n "(cached) $ac_c" 1>&6
-else
-  if test -n "$CC"; then
-  ac_cv_prog_CC="$CC" # Let the user override the test.
-else
-  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS=":"
-  ac_dummy="$PATH"
-  for ac_dir in $ac_dummy; do
-    test -z "$ac_dir" && ac_dir=.
-    if test -f $ac_dir/$ac_word; then
-      ac_cv_prog_CC="cl"
-      break
-    fi
-  done
-  IFS="$ac_save_ifs"
-fi
-fi
-CC="$ac_cv_prog_CC"
-if test -n "$CC"; then
-  echo "$ac_t""$CC" 1>&6
-else
-  echo "$ac_t""no" 1>&6
-fi
- ;;
-    esac
-  fi
-  test -z "$CC" && { echo "configure: error: no acceptable cc found in \$PATH" 1>&2; exit 1; }
-fi
-
-echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works""... $ac_c" 1>&6
-echo "configure:666: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works" >&5
-
-ac_ext=c
-# CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='${CC-cc} -c $CFLAGS $CPPFLAGS conftest.$ac_ext 1>&5'
-ac_link='${CC-cc} -o conftest${ac_exeext} $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS 1>&5'
-cross_compiling=$ac_cv_prog_cc_cross
-
-cat > conftest.$ac_ext << EOF
-
-#line 677 "configure"
-#include "confdefs.h"
-
-main(){return(0);}
-EOF
-if { (eval echo configure:682: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
-  ac_cv_prog_cc_works=yes
-  # If we can't run a trivial program, we are probably using a cross compiler.
-  if (./conftest; exit) 2>/dev/null; then
-    ac_cv_prog_cc_cross=no
-  else
-    ac_cv_prog_cc_cross=yes
-  fi
-else
-  echo "configure: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-  ac_cv_prog_cc_works=no
-fi
-rm -fr conftest*
-ac_ext=c
-# CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
-ac_cpp='$CPP $CPPFLAGS'
-ac_compile='${CC-cc} -c $CFLAGS $CPPFLAGS conftest.$ac_ext 1>&5'
-ac_link='${CC-cc} -o conftest${ac_exeext} $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS 1>&5'
-cross_compiling=$ac_cv_prog_cc_cross
-
-echo "$ac_t""$ac_cv_prog_cc_works" 1>&6
-if test $ac_cv_prog_cc_works = no; then
-  { echo "configure: error: installation or configuration problem: C compiler cannot create executables." 1>&2; exit 1; }
-fi
-echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler""... $ac_c" 1>&6
-echo "configure:708: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler" >&5
-echo "$ac_t""$ac_cv_prog_cc_cross" 1>&6
-cross_compiling=$ac_cv_prog_cc_cross
-
-echo $ac_n "checking whether we are using GNU C""... $ac_c" 1>&6
-echo "configure:713: checking whether we are using GNU C" >&5
-if eval "test \"`echo '$''{'ac_cv_prog_gcc'+set}'`\" = set"; then
-  echo $ac_n "(cached) $ac_c" 1>&6
-else
-  cat > conftest.c <<EOF
-#ifdef __GNUC__
-  yes;
-#endif
-EOF
-if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:722: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
-  ac_cv_prog_gcc=yes
-else
-  ac_cv_prog_gcc=no
-fi
-fi
-
-echo "$ac_t""$ac_cv_prog_gcc" 1>&6
-
-if test $ac_cv_prog_gcc = yes; then
-  GCC=yes
-else
-  GCC=
-fi
-
-ac_test_CFLAGS="${CFLAGS+set}"
-ac_save_CFLAGS="$CFLAGS"
-CFLAGS=
-echo $ac_n "checking whether ${CC-cc} accepts -g""... $ac_c" 1>&6
-echo "configure:741: checking whether ${CC-cc} accepts -g" >&5
-if eval "test \"`echo '$''{'ac_cv_prog_cc_g'+set}'`\" = set"; then
-  echo $ac_n "(cached) $ac_c" 1>&6
-else
-  echo 'void f(){}' > conftest.c
-if test -z "`${CC-cc} -g -c conftest.c 2>&1`"; then
-  ac_cv_prog_cc_g=yes
-else
-  ac_cv_prog_cc_g=no
-fi
-rm -f conftest*
-
-fi
-
-echo "$ac_t""$ac_cv_prog_cc_g" 1>&6
-if test "$ac_test_CFLAGS" = set; then
-  CFLAGS="$ac_save_CFLAGS"
-elif test $ac_cv_prog_cc_g = yes; then
-  if test "$GCC" = yes; then
-    CFLAGS="-g -O2"
-  else
-    CFLAGS="-g"
-  fi
-else
-  if test "$GCC" = yes; then
-    CFLAGS="-O2"
-  else
-    CFLAGS=
-  fi
-fi
-
-echo $ac_n "checking whether ${MAKE-make} sets \${MAKE}""... $ac_c" 1>&6
-echo "configure:773: checking whether ${MAKE-make} sets \${MAKE}" >&5
-set dummy ${MAKE-make}; ac_make=`echo "$2" | sed 'y%./+-%__p_%'`
-if eval "test \"`echo '$''{'ac_cv_prog_make_${ac_make}_set'+set}'`\" = set"; then
-  echo $ac_n "(cached) $ac_c" 1>&6
-else
-  cat > conftestmake <<\EOF
-all:
-	@echo 'ac_maketemp="${MAKE}"'
-EOF
-# GNU make sometimes prints "make[1]: Entering...", which would confuse us.
-eval `${MAKE-make} -f conftestmake 2>/dev/null | grep temp=`
-if test -n "$ac_maketemp"; then
-  eval ac_cv_prog_make_${ac_make}_set=yes
-else
-  eval ac_cv_prog_make_${ac_make}_set=no
-fi
-rm -f conftestmake
-fi
-if eval "test \"`echo '$ac_cv_prog_make_'${ac_make}_set`\" = yes"; then
-  echo "$ac_t""yes" 1>&6
-  SET_MAKE=
-else
-  echo "$ac_t""no" 1>&6
-  SET_MAKE="MAKE=${MAKE-make}"
-fi
-
-# Extract the first word of "ranlib", so it can be a program name with args.
-set dummy ranlib; ac_word=$2
-echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:802: checking for $ac_word" >&5
-if eval "test \"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\" = set"; then
-  echo $ac_n "(cached) $ac_c" 1>&6
-else
-  if test -n "$RANLIB"; then
-  ac_cv_prog_RANLIB="$RANLIB" # Let the user override the test.
-else
-  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS=":"
-  ac_dummy="$PATH"
-  for ac_dir in $ac_dummy; do
-    test -z "$ac_dir" && ac_dir=.
-    if test -f $ac_dir/$ac_word; then
-      ac_cv_prog_RANLIB="ranlib"
-      break
-    fi
-  done
-  IFS="$ac_save_ifs"
-  test -z "$ac_cv_prog_RANLIB" && ac_cv_prog_RANLIB=":"
-fi
-fi
-RANLIB="$ac_cv_prog_RANLIB"
-if test -n "$RANLIB"; then
-  echo "$ac_t""$RANLIB" 1>&6
-else
-  echo "$ac_t""no" 1>&6
-fi
-
-
-echo $ac_n "checking how to run the C preprocessor""... $ac_c" 1>&6
-echo "configure:831: checking how to run the C preprocessor" >&5
-# On Suns, sometimes $CPP names a directory.
-if test -n "$CPP" && test -d "$CPP"; then
-  CPP=
-fi
-if test -z "$CPP"; then
-if eval "test \"`echo '$''{'ac_cv_prog_CPP'+set}'`\" = set"; then
-  echo $ac_n "(cached) $ac_c" 1>&6
-else
-    # This must be in double quotes, not single quotes, because CPP may get
-  # substituted into the Makefile and "${CC-cc}" will confuse make.
-  CPP="${CC-cc} -E"
-  # On the NeXT, cc -E runs the code through the compiler's parser,
-  # not just through cpp.
-  cat > conftest.$ac_ext <<EOF
-#line 846 "configure"
-#include "confdefs.h"
-#include <assert.h>
-Syntax Error
-EOF
-ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:852: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
-ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
-if test -z "$ac_err"; then
-  :
-else
-  echo "$ac_err" >&5
-  echo "configure: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-  rm -rf conftest*
-  CPP="${CC-cc} -E -traditional-cpp"
-  cat > conftest.$ac_ext <<EOF
-#line 863 "configure"
-#include "confdefs.h"
-#include <assert.h>
-Syntax Error
-EOF
-ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:869: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
-ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
-if test -z "$ac_err"; then
-  :
-else
-  echo "$ac_err" >&5
-  echo "configure: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-  rm -rf conftest*
-  CPP="${CC-cc} -nologo -E"
-  cat > conftest.$ac_ext <<EOF
-#line 880 "configure"
-#include "confdefs.h"
-#include <assert.h>
-Syntax Error
-EOF
-ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:886: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
-ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
-if test -z "$ac_err"; then
-  :
-else
-  echo "$ac_err" >&5
-  echo "configure: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-  rm -rf conftest*
-  CPP=/lib/cpp
-fi
-rm -f conftest*
-fi
-rm -f conftest*
-fi
-rm -f conftest*
-  ac_cv_prog_CPP="$CPP"
-fi
-  CPP="$ac_cv_prog_CPP"
-else
-  ac_cv_prog_CPP="$CPP"
-fi
-echo "$ac_t""$CPP" 1>&6
-
-# If we find X, set shell vars x_includes and x_libraries to the
-# paths, otherwise set no_x=yes.
-# Uses ac_ vars as temps to allow command line to override cache and checks.
-# --without-x overrides everything else, but does not touch the cache.
-echo $ac_n "checking for X""... $ac_c" 1>&6
-echo "configure:915: checking for X" >&5
-
-# Check whether --with-x or --without-x was given.
-if test "${with_x+set}" = set; then
-  withval="$with_x"
-  :
-fi
-
-# $have_x is `yes', `no', `disabled', or empty when we do not yet know.
-if test "x$with_x" = xno; then
-  # The user explicitly disabled X.
-  have_x=disabled
-else
-  if test "x$x_includes" != xNONE && test "x$x_libraries" != xNONE; then
-    # Both variables are already set.
-    have_x=yes
-  else
-if eval "test \"`echo '$''{'ac_cv_have_x'+set}'`\" = set"; then
-  echo $ac_n "(cached) $ac_c" 1>&6
-else
-  # One or both of the vars are not set, and there is no cached value.
-ac_x_includes=NO ac_x_libraries=NO
-rm -fr conftestdir
-if mkdir conftestdir; then
-  cd conftestdir
-  # Make sure to not put "make" in the Imakefile rules, since we grep it out.
-  cat > Imakefile <<'EOF'
-acfindx:
-	@echo 'ac_im_incroot="${INCROOT}"; ac_im_usrlibdir="${USRLIBDIR}"; ac_im_libdir="${LIBDIR}"'
-EOF
-  if (xmkmf) >/dev/null 2>/dev/null && test -f Makefile; then
-    # GNU make sometimes prints "make[1]: Entering...", which would confuse us.
-    eval `${MAKE-make} acfindx 2>/dev/null | grep -v make`
-    # Open Windows xmkmf reportedly sets LIBDIR instead of USRLIBDIR.
-    for ac_extension in a so sl; do
-      if test ! -f $ac_im_usrlibdir/libX11.$ac_extension &&
-        test -f $ac_im_libdir/libX11.$ac_extension; then
-        ac_im_usrlibdir=$ac_im_libdir; break
-      fi
-    done
-    # Screen out bogus values from the imake configuration.  They are
-    # bogus both because they are the default anyway, and because
-    # using them would break gcc on systems where it needs fixed includes.
-    case "$ac_im_incroot" in
-	/usr/include) ;;
-	*) test -f "$ac_im_incroot/X11/Xos.h" && ac_x_includes="$ac_im_incroot" ;;
-    esac
-    case "$ac_im_usrlibdir" in
-	/usr/lib | /lib) ;;
-	*) test -d "$ac_im_usrlibdir" && ac_x_libraries="$ac_im_usrlibdir" ;;
-    esac
-  fi
-  cd ..
-  rm -fr conftestdir
-fi
-
-if test "$ac_x_includes" = NO; then
-  # Guess where to find include files, by looking for this one X11 .h file.
-  test -z "$x_direct_test_include" && x_direct_test_include=X11/Intrinsic.h
-
-  # First, try using that file with no special directory specified.
-cat > conftest.$ac_ext <<EOF
-#line 977 "configure"
-#include "confdefs.h"
-#include <$x_direct_test_include>
-EOF
-ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:982: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
-ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
-if test -z "$ac_err"; then
-  rm -rf conftest*
-  # We can compile using X headers with no special include directory.
-ac_x_includes=
-else
-  echo "$ac_err" >&5
-  echo "configure: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-  rm -rf conftest*
-  # Look for the header file in a standard set of common directories.
-# Check X11 before X11Rn because it is often a symlink to the current release.
-  for ac_dir in               \
-    /usr/X11/include          \
-    /usr/X11R6/include        \
-    /usr/X11R5/include        \
-    /usr/X11R4/include        \
-                              \
-    /usr/include/X11          \
-    /usr/include/X11R6        \
-    /usr/include/X11R5        \
-    /usr/include/X11R4        \
-                              \
-    /usr/local/X11/include    \
-    /usr/local/X11R6/include  \
-    /usr/local/X11R5/include  \
-    /usr/local/X11R4/include  \
-                              \
-    /usr/local/include/X11    \
-    /usr/local/include/X11R6  \
-    /usr/local/include/X11R5  \
-    /usr/local/include/X11R4  \
-                              \
-    /usr/X386/include         \
-    /usr/x386/include         \
-    /usr/XFree86/include/X11  \
-                              \
-    /usr/include              \
-    /usr/local/include        \
-    /usr/unsupported/include  \
-    /usr/athena/include       \
-    /usr/local/x11r5/include  \
-    /usr/lpp/Xamples/include  \
-                              \
-    /usr/openwin/include      \
-    /usr/openwin/share/include \
-    ; \
-  do
-    if test -r "$ac_dir/$x_direct_test_include"; then
-      ac_x_includes=$ac_dir
-      break
-    fi
-  done
-fi
-rm -f conftest*
-fi # $ac_x_includes = NO
-
-if test "$ac_x_libraries" = NO; then
-  # Check for the libraries.
-
-  test -z "$x_direct_test_library" && x_direct_test_library=Xt
-  test -z "$x_direct_test_function" && x_direct_test_function=XtMalloc
-
-  # See if we find them without any special options.
-  # Don't add to $LIBS permanently.
-  ac_save_LIBS="$LIBS"
-  LIBS="-l$x_direct_test_library $LIBS"
-cat > conftest.$ac_ext <<EOF
-#line 1051 "configure"
-#include "confdefs.h"
-
-int main() {
-${x_direct_test_function}()
-; return 0; }
-EOF
-if { (eval echo configure:1058: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
-  rm -rf conftest*
-  LIBS="$ac_save_LIBS"
-# We can link X programs with no special library path.
-ac_x_libraries=
-else
-  echo "configure: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-  rm -rf conftest*
-  LIBS="$ac_save_LIBS"
-# First see if replacing the include by lib works.
-# Check X11 before X11Rn because it is often a symlink to the current release.
-for ac_dir in `echo "$ac_x_includes" | sed s/include/lib/` \
-    /usr/X11/lib          \
-    /usr/X11R6/lib        \
-    /usr/X11R5/lib        \
-    /usr/X11R4/lib        \
-                          \
-    /usr/lib/X11          \
-    /usr/lib/X11R6        \
-    /usr/lib/X11R5        \
-    /usr/lib/X11R4        \
-                          \
-    /usr/local/X11/lib    \
-    /usr/local/X11R6/lib  \
-    /usr/local/X11R5/lib  \
-    /usr/local/X11R4/lib  \
-                          \
-    /usr/local/lib/X11    \
-    /usr/local/lib/X11R6  \
-    /usr/local/lib/X11R5  \
-    /usr/local/lib/X11R4  \
-                          \
-    /usr/X386/lib         \
-    /usr/x386/lib         \
-    /usr/XFree86/lib/X11  \
-                          \
-    /usr/lib              \
-    /usr/local/lib        \
-    /usr/unsupported/lib  \
-    /usr/athena/lib       \
-    /usr/local/x11r5/lib  \
-    /usr/lpp/Xamples/lib  \
-    /lib/usr/lib/X11	  \
-                          \
-    /usr/openwin/lib      \
-    /usr/openwin/share/lib \
-    ; \
-do
-  for ac_extension in a so sl; do
-    if test -r $ac_dir/lib${x_direct_test_library}.$ac_extension; then
-      ac_x_libraries=$ac_dir
-      break 2
-    fi
-  done
-done
-fi
-rm -f conftest*
-fi # $ac_x_libraries = NO
-
-if test "$ac_x_includes" = NO || test "$ac_x_libraries" = NO; then
-  # Didn't find X anywhere.  Cache the known absence of X.
-  ac_cv_have_x="have_x=no"
-else
-  # Record where we found X for the cache.
-  ac_cv_have_x="have_x=yes \
-	        ac_x_includes=$ac_x_includes ac_x_libraries=$ac_x_libraries"
-fi
-fi
-  fi
-  eval "$ac_cv_have_x"
-fi # $with_x != no
-
-if test "$have_x" != yes; then
-  echo "$ac_t""$have_x" 1>&6
-  no_x=yes
-else
-  # If each of the values was on the command line, it overrides each guess.
-  test "x$x_includes" = xNONE && x_includes=$ac_x_includes
-  test "x$x_libraries" = xNONE && x_libraries=$ac_x_libraries
-  # Update the cache value to reflect the command line values.
-  ac_cv_have_x="have_x=yes \
-		ac_x_includes=$x_includes ac_x_libraries=$x_libraries"
-  echo "$ac_t""libraries $x_libraries, headers $x_includes" 1>&6
-fi
-
-if test "$no_x" = yes; then
-  # Not all programs may use this symbol, but it does not hurt to define it.
-  cat >> confdefs.h <<\EOF
-#define X_DISPLAY_MISSING 1
-EOF
-
-  X_CFLAGS= X_PRE_LIBS= X_LIBS= X_EXTRA_LIBS=
-else
-  if test -n "$x_includes"; then
-    X_CFLAGS="$X_CFLAGS -I$x_includes"
-  fi
-
-  # It would also be nice to do this for all -L options, not just this one.
-  if test -n "$x_libraries"; then
-    X_LIBS="$X_LIBS -L$x_libraries"
-    # For Solaris; some versions of Sun CC require a space after -R and
-    # others require no space.  Words are not sufficient . . . .
-    case "`(uname -sr) 2>/dev/null`" in
-    "SunOS 5"*)
-      echo $ac_n "checking whether -R must be followed by a space""... $ac_c" 1>&6
-echo "configure:1164: checking whether -R must be followed by a space" >&5
-      ac_xsave_LIBS="$LIBS"; LIBS="$LIBS -R$x_libraries"
-      cat > conftest.$ac_ext <<EOF
-#line 1167 "configure"
-#include "confdefs.h"
-
-int main() {
-
-; return 0; }
-EOF
-if { (eval echo configure:1174: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
-  rm -rf conftest*
-  ac_R_nospace=yes
-else
-  echo "configure: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-  rm -rf conftest*
-  ac_R_nospace=no
-fi
-rm -f conftest*
-      if test $ac_R_nospace = yes; then
-	echo "$ac_t""no" 1>&6
-	X_LIBS="$X_LIBS -R$x_libraries"
-      else
-	LIBS="$ac_xsave_LIBS -R $x_libraries"
-	cat > conftest.$ac_ext <<EOF
-#line 1190 "configure"
-#include "confdefs.h"
-
-int main() {
-
-; return 0; }
-EOF
-if { (eval echo configure:1197: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
-  rm -rf conftest*
-  ac_R_space=yes
-else
-  echo "configure: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-  rm -rf conftest*
-  ac_R_space=no
-fi
-rm -f conftest*
-	if test $ac_R_space = yes; then
-	  echo "$ac_t""yes" 1>&6
-	  X_LIBS="$X_LIBS -R $x_libraries"
-	else
-	  echo "$ac_t""neither works" 1>&6
-	fi
-      fi
-      LIBS="$ac_xsave_LIBS"
-    esac
-  fi
-
-  # Check for system-dependent libraries X programs must link with.
-  # Do this before checking for the system-independent R6 libraries
-  # (-lICE), since we may need -lsocket or whatever for X linking.
-
-  if test "$ISC" = yes; then
-    X_EXTRA_LIBS="$X_EXTRA_LIBS -lnsl_s -linet"
-  else
-    # Martyn.Johnson@cl.cam.ac.uk says this is needed for Ultrix, if the X
-    # libraries were built with DECnet support.  And karl@cs.umb.edu says
-    # the Alpha needs dnet_stub (dnet does not exist).
-    echo $ac_n "checking for dnet_ntoa in -ldnet""... $ac_c" 1>&6
-echo "configure:1229: checking for dnet_ntoa in -ldnet" >&5
-ac_lib_var=`echo dnet'_'dnet_ntoa | sed 'y%./+-%__p_%'`
-if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
-  echo $ac_n "(cached) $ac_c" 1>&6
-else
-  ac_save_LIBS="$LIBS"
-LIBS="-ldnet  $LIBS"
-cat > conftest.$ac_ext <<EOF
-#line 1237 "configure"
-#include "confdefs.h"
-/* Override any gcc2 internal prototype to avoid an error.  */
-/* We use char because int might match the return type of a gcc2
-    builtin and then its argument prototype would still apply.  */
-char dnet_ntoa();
-
-int main() {
-dnet_ntoa()
-; return 0; }
-EOF
-if { (eval echo configure:1248: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
-  rm -rf conftest*
-  eval "ac_cv_lib_$ac_lib_var=yes"
-else
-  echo "configure: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-  rm -rf conftest*
-  eval "ac_cv_lib_$ac_lib_var=no"
-fi
-rm -f conftest*
-LIBS="$ac_save_LIBS"
-
-fi
-if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
-  echo "$ac_t""yes" 1>&6
-  X_EXTRA_LIBS="$X_EXTRA_LIBS -ldnet"
-else
-  echo "$ac_t""no" 1>&6
-fi
-
-    if test $ac_cv_lib_dnet_dnet_ntoa = no; then
-      echo $ac_n "checking for dnet_ntoa in -ldnet_stub""... $ac_c" 1>&6
-echo "configure:1270: checking for dnet_ntoa in -ldnet_stub" >&5
-ac_lib_var=`echo dnet_stub'_'dnet_ntoa | sed 'y%./+-%__p_%'`
-if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
-  echo $ac_n "(cached) $ac_c" 1>&6
-else
-  ac_save_LIBS="$LIBS"
-LIBS="-ldnet_stub  $LIBS"
-cat > conftest.$ac_ext <<EOF
-#line 1278 "configure"
-#include "confdefs.h"
-/* Override any gcc2 internal prototype to avoid an error.  */
-/* We use char because int might match the return type of a gcc2
-    builtin and then its argument prototype would still apply.  */
-char dnet_ntoa();
-
-int main() {
-dnet_ntoa()
-; return 0; }
-EOF
-if { (eval echo configure:1289: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
-  rm -rf conftest*
-  eval "ac_cv_lib_$ac_lib_var=yes"
-else
-  echo "configure: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-  rm -rf conftest*
-  eval "ac_cv_lib_$ac_lib_var=no"
-fi
-rm -f conftest*
-LIBS="$ac_save_LIBS"
-
-fi
-if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
-  echo "$ac_t""yes" 1>&6
-  X_EXTRA_LIBS="$X_EXTRA_LIBS -ldnet_stub"
-else
-  echo "$ac_t""no" 1>&6
-fi
-
-    fi
-
-    # msh@cis.ufl.edu says -lnsl (and -lsocket) are needed for his 386/AT,
-    # to get the SysV transport functions.
-    # chad@anasazi.com says the Pyramis MIS-ES running DC/OSx (SVR4)
-    # needs -lnsl.
-    # The nsl library prevents programs from opening the X display
-    # on Irix 5.2, according to dickey@clark.net.
-    echo $ac_n "checking for gethostbyname""... $ac_c" 1>&6
-echo "configure:1318: checking for gethostbyname" >&5
-if eval "test \"`echo '$''{'ac_cv_func_gethostbyname'+set}'`\" = set"; then
-  echo $ac_n "(cached) $ac_c" 1>&6
-else
-  cat > conftest.$ac_ext <<EOF
-#line 1323 "configure"
-#include "confdefs.h"
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char gethostbyname(); below.  */
-#include <assert.h>
-/* Override any gcc2 internal prototype to avoid an error.  */
-/* We use char because int might match the return type of a gcc2
-    builtin and then its argument prototype would still apply.  */
-char gethostbyname();
-
-int main() {
-
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined (__stub_gethostbyname) || defined (__stub___gethostbyname)
-choke me
-#else
-gethostbyname();
-#endif
-
-; return 0; }
-EOF
-if { (eval echo configure:1346: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
-  rm -rf conftest*
-  eval "ac_cv_func_gethostbyname=yes"
-else
-  echo "configure: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-  rm -rf conftest*
-  eval "ac_cv_func_gethostbyname=no"
-fi
-rm -f conftest*
-fi
-
-if eval "test \"`echo '$ac_cv_func_'gethostbyname`\" = yes"; then
-  echo "$ac_t""yes" 1>&6
-  :
-else
-  echo "$ac_t""no" 1>&6
-fi
-
-    if test $ac_cv_func_gethostbyname = no; then
-      echo $ac_n "checking for gethostbyname in -lnsl""... $ac_c" 1>&6
-echo "configure:1367: checking for gethostbyname in -lnsl" >&5
-ac_lib_var=`echo nsl'_'gethostbyname | sed 'y%./+-%__p_%'`
-if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
-  echo $ac_n "(cached) $ac_c" 1>&6
-else
-  ac_save_LIBS="$LIBS"
-LIBS="-lnsl  $LIBS"
-cat > conftest.$ac_ext <<EOF
-#line 1375 "configure"
-#include "confdefs.h"
-/* Override any gcc2 internal prototype to avoid an error.  */
-/* We use char because int might match the return type of a gcc2
-    builtin and then its argument prototype would still apply.  */
-char gethostbyname();
-
-int main() {
-gethostbyname()
-; return 0; }
-EOF
-if { (eval echo configure:1386: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
-  rm -rf conftest*
-  eval "ac_cv_lib_$ac_lib_var=yes"
-else
-  echo "configure: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-  rm -rf conftest*
-  eval "ac_cv_lib_$ac_lib_var=no"
-fi
-rm -f conftest*
-LIBS="$ac_save_LIBS"
-
-fi
-if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
-  echo "$ac_t""yes" 1>&6
-  X_EXTRA_LIBS="$X_EXTRA_LIBS -lnsl"
-else
-  echo "$ac_t""no" 1>&6
-fi
-
-    fi
-
-    # lieder@skyler.mavd.honeywell.com says without -lsocket,
-    # socket/setsockopt and other routines are undefined under SCO ODT
-    # 2.0.  But -lsocket is broken on IRIX 5.2 (and is not necessary
-    # on later versions), says simon@lia.di.epfl.ch: it contains
-    # gethostby* variants that don't use the nameserver (or something).
-    # -lsocket must be given before -lnsl if both are needed.
-    # We assume that if connect needs -lnsl, so does gethostbyname.
-    echo $ac_n "checking for connect""... $ac_c" 1>&6
-echo "configure:1416: checking for connect" >&5
-if eval "test \"`echo '$''{'ac_cv_func_connect'+set}'`\" = set"; then
-  echo $ac_n "(cached) $ac_c" 1>&6
-else
-  cat > conftest.$ac_ext <<EOF
-#line 1421 "configure"
-#include "confdefs.h"
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char connect(); below.  */
-#include <assert.h>
-/* Override any gcc2 internal prototype to avoid an error.  */
-/* We use char because int might match the return type of a gcc2
-    builtin and then its argument prototype would still apply.  */
-char connect();
-
-int main() {
-
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined (__stub_connect) || defined (__stub___connect)
-choke me
-#else
-connect();
-#endif
-
-; return 0; }
-EOF
-if { (eval echo configure:1444: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
-  rm -rf conftest*
-  eval "ac_cv_func_connect=yes"
-else
-  echo "configure: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-  rm -rf conftest*
-  eval "ac_cv_func_connect=no"
-fi
-rm -f conftest*
-fi
-
-if eval "test \"`echo '$ac_cv_func_'connect`\" = yes"; then
-  echo "$ac_t""yes" 1>&6
-  :
-else
-  echo "$ac_t""no" 1>&6
-fi
-
-    if test $ac_cv_func_connect = no; then
-      echo $ac_n "checking for connect in -lsocket""... $ac_c" 1>&6
-echo "configure:1465: checking for connect in -lsocket" >&5
-ac_lib_var=`echo socket'_'connect | sed 'y%./+-%__p_%'`
-if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
-  echo $ac_n "(cached) $ac_c" 1>&6
-else
-  ac_save_LIBS="$LIBS"
-LIBS="-lsocket $X_EXTRA_LIBS $LIBS"
-cat > conftest.$ac_ext <<EOF
-#line 1473 "configure"
-#include "confdefs.h"
-/* Override any gcc2 internal prototype to avoid an error.  */
-/* We use char because int might match the return type of a gcc2
-    builtin and then its argument prototype would still apply.  */
-char connect();
-
-int main() {
-connect()
-; return 0; }
-EOF
-if { (eval echo configure:1484: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
-  rm -rf conftest*
-  eval "ac_cv_lib_$ac_lib_var=yes"
-else
-  echo "configure: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-  rm -rf conftest*
-  eval "ac_cv_lib_$ac_lib_var=no"
-fi
-rm -f conftest*
-LIBS="$ac_save_LIBS"
-
-fi
-if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
-  echo "$ac_t""yes" 1>&6
-  X_EXTRA_LIBS="-lsocket $X_EXTRA_LIBS"
-else
-  echo "$ac_t""no" 1>&6
-fi
-
-    fi
-
-    # gomez@mi.uni-erlangen.de says -lposix is necessary on A/UX.
-    echo $ac_n "checking for remove""... $ac_c" 1>&6
-echo "configure:1508: checking for remove" >&5
-if eval "test \"`echo '$''{'ac_cv_func_remove'+set}'`\" = set"; then
-  echo $ac_n "(cached) $ac_c" 1>&6
-else
-  cat > conftest.$ac_ext <<EOF
-#line 1513 "configure"
-#include "confdefs.h"
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char remove(); below.  */
-#include <assert.h>
-/* Override any gcc2 internal prototype to avoid an error.  */
-/* We use char because int might match the return type of a gcc2
-    builtin and then its argument prototype would still apply.  */
-char remove();
-
-int main() {
-
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined (__stub_remove) || defined (__stub___remove)
-choke me
-#else
-remove();
-#endif
-
-; return 0; }
-EOF
-if { (eval echo configure:1536: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
-  rm -rf conftest*
-  eval "ac_cv_func_remove=yes"
-else
-  echo "configure: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-  rm -rf conftest*
-  eval "ac_cv_func_remove=no"
-fi
-rm -f conftest*
-fi
-
-if eval "test \"`echo '$ac_cv_func_'remove`\" = yes"; then
-  echo "$ac_t""yes" 1>&6
-  :
-else
-  echo "$ac_t""no" 1>&6
-fi
-
-    if test $ac_cv_func_remove = no; then
-      echo $ac_n "checking for remove in -lposix""... $ac_c" 1>&6
-echo "configure:1557: checking for remove in -lposix" >&5
-ac_lib_var=`echo posix'_'remove | sed 'y%./+-%__p_%'`
-if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
-  echo $ac_n "(cached) $ac_c" 1>&6
-else
-  ac_save_LIBS="$LIBS"
-LIBS="-lposix  $LIBS"
-cat > conftest.$ac_ext <<EOF
-#line 1565 "configure"
-#include "confdefs.h"
-/* Override any gcc2 internal prototype to avoid an error.  */
-/* We use char because int might match the return type of a gcc2
-    builtin and then its argument prototype would still apply.  */
-char remove();
-
-int main() {
-remove()
-; return 0; }
-EOF
-if { (eval echo configure:1576: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
-  rm -rf conftest*
-  eval "ac_cv_lib_$ac_lib_var=yes"
-else
-  echo "configure: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-  rm -rf conftest*
-  eval "ac_cv_lib_$ac_lib_var=no"
-fi
-rm -f conftest*
-LIBS="$ac_save_LIBS"
-
-fi
-if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
-  echo "$ac_t""yes" 1>&6
-  X_EXTRA_LIBS="$X_EXTRA_LIBS -lposix"
-else
-  echo "$ac_t""no" 1>&6
-fi
-
-    fi
-
-    # BSDI BSD/OS 2.1 needs -lipc for XOpenDisplay.
-    echo $ac_n "checking for shmat""... $ac_c" 1>&6
-echo "configure:1600: checking for shmat" >&5
-if eval "test \"`echo '$''{'ac_cv_func_shmat'+set}'`\" = set"; then
-  echo $ac_n "(cached) $ac_c" 1>&6
-else
-  cat > conftest.$ac_ext <<EOF
-#line 1605 "configure"
-#include "confdefs.h"
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char shmat(); below.  */
-#include <assert.h>
-/* Override any gcc2 internal prototype to avoid an error.  */
-/* We use char because int might match the return type of a gcc2
-    builtin and then its argument prototype would still apply.  */
-char shmat();
-
-int main() {
-
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined (__stub_shmat) || defined (__stub___shmat)
-choke me
-#else
-shmat();
-#endif
-
-; return 0; }
-EOF
-if { (eval echo configure:1628: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
-  rm -rf conftest*
-  eval "ac_cv_func_shmat=yes"
-else
-  echo "configure: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-  rm -rf conftest*
-  eval "ac_cv_func_shmat=no"
-fi
-rm -f conftest*
-fi
-
-if eval "test \"`echo '$ac_cv_func_'shmat`\" = yes"; then
-  echo "$ac_t""yes" 1>&6
-  :
-else
-  echo "$ac_t""no" 1>&6
-fi
-
-    if test $ac_cv_func_shmat = no; then
-      echo $ac_n "checking for shmat in -lipc""... $ac_c" 1>&6
-echo "configure:1649: checking for shmat in -lipc" >&5
-ac_lib_var=`echo ipc'_'shmat | sed 'y%./+-%__p_%'`
-if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
-  echo $ac_n "(cached) $ac_c" 1>&6
-else
-  ac_save_LIBS="$LIBS"
-LIBS="-lipc  $LIBS"
-cat > conftest.$ac_ext <<EOF
-#line 1657 "configure"
-#include "confdefs.h"
-/* Override any gcc2 internal prototype to avoid an error.  */
-/* We use char because int might match the return type of a gcc2
-    builtin and then its argument prototype would still apply.  */
-char shmat();
-
-int main() {
-shmat()
-; return 0; }
-EOF
-if { (eval echo configure:1668: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
-  rm -rf conftest*
-  eval "ac_cv_lib_$ac_lib_var=yes"
-else
-  echo "configure: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-  rm -rf conftest*
-  eval "ac_cv_lib_$ac_lib_var=no"
-fi
-rm -f conftest*
-LIBS="$ac_save_LIBS"
-
-fi
-if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
-  echo "$ac_t""yes" 1>&6
-  X_EXTRA_LIBS="$X_EXTRA_LIBS -lipc"
-else
-  echo "$ac_t""no" 1>&6
-fi
-
-    fi
-  fi
-
-  # Check for libraries that X11R6 Xt/Xaw programs need.
-  ac_save_LDFLAGS="$LDFLAGS"
-  test -n "$x_libraries" && LDFLAGS="$LDFLAGS -L$x_libraries"
-  # SM needs ICE to (dynamically) link under SunOS 4.x (so we have to
-  # check for ICE first), but we must link in the order -lSM -lICE or
-  # we get undefined symbols.  So assume we have SM if we have ICE.
-  # These have to be linked with before -lX11, unlike the other
-  # libraries we check for below, so use a different variable.
-  #  --interran@uluru.Stanford.EDU, kb@cs.umb.edu.
-  echo $ac_n "checking for IceConnectionNumber in -lICE""... $ac_c" 1>&6
-echo "configure:1701: checking for IceConnectionNumber in -lICE" >&5
-ac_lib_var=`echo ICE'_'IceConnectionNumber | sed 'y%./+-%__p_%'`
-if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
-  echo $ac_n "(cached) $ac_c" 1>&6
-else
-  ac_save_LIBS="$LIBS"
-LIBS="-lICE $X_EXTRA_LIBS $LIBS"
-cat > conftest.$ac_ext <<EOF
-#line 1709 "configure"
-#include "confdefs.h"
-/* Override any gcc2 internal prototype to avoid an error.  */
-/* We use char because int might match the return type of a gcc2
-    builtin and then its argument prototype would still apply.  */
-char IceConnectionNumber();
-
-int main() {
-IceConnectionNumber()
-; return 0; }
-EOF
-if { (eval echo configure:1720: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
-  rm -rf conftest*
-  eval "ac_cv_lib_$ac_lib_var=yes"
-else
-  echo "configure: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-  rm -rf conftest*
-  eval "ac_cv_lib_$ac_lib_var=no"
-fi
-rm -f conftest*
-LIBS="$ac_save_LIBS"
-
-fi
-if eval "test \"`echo '$ac_cv_lib_'$ac_lib_var`\" = yes"; then
-  echo "$ac_t""yes" 1>&6
-  X_PRE_LIBS="$X_PRE_LIBS -lSM -lICE"
-else
-  echo "$ac_t""no" 1>&6
-fi
-
-  LDFLAGS="$ac_save_LDFLAGS"
-
-fi
-
-
-echo $ac_n "checking for inline""... $ac_c" 1>&6
-echo "configure:1746: checking for inline" >&5
-if eval "test \"`echo '$''{'ac_cv_c_inline'+set}'`\" = set"; then
-  echo $ac_n "(cached) $ac_c" 1>&6
-else
-  ac_cv_c_inline=no
-for ac_kw in inline __inline__ __inline; do
-  cat > conftest.$ac_ext <<EOF
-#line 1753 "configure"
-#include "confdefs.h"
-
-int main() {
-} $ac_kw foo() {
-; return 0; }
-EOF
-if { (eval echo configure:1760: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
-  rm -rf conftest*
-  ac_cv_c_inline=$ac_kw; break
-else
-  echo "configure: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-fi
-rm -f conftest*
-done
-
-fi
-
-echo "$ac_t""$ac_cv_c_inline" 1>&6
-case "$ac_cv_c_inline" in
-  inline | yes) ;;
-  no) cat >> confdefs.h <<\EOF
-#define inline 
-EOF
- ;;
-  *)  cat >> confdefs.h <<EOF
-#define inline $ac_cv_c_inline
-EOF
- ;;
-esac
-
-echo $ac_n "checking size of unsigned char""... $ac_c" 1>&6
-echo "configure:1786: checking size of unsigned char" >&5
-if eval "test \"`echo '$''{'ac_cv_sizeof_unsigned_char'+set}'`\" = set"; then
-  echo $ac_n "(cached) $ac_c" 1>&6
-else
-  if test "$cross_compiling" = yes; then
-  ac_cv_sizeof_unsigned_char=0
-else
-  cat > conftest.$ac_ext <<EOF
-#line 1794 "configure"
-#include "confdefs.h"
-#include <stdio.h>
-#include <sys/types.h>
-main()
-{
-  FILE *f=fopen("conftestval", "w");
-  if (!f) exit(1);
-  fprintf(f, "%d\n", sizeof(unsigned char));
-  exit(0);
-}
-EOF
-if { (eval echo configure:1806: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
-then
-  ac_cv_sizeof_unsigned_char=`cat conftestval`
-else
-  echo "configure: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-  rm -fr conftest*
-  ac_cv_sizeof_unsigned_char=0
-fi
-rm -fr conftest*
-fi
-
-fi
-echo "$ac_t""$ac_cv_sizeof_unsigned_char" 1>&6
-cat >> confdefs.h <<EOF
-#define SIZEOF_UNSIGNED_CHAR $ac_cv_sizeof_unsigned_char
-EOF
-
-
-echo $ac_n "checking size of unsigned short""... $ac_c" 1>&6
-echo "configure:1826: checking size of unsigned short" >&5
-if eval "test \"`echo '$''{'ac_cv_sizeof_unsigned_short'+set}'`\" = set"; then
-  echo $ac_n "(cached) $ac_c" 1>&6
-else
-  if test "$cross_compiling" = yes; then
-  ac_cv_sizeof_unsigned_short=0
-else
-  cat > conftest.$ac_ext <<EOF
-#line 1834 "configure"
-#include "confdefs.h"
-#include <stdio.h>
-#include <sys/types.h>
-main()
-{
-  FILE *f=fopen("conftestval", "w");
-  if (!f) exit(1);
-  fprintf(f, "%d\n", sizeof(unsigned short));
-  exit(0);
-}
-EOF
-if { (eval echo configure:1846: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
-then
-  ac_cv_sizeof_unsigned_short=`cat conftestval`
-else
-  echo "configure: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-  rm -fr conftest*
-  ac_cv_sizeof_unsigned_short=0
-fi
-rm -fr conftest*
-fi
-
-fi
-echo "$ac_t""$ac_cv_sizeof_unsigned_short" 1>&6
-cat >> confdefs.h <<EOF
-#define SIZEOF_UNSIGNED_SHORT $ac_cv_sizeof_unsigned_short
-EOF
-
-
-echo $ac_n "checking size of unsigned int""... $ac_c" 1>&6
-echo "configure:1866: checking size of unsigned int" >&5
-if eval "test \"`echo '$''{'ac_cv_sizeof_unsigned_int'+set}'`\" = set"; then
-  echo $ac_n "(cached) $ac_c" 1>&6
-else
-  if test "$cross_compiling" = yes; then
-  ac_cv_sizeof_unsigned_int=0
-else
-  cat > conftest.$ac_ext <<EOF
-#line 1874 "configure"
-#include "confdefs.h"
-#include <stdio.h>
-#include <sys/types.h>
-main()
-{
-  FILE *f=fopen("conftestval", "w");
-  if (!f) exit(1);
-  fprintf(f, "%d\n", sizeof(unsigned int));
-  exit(0);
-}
-EOF
-if { (eval echo configure:1886: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
-then
-  ac_cv_sizeof_unsigned_int=`cat conftestval`
-else
-  echo "configure: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-  rm -fr conftest*
-  ac_cv_sizeof_unsigned_int=0
-fi
-rm -fr conftest*
-fi
-
-fi
-echo "$ac_t""$ac_cv_sizeof_unsigned_int" 1>&6
-cat >> confdefs.h <<EOF
-#define SIZEOF_UNSIGNED_INT $ac_cv_sizeof_unsigned_int
-EOF
-
-
-echo $ac_n "checking size of unsigned long""... $ac_c" 1>&6
-echo "configure:1906: checking size of unsigned long" >&5
-if eval "test \"`echo '$''{'ac_cv_sizeof_unsigned_long'+set}'`\" = set"; then
-  echo $ac_n "(cached) $ac_c" 1>&6
-else
-  if test "$cross_compiling" = yes; then
-  ac_cv_sizeof_unsigned_long=0
-else
-  cat > conftest.$ac_ext <<EOF
-#line 1914 "configure"
-#include "confdefs.h"
-#include <stdio.h>
-#include <sys/types.h>
-main()
-{
-  FILE *f=fopen("conftestval", "w");
-  if (!f) exit(1);
-  fprintf(f, "%d\n", sizeof(unsigned long));
-  exit(0);
-}
-EOF
-if { (eval echo configure:1926: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
-then
-  ac_cv_sizeof_unsigned_long=`cat conftestval`
-else
-  echo "configure: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-  rm -fr conftest*
-  ac_cv_sizeof_unsigned_long=0
-fi
-rm -fr conftest*
-fi
-
-fi
-echo "$ac_t""$ac_cv_sizeof_unsigned_long" 1>&6
-cat >> confdefs.h <<EOF
-#define SIZEOF_UNSIGNED_LONG $ac_cv_sizeof_unsigned_long
-EOF
-
-
-echo $ac_n "checking size of unsigned long long""... $ac_c" 1>&6
-echo "configure:1946: checking size of unsigned long long" >&5
-if eval "test \"`echo '$''{'ac_cv_sizeof_unsigned_long_long'+set}'`\" = set"; then
-  echo $ac_n "(cached) $ac_c" 1>&6
-else
-  if test "$cross_compiling" = yes; then
-  ac_cv_sizeof_unsigned_long_long=0
-else
-  cat > conftest.$ac_ext <<EOF
-#line 1954 "configure"
-#include "confdefs.h"
-#include <stdio.h>
-#include <sys/types.h>
-main()
-{
-  FILE *f=fopen("conftestval", "w");
-  if (!f) exit(1);
-  fprintf(f, "%d\n", sizeof(unsigned long long));
-  exit(0);
-}
-EOF
-if { (eval echo configure:1966: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
-then
-  ac_cv_sizeof_unsigned_long_long=`cat conftestval`
-else
-  echo "configure: failed program was:" >&5
-  cat conftest.$ac_ext >&5
-  rm -fr conftest*
-  ac_cv_sizeof_unsigned_long_long=0
-fi
-rm -fr conftest*
-fi
-
-fi
-echo "$ac_t""$ac_cv_sizeof_unsigned_long_long" 1>&6
-cat >> confdefs.h <<EOF
-#define SIZEOF_UNSIGNED_LONG_LONG $ac_cv_sizeof_unsigned_long_long
-EOF
-
-
-
-if test "$GCC" = "yes"; then
-  CFLAGS="$CFLAGS -Wall -Wstrict-prototypes"
-fi
-if test "$GXX" = "yes"; then
-  CXXFLAGS="$CXXFLAGS -Wall -Wstrict-prototypes"
-fi
-
-# Check whether --with-WinNT or --without-WinNT was given.
-if test "${with_WinNT+set}" = set; then
-  withval="$with_WinNT"
-  :
-fi
-
-
-# Check whether --with-BeOS or --without-BeOS was given.
-if test "${with_BeOS+set}" = set; then
-  withval="$with_BeOS"
-  :
-fi
-
-
-# Check whether --with-Linux or --without-Linux was given.
-if test "${with_Linux+set}" = set; then
-  withval="$with_Linux"
-  :
-fi
-
-
-# Check whether --with-NetBSD or --without-NetBSD was given.
-if test "${with_NetBSD+set}" = set; then
-  withval="$with_NetBSD"
-  :
-fi
-
-
-# Check whether --with-FreeBSD or --without-FreeBSD was given.
-if test "${with_FreeBSD+set}" = set; then
-  withval="$with_FreeBSD"
-  :
-fi
-
-
-# Check whether --with-null or --without-null was given.
-if test "${with_null+set}" = set; then
-  withval="$with_null"
-  :
-fi
-
-
-# Check whether --with-linux-source or --without-linux-source was given.
-if test "${with_linux_source+set}" = set; then
-  withval="$with_linux_source"
-   LINUX_SRC="$withval" 
-else
-   LINUX_SRC="/lib/modules/`uname -r`/build" 
-  
-fi
-
-
-
-# Check whether --with-netbsd-source or --without-netbsd-source was given.
-if test "${with_netbsd_source+set}" = set; then
-  withval="$with_netbsd_source"
-   NETBSD_SRC="$withval" 
-else
-   NETBSD_SRC="/sys" 
-  
-fi
-
-
-
-# Check whether --with-freebsd-source or --without-freebsd-source was given.
-if test "${with_freebsd_source+set}" = set; then
-  withval="$with_freebsd_source"
-   FREEBSD_SRC="$withval" 
-else
-   FREEBSD_SRC="/sys" 
-  
-fi
-
-
-
-if test "$with_Linux" != yes && \
-   test "$with_BeOS" != yes && \
-   test "$with_NetBSD" != yes && \
-   test "$with_FreeBSD" != yes && \
-   test "$with_null" != yes && \
-   test "$with_WinNT" != yes; then
-  with_Linux=yes
-fi
-
-if test "$with_Linux" = yes; then
-  HOST_O=host-linux.o
-  KERNEL_TARGET=plex86.o
-  HOST_TARGET=linux-target
-  HOST_CLEAN=linux-clean
-  HOSTOS=LINUX
-  FULL_LINK=
-elif test "$with_BeOS" = yes; then
-  HOST_O=host-beos.o
-  KERNEL_TARGET=plex86
-  HOST_TARGET=
-  HOST_CLEAN=
-  HOSTOS=BEOS
-  FULL_LINK=
-elif test "$with_NetBSD" = yes; then
-  HOST_O=host-netbsd.o
-  KERNEL_TARGET=plex86.o
-  HOST_TARGET=netbsd-target
-  HOST_CLEAN=netbsd-clean
-  HOSTOS=NETBSD
-  FULL_LINK=
-elif test "$with_FreeBSD" = yes; then
-  HOST_O=host-freebsd.o
-  KERNEL_TARGET=plex86.o
-  HOST_TARGET=freebsd-target
-  HOST_CLEAN=freebsd-clean
-  HOSTOS=FREEBSD
-  FULL_LINK=
-elif test "$with_null" = yes; then
-  HOST_O=host-null.o
-  KERNEL_TARGET=plex86.o
-  HOST_TARGET=null-target
-  HOST_CLEAN=null-clean
-  HOSTOS=NULL
-  FULL_LINK='$(CC) -o a.out plex86.o'
-else
-  echo " "
-  echo "ERROR: Your system is not supported yet"
-  exit 1
-fi
-
-
-
-
-
-
-
-
-
-SUFFIX_LINE='.SUFFIXES: .cc'
-CPP_SUFFIX='cc'
-DASH="-"
-SLASH="/"
-CXXFP=""
-CFP=""
-OFP="-o "
-MAKELIB="ar rv \$@"
-RMCOMMAND="rm -f "
-EXE=""
-COMMAND_SEPARATOR="&& \\"
-CD_UP_ONE="echo done"
-CD_UP_TWO="echo done"
-INSTRUMENT_DIR='instrument/'
-VIDEO_OBJS='$(VIDEO_OBJS_VGA)'
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-trap '' 1 2 15
-cat > confcache <<\EOF
-# This file is a shell script that caches the results of configure
-# tests run on this system so they can be shared between configure
-# scripts and configure runs.  It is not useful on other systems.
-# If it contains results you don't want to keep, you may remove or edit it.
-#
-# By default, configure uses ./config.cache as the cache file,
-# creating it if it does not exist already.  You can give configure
-# the --cache-file=FILE option to use a different cache file; that is
-# what configure does when it calls configure scripts in
-# subdirectories, so they share the cache.
-# Giving --cache-file=/dev/null disables caching, for debugging configure.
-# config.status only pays attention to the cache file if you give it the
-# --recheck option to rerun configure.
-#
-EOF
-# The following way of writing the cache mishandles newlines in values,
-# but we know of no workaround that is simple, portable, and efficient.
-# So, don't put newlines in cache variables' values.
-# Ultrix sh set writes to stderr and can't be redirected directly,
-# and sets the high bit in the cache file unless we assign to the vars.
-(set) 2>&1 |
-  case `(ac_space=' '; set | grep ac_space) 2>&1` in
-  *ac_space=\ *)
-    # `set' does not quote correctly, so add quotes (double-quote substitution
-    # turns \\\\ into \\, and sed turns \\ into \).
-    sed -n \
-      -e "s/'/'\\\\''/g" \
-      -e "s/^\\([a-zA-Z0-9_]*_cv_[a-zA-Z0-9_]*\\)=\\(.*\\)/\\1=\${\\1='\\2'}/p"
-    ;;
-  *)
-    # `set' quotes correctly as required by POSIX, so do not add quotes.
-    sed -n -e 's/^\([a-zA-Z0-9_]*_cv_[a-zA-Z0-9_]*\)=\(.*\)/\1=${\1=\2}/p'
-    ;;
-  esac >> confcache
-if cmp -s $cache_file confcache; then
-  :
-else
-  if test -w $cache_file; then
-    echo "updating cache $cache_file"
-    cat confcache > $cache_file
-  else
-    echo "not updating unwritable cache $cache_file"
-  fi
-fi
-rm -f confcache
-
-trap 'rm -fr conftest* confdefs* core core.* *.core $ac_clean_files; exit 1' 1 2 15
-
-test "x$prefix" = xNONE && prefix=$ac_default_prefix
-# Let make expand exec_prefix.
-test "x$exec_prefix" = xNONE && exec_prefix='${prefix}'
-
-# Any assignment to VPATH causes Sun make to only execute
-# the first set of double-colon rules, so remove it if not needed.
-# If there is a colon in the path, we need to keep it.
-if test "x$srcdir" = x.; then
-  ac_vpsub='/^[ 	]*VPATH[ 	]*=[^:]*$/d'
-fi
-
-trap 'rm -f $CONFIG_STATUS conftest*; exit 1' 1 2 15
-
-DEFS=-DHAVE_CONFIG_H
-
-# Without the "./", some shells look in PATH for config.status.
-: ${CONFIG_STATUS=./config.status}
-
-echo creating $CONFIG_STATUS
-rm -f $CONFIG_STATUS
-cat > $CONFIG_STATUS <<EOF
-#! /bin/sh
-# Generated automatically by configure.
-# Run this file to recreate the current configuration.
-# This directory was configured as follows,
-# on host `(hostname || uname -n) 2>/dev/null | sed 1q`:
-#
-# $0 $ac_configure_args
-#
-# Compiler output produced by configure, useful for debugging
-# configure, is in ./config.log if it exists.
-
-ac_cs_usage="Usage: $CONFIG_STATUS [--recheck] [--version] [--help]"
-for ac_option
-do
-  case "\$ac_option" in
-  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
-    echo "running \${CONFIG_SHELL-/bin/sh} $0 $ac_configure_args --no-create --no-recursion"
-    exec \${CONFIG_SHELL-/bin/sh} $0 $ac_configure_args --no-create --no-recursion ;;
-  -version | --version | --versio | --versi | --vers | --ver | --ve | --v)
-    echo "$CONFIG_STATUS generated by autoconf version 2.13"
-    exit 0 ;;
-  -help | --help | --hel | --he | --h)
-    echo "\$ac_cs_usage"; exit 0 ;;
-  *) echo "\$ac_cs_usage"; exit 1 ;;
-  esac
-done
-
-ac_given_srcdir=$srcdir
-
-trap 'rm -fr `echo "
-Makefile 
-kernel/Makefile
- config.h" | sed "s/:[^ ]*//g"` conftest*; exit 1' 1 2 15
-EOF
-cat >> $CONFIG_STATUS <<EOF
-
-# Protect against being on the right side of a sed subst in config.status.
-sed 's/%@/@@/; s/@%/@@/; s/%g\$/@g/; /@g\$/s/[\\\\&%]/\\\\&/g;
- s/@@/%@/; s/@@/@%/; s/@g\$/%g/' > conftest.subs <<\\CEOF
-$ac_vpsub
-$extrasub
-s%@SHELL@%$SHELL%g
-s%@CFLAGS@%$CFLAGS%g
-s%@CPPFLAGS@%$CPPFLAGS%g
-s%@CXXFLAGS@%$CXXFLAGS%g
-s%@FFLAGS@%$FFLAGS%g
-s%@DEFS@%$DEFS%g
-s%@LDFLAGS@%$LDFLAGS%g
-s%@LIBS@%$LIBS%g
-s%@exec_prefix@%$exec_prefix%g
-s%@prefix@%$prefix%g
-s%@program_transform_name@%$program_transform_name%g
-s%@bindir@%$bindir%g
-s%@sbindir@%$sbindir%g
-s%@libexecdir@%$libexecdir%g
-s%@datadir@%$datadir%g
-s%@sysconfdir@%$sysconfdir%g
-s%@sharedstatedir@%$sharedstatedir%g
-s%@localstatedir@%$localstatedir%g
-s%@libdir@%$libdir%g
-s%@includedir@%$includedir%g
-s%@oldincludedir@%$oldincludedir%g
-s%@infodir@%$infodir%g
-s%@mandir@%$mandir%g
-s%@CC@%$CC%g
-s%@SET_MAKE@%$SET_MAKE%g
-s%@RANLIB@%$RANLIB%g
-s%@CPP@%$CPP%g
-s%@X_CFLAGS@%$X_CFLAGS%g
-s%@X_PRE_LIBS@%$X_PRE_LIBS%g
-s%@X_LIBS@%$X_LIBS%g
-s%@X_EXTRA_LIBS@%$X_EXTRA_LIBS%g
-s%@LINUX_SRC@%$LINUX_SRC%g
-s%@NETBSD_SRC@%$NETBSD_SRC%g
-s%@FREEBSD_SRC@%$FREEBSD_SRC%g
-s%@HOST_O@%$HOST_O%g
-s%@KERNEL_TARGET@%$KERNEL_TARGET%g
-s%@HOST_TARGET@%$HOST_TARGET%g
-s%@HOST_CLEAN@%$HOST_CLEAN%g
-s%@HOSTOS@%$HOSTOS%g
-s%@FULL_LINK@%$FULL_LINK%g
-s%@SUFFIX_LINE@%$SUFFIX_LINE%g
-s%@CPP_SUFFIX@%$CPP_SUFFIX%g
-s%@DASH@%$DASH%g
-s%@SLASH@%$SLASH%g
-s%@CXXFP@%$CXXFP%g
-s%@CFP@%$CFP%g
-s%@OFP@%$OFP%g
-s%@MAKELIB@%$MAKELIB%g
-s%@RMCOMMAND@%$RMCOMMAND%g
-s%@EXE@%$EXE%g
-s%@COMMAND_SEPARATOR@%$COMMAND_SEPARATOR%g
-s%@CD_UP_ONE@%$CD_UP_ONE%g
-s%@CD_UP_TWO@%$CD_UP_TWO%g
-
-CEOF
-EOF
-
-cat >> $CONFIG_STATUS <<\EOF
-
-# Split the substitutions into bite-sized pieces for seds with
-# small command number limits, like on Digital OSF/1 and HP-UX.
-ac_max_sed_cmds=90 # Maximum number of lines to put in a sed script.
-ac_file=1 # Number of current file.
-ac_beg=1 # First line for current file.
-ac_end=$ac_max_sed_cmds # Line after last line for current file.
-ac_more_lines=:
-ac_sed_cmds=""
-while $ac_more_lines; do
-  if test $ac_beg -gt 1; then
-    sed "1,${ac_beg}d; ${ac_end}q" conftest.subs > conftest.s$ac_file
-  else
-    sed "${ac_end}q" conftest.subs > conftest.s$ac_file
-  fi
-  if test ! -s conftest.s$ac_file; then
-    ac_more_lines=false
-    rm -f conftest.s$ac_file
-  else
-    if test -z "$ac_sed_cmds"; then
-      ac_sed_cmds="sed -f conftest.s$ac_file"
-    else
-      ac_sed_cmds="$ac_sed_cmds | sed -f conftest.s$ac_file"
-    fi
-    ac_file=`expr $ac_file + 1`
-    ac_beg=$ac_end
-    ac_end=`expr $ac_end + $ac_max_sed_cmds`
-  fi
-done
-if test -z "$ac_sed_cmds"; then
-  ac_sed_cmds=cat
-fi
-EOF
-
-cat >> $CONFIG_STATUS <<EOF
-
-CONFIG_FILES=\${CONFIG_FILES-"Makefile 
-kernel/Makefile
-"}
-EOF
-cat >> $CONFIG_STATUS <<\EOF
-for ac_file in .. $CONFIG_FILES; do if test "x$ac_file" != x..; then
-  # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
-  case "$ac_file" in
-  *:*) ac_file_in=`echo "$ac_file"|sed 's%[^:]*:%%'`
-       ac_file=`echo "$ac_file"|sed 's%:.*%%'` ;;
-  *) ac_file_in="${ac_file}.in" ;;
-  esac
-
-  # Adjust a relative srcdir, top_srcdir, and INSTALL for subdirectories.
-
-  # Remove last slash and all that follows it.  Not all systems have dirname.
-  ac_dir=`echo $ac_file|sed 's%/[^/][^/]*$%%'`
-  if test "$ac_dir" != "$ac_file" && test "$ac_dir" != .; then
-    # The file is in a subdirectory.
-    test ! -d "$ac_dir" && mkdir "$ac_dir"
-    ac_dir_suffix="/`echo $ac_dir|sed 's%^\./%%'`"
-    # A "../" for each directory in $ac_dir_suffix.
-    ac_dots=`echo $ac_dir_suffix|sed 's%/[^/]*%../%g'`
-  else
-    ac_dir_suffix= ac_dots=
-  fi
-
-  case "$ac_given_srcdir" in
-  .)  srcdir=.
-      if test -z "$ac_dots"; then top_srcdir=.
-      else top_srcdir=`echo $ac_dots|sed 's%/$%%'`; fi ;;
-  /*) srcdir="$ac_given_srcdir$ac_dir_suffix"; top_srcdir="$ac_given_srcdir" ;;
-  *) # Relative path.
-    srcdir="$ac_dots$ac_given_srcdir$ac_dir_suffix"
-    top_srcdir="$ac_dots$ac_given_srcdir" ;;
-  esac
-
-
-  echo creating "$ac_file"
-  rm -f "$ac_file"
-  configure_input="Generated automatically from `echo $ac_file_in|sed 's%.*/%%'` by configure."
-  case "$ac_file" in
-  *Makefile*) ac_comsub="1i\\
-# $configure_input" ;;
-  *) ac_comsub= ;;
-  esac
-
-  ac_file_inputs=`echo $ac_file_in|sed -e "s%^%$ac_given_srcdir/%" -e "s%:% $ac_given_srcdir/%g"`
-  sed -e "$ac_comsub
-s%@configure_input@%$configure_input%g
-s%@srcdir@%$srcdir%g
-s%@top_srcdir@%$top_srcdir%g
-" $ac_file_inputs | (eval "$ac_sed_cmds") > $ac_file
-fi; done
-rm -f conftest.s*
-
-# These sed commands are passed to sed as "A NAME B NAME C VALUE D", where
-# NAME is the cpp macro being defined and VALUE is the value it is being given.
-#
-# ac_d sets the value in "#define NAME VALUE" lines.
-ac_dA='s%^\([ 	]*\)#\([ 	]*define[ 	][ 	]*\)'
-ac_dB='\([ 	][ 	]*\)[^ 	]*%\1#\2'
-ac_dC='\3'
-ac_dD='%g'
-# ac_u turns "#undef NAME" with trailing blanks into "#define NAME VALUE".
-ac_uA='s%^\([ 	]*\)#\([ 	]*\)undef\([ 	][ 	]*\)'
-ac_uB='\([ 	]\)%\1#\2define\3'
-ac_uC=' '
-ac_uD='\4%g'
-# ac_e turns "#undef NAME" without trailing blanks into "#define NAME VALUE".
-ac_eA='s%^\([ 	]*\)#\([ 	]*\)undef\([ 	][ 	]*\)'
-ac_eB='$%\1#\2define\3'
-ac_eC=' '
-ac_eD='%g'
-
-if test "${CONFIG_HEADERS+set}" != set; then
-EOF
-cat >> $CONFIG_STATUS <<EOF
-  CONFIG_HEADERS="config.h"
-EOF
-cat >> $CONFIG_STATUS <<\EOF
-fi
-for ac_file in .. $CONFIG_HEADERS; do if test "x$ac_file" != x..; then
-  # Support "outfile[:infile[:infile...]]", defaulting infile="outfile.in".
-  case "$ac_file" in
-  *:*) ac_file_in=`echo "$ac_file"|sed 's%[^:]*:%%'`
-       ac_file=`echo "$ac_file"|sed 's%:.*%%'` ;;
-  *) ac_file_in="${ac_file}.in" ;;
-  esac
-
-  echo creating $ac_file
-
-  rm -f conftest.frag conftest.in conftest.out
-  ac_file_inputs=`echo $ac_file_in|sed -e "s%^%$ac_given_srcdir/%" -e "s%:% $ac_given_srcdir/%g"`
-  cat $ac_file_inputs > conftest.in
-
-EOF
-
-# Transform confdefs.h into a sed script conftest.vals that substitutes
-# the proper values into config.h.in to produce config.h.  And first:
-# Protect against being on the right side of a sed subst in config.status.
-# Protect against being in an unquoted here document in config.status.
-rm -f conftest.vals
-cat > conftest.hdr <<\EOF
-s/[\\&%]/\\&/g
-s%[\\$`]%\\&%g
-s%#define \([A-Za-z_][A-Za-z0-9_]*\) *\(.*\)%${ac_dA}\1${ac_dB}\1${ac_dC}\2${ac_dD}%gp
-s%ac_d%ac_u%gp
-s%ac_u%ac_e%gp
-EOF
-sed -n -f conftest.hdr confdefs.h > conftest.vals
-rm -f conftest.hdr
-
-# This sed command replaces #undef with comments.  This is necessary, for
-# example, in the case of _POSIX_SOURCE, which is predefined and required
-# on some systems where configure will not decide to define it.
-cat >> conftest.vals <<\EOF
-s%^[ 	]*#[ 	]*undef[ 	][ 	]*[a-zA-Z_][a-zA-Z_0-9]*%/* & */%
-EOF
-
-# Break up conftest.vals because some shells have a limit on
-# the size of here documents, and old seds have small limits too.
-
-rm -f conftest.tail
-while :
-do
-  ac_lines=`grep -c . conftest.vals`
-  # grep -c gives empty output for an empty file on some AIX systems.
-  if test -z "$ac_lines" || test "$ac_lines" -eq 0; then break; fi
-  # Write a limited-size here document to conftest.frag.
-  echo '  cat > conftest.frag <<CEOF' >> $CONFIG_STATUS
-  sed ${ac_max_here_lines}q conftest.vals >> $CONFIG_STATUS
-  echo 'CEOF
-  sed -f conftest.frag conftest.in > conftest.out
-  rm -f conftest.in
-  mv conftest.out conftest.in
-' >> $CONFIG_STATUS
-  sed 1,${ac_max_here_lines}d conftest.vals > conftest.tail
-  rm -f conftest.vals
-  mv conftest.tail conftest.vals
-done
-rm -f conftest.vals
-
-cat >> $CONFIG_STATUS <<\EOF
-  rm -f conftest.frag conftest.h
-  echo "/* $ac_file.  Generated automatically by configure.  */" > conftest.h
-  cat conftest.in >> conftest.h
-  rm -f conftest.in
-  if cmp -s $ac_file conftest.h 2>/dev/null; then
-    echo "$ac_file is unchanged"
-    rm -f conftest.h
-  else
-    # Remove last slash and all that follows it.  Not all systems have dirname.
-      ac_dir=`echo $ac_file|sed 's%/[^/][^/]*$%%'`
-      if test "$ac_dir" != "$ac_file" && test "$ac_dir" != .; then
-      # The file is in a subdirectory.
-      test ! -d "$ac_dir" && mkdir "$ac_dir"
-    fi
-    rm -f $ac_file
-    mv conftest.h $ac_file
-  fi
-fi; done
-
-EOF
-cat >> $CONFIG_STATUS <<EOF
-
-EOF
-cat >> $CONFIG_STATUS <<\EOF
-
-exit 0
-EOF
-chmod +x $CONFIG_STATUS
-rm -fr confdefs* $ac_clean_files
-test "$no_create" = yes || ${CONFIG_SHELL-/bin/sh} $CONFIG_STATUS || exit 1
-
diff -Nur bochs-2.0.2+20030829.old/plex86/configure.in bochs-2.0.2+20030829/plex86/configure.in
--- bochs-2.0.2+20030829.old/plex86/configure.in	2003-01-01 17:32:04.000000000 +0000
+++ bochs-2.0.2+20030829/plex86/configure.in	1970-01-01 00:00:00.000000000 +0000
@@ -1,169 +0,0 @@
-dnl // Process this file with autoconf to produce a configure script.
-
-AC_PREREQ(2.4)
-AC_INIT(COPYING)
-AC_CONFIG_HEADER(config.h)
-
-changequote(<<, >>)
-changequote([, ])
-
-AC_PROG_CC
-AC_PROG_MAKE_SET
-AC_PROG_RANLIB
-
-AC_PATH_XTRA
-
-AC_C_INLINE
-AC_CHECK_SIZEOF(unsigned char, 0)
-AC_CHECK_SIZEOF(unsigned short, 0)
-AC_CHECK_SIZEOF(unsigned int, 0)
-AC_CHECK_SIZEOF(unsigned long, 0)
-AC_CHECK_SIZEOF(unsigned long long, 0)
-
-dnl When compiling with gcc, use appropriate warning level
-if test "$GCC" = "yes"; then
-  CFLAGS="$CFLAGS -Wall -Wstrict-prototypes"
-fi
-if test "$GXX" = "yes"; then
-  CXXFLAGS="$CXXFLAGS -Wall -Wstrict-prototypes"
-fi
-
-AC_ARG_WITH(WinNT,
-  [  --with-WinNT                      WinNT host],
-  )
-
-AC_ARG_WITH(BeOS,
-  [  --with-BeOS                       BeOS host],
-  )
-
-AC_ARG_WITH(Linux,
-  [  --with-Linux                      Linux host],
-  )
-
-AC_ARG_WITH(NetBSD,
-  [  --with-NetBSD                     NetBSD host],
-  )
-
-AC_ARG_WITH(FreeBSD,
-  [  --with-FreeBSD                    FreeBSD host],
-  )
-
-AC_ARG_WITH(null,
-  [  --with-null                       No real host],
-  )
-
-AC_ARG_WITH(linux-source,
-  [  --with-linux-source=dir           Linux kernel source dir],
-  [ LINUX_SRC="$withval" ],
-  [ LINUX_SRC="/lib/modules/`uname -r`/build" ]
-  )
-AC_SUBST(LINUX_SRC)
-
-AC_ARG_WITH(netbsd-source,
-  [  --with-netbsd-source=dir          NetBSD kernel source dir],
-  [ NETBSD_SRC="$withval" ],
-  [ NETBSD_SRC="/sys" ]
-  )
-AC_SUBST(NETBSD_SRC)
-
-AC_ARG_WITH(freebsd-source,
-  [  --with-freebsd-source=dir          FreeBSD kernel source dir],
-  [ FREEBSD_SRC="$withval" ],
-  [ FREEBSD_SRC="/sys" ]
-  )
-AC_SUBST(FREEBSD_SRC)
-
-dnl // make sure Linux is default host if no other chosen
-if test "$with_Linux" != yes && \
-   test "$with_BeOS" != yes && \
-   test "$with_NetBSD" != yes && \
-   test "$with_FreeBSD" != yes && \
-   test "$with_null" != yes && \
-   test "$with_WinNT" != yes; then
-  with_Linux=yes
-fi
-
-if test "$with_Linux" = yes; then
-  HOST_O=host-linux.o
-  KERNEL_TARGET=plex86.o
-  HOST_TARGET=linux-target
-  HOST_CLEAN=linux-clean
-  HOSTOS=LINUX
-  FULL_LINK=
-elif test "$with_BeOS" = yes; then
-  HOST_O=host-beos.o
-  KERNEL_TARGET=plex86
-  HOST_TARGET=
-  HOST_CLEAN=
-  HOSTOS=BEOS
-  FULL_LINK=
-elif test "$with_NetBSD" = yes; then
-  HOST_O=host-netbsd.o
-  KERNEL_TARGET=plex86.o
-  HOST_TARGET=netbsd-target
-  HOST_CLEAN=netbsd-clean
-  HOSTOS=NETBSD
-  FULL_LINK=
-elif test "$with_FreeBSD" = yes; then
-  HOST_O=host-freebsd.o
-  KERNEL_TARGET=plex86.o
-  HOST_TARGET=freebsd-target
-  HOST_CLEAN=freebsd-clean
-  HOSTOS=FREEBSD
-  FULL_LINK=
-elif test "$with_null" = yes; then
-  HOST_O=host-null.o
-  KERNEL_TARGET=plex86.o
-  HOST_TARGET=null-target
-  HOST_CLEAN=null-clean
-  HOSTOS=NULL
-  FULL_LINK='$(CC) -o a.out plex86.o'
-else
-  echo " "
-  echo "ERROR: Your system is not supported yet"
-  exit 1
-fi
-
-
-dnl // code to test if CFLAGS is set.  If not, use defaults
-AC_SUBST(HOST_O)
-AC_SUBST(KERNEL_TARGET)
-AC_SUBST(HOST_TARGET)
-AC_SUBST(HOST_CLEAN)
-AC_SUBST(HOSTOS)
-AC_SUBST(FULL_LINK)
-
-SUFFIX_LINE='.SUFFIXES: .cc'
-CPP_SUFFIX='cc'
-DASH="-"
-SLASH="/"
-CXXFP=""
-CFP=""
-OFP="-o "
-MAKELIB="ar rv \$@"
-RMCOMMAND="rm -f "
-EXE=""
-COMMAND_SEPARATOR="&& \\"
-CD_UP_ONE="echo done"
-CD_UP_TWO="echo done"
-INSTRUMENT_DIR='instrument/'
-VIDEO_OBJS='$(VIDEO_OBJS_VGA)'
-
-AC_SUBST(SUFFIX_LINE)
-AC_SUBST(CPP_SUFFIX)
-AC_SUBST(DASH)
-AC_SUBST(SLASH)
-AC_SUBST(CXXFP)
-AC_SUBST(CFP)
-AC_SUBST(OFP)
-AC_SUBST(MAKELIB)
-AC_SUBST(RMCOMMAND)
-AC_SUBST(EXE)
-AC_SUBST(COMMAND_SEPARATOR)
-AC_SUBST(CD_UP_ONE)
-AC_SUBST(CD_UP_TWO)
-
-AC_OUTPUT([
-Makefile 
-kernel/Makefile
-])
diff -Nur bochs-2.0.2+20030829.old/plex86/descriptor.h bochs-2.0.2+20030829/plex86/descriptor.h
--- bochs-2.0.2+20030829.old/plex86/descriptor.h	2003-01-01 17:32:04.000000000 +0000
+++ bochs-2.0.2+20030829/plex86/descriptor.h	2003-08-29 14:31:40.000000000 +0000
@@ -1,5 +1,5 @@
 /************************************************************************
- * $Id: descriptor.h,v 1.1 2003/01/01 17:32:04 kevinlawton Exp $
+ * $Id: descriptor.h,v 0.0 2002/07/21 23:14:54 DemonLord Exp $
  ************************************************************************
  *
  *  plex86: run multiple x86 operating systems concurrently
diff -Nur bochs-2.0.2+20030829.old/plex86/kernel/Makefile.in bochs-2.0.2+20030829/plex86/kernel/Makefile.in
--- bochs-2.0.2+20030829.old/plex86/kernel/Makefile.in	2003-01-02 02:08:22.000000000 +0000
+++ bochs-2.0.2+20030829/plex86/kernel/Makefile.in	1970-01-01 00:00:00.000000000 +0000
@@ -1,127 +0,0 @@
-#  plex86: run multiple x86 operating systems concurrently
-#  Copyright (C) 1999-2001 Kevin P. Lawton
-#
-#  This library is free software; you can redistribute it and/or
-#  modify it under the terms of the GNU Lesser General Public
-#  License as published by the Free Software Foundation; either
-#  version 2 of the License, or (at your option) any later version.
-#
-#  This library is distributed in the hope that it will be useful,
-#  but WITHOUT ANY WARRANTY; without even the implied warranty of
-#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-#  Lesser General Public License for more details.
-#
-#  You should have received a copy of the GNU Lesser General Public
-#  License along with this library; if not, write to the Free Software
-#  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-
-
-CC      = @CC@
-CFLAGS  = @CFLAGS@
-LDFLAGS = @LDFLAGS@
-KERNEL_TARGET = @KERNEL_TARGET@
-HOST_TARGET = @HOST_TARGET@
-HOST_CLEAN = @HOST_CLEAN@
-
-srcdir	= @srcdir@
-VPATH	= @srcdir@
-
-LD = ld
-
-HOST_O = @HOST_O@
-
-# extra kernel CFLAGS and LDFLAGS for each host OS
-KCFLAGS_LINUX  = -fno-strength-reduce -fomit-frame-pointer \
-                 -malign-loops=2 -malign-jumps=2 -malign-functions=2 \
-                 -D__KERNEL__ -I@LINUX_SRC@/include -DCPU=586 -DMODULE
-KLDFLAGS_LINUX = -r
-
-
-KCFLAGS_NULL   = -fno-strength-reduce -fomit-frame-pointer \
-                 -malign-loops=2 -malign-jumps=2 -malign-functions=2 \
-                 -D__KERNEL__ -DCPU=586
-KLDFLAGS_NULL  = -r
-
-
-KCFLAGS_NETBSD  = -fno-strength-reduce -nostdinc -fomit-frame-pointer \
-                 -malign-loops=2 -malign-jumps=2 -malign-functions=2 \
-                 -D_KERNEL -I@NETBSD_SRC@ -I@NETBSD_SRC@/arch -I. -D_LKM
-KLDFLAGS_NETBSD = -r
-
-
-KCFLAGS_FREEBSD  = -fno-strength-reduce -nostdinc -fomit-frame-pointer \
-                 -malign-loops=2 -malign-jumps=2 -malign-functions=2 \
-                 -D_KERNEL -I@FREEBSD_SRC@ -I@FREEBSD_SRC@/sys -I. -D_LKM \
-		 -DFREEBSD_PLEX86_DEBUG
-KLDFLAGS_FREEBSD = -r
-
-KCFLAGS_BEOS   =
-KLDFLAGS_BEOS  = -nostdlib /boot/develop/lib/x86/_KERNEL_
-
-KLDFLAGS  = $(KLDFLAGS_@HOSTOS@)
-
-ALL_CFLAGS = $(CFLAGS) $(KCFLAGS_@HOSTOS@) -I$(srcdir)/include -I$(srcdir)/..
-
-
-.c.o:
-	$(CC) -c $(ALL_CFLAGS) $<
-.S.o:
-	$(CC) -c $(ALL_CFLAGS) -D__ASSEMBLY__ $<
-
-main_target: $(HOST_TARGET) $(KERNEL_TARGET)
-	@FULL_LINK@
-
-$(KERNEL_TARGET): $(HOST_O) monitor-host.o \
-		nexus.o print-mon.o \
-		util-nexus.o \
-		fault-mon.o panic-mon.o \
-		paging-mon.o monitor-mon.o
-	$(LD) $(KLDFLAGS) $^ -o $@
-
-clean: $(HOST_CLEAN) main_clean
-
-main_clean:
-	/bin/rm -f *.o *.s $(KERNEL_TARGET) a.out
-
-dist-clean: clean
-	/bin/rm -f Makefile
-
-# Linux specific targets
-linux-target:
-
-linux-clean:
-
-# Null specific targets
-null-target:
-
-null-clean:
-
-
-# NetBSD specific targets
-netbsd-target: netbsd-machine
-
-netbsd-machine:
-	ln -sf @NETBSD_SRC@/arch/i386/include machine
-
-netbsd-clean:
-	/bin/rm -f machine
-
-# FreeBSD specific targets
-freebsd-target: freebsd-machine
-	[ -r opt_posix.h ] || touch opt_posix.h
-
-freebsd-machine:
-	ln -sf @FREEBSD_SRC@/i386/include machine
-
-freebsd-clean:
-	/bin/rm -f opt_posix.h
-	/bin/rm -f machine
-
-# BeOS specific targets
-beos-install: $(KERNEL_TARGET)
-	cp -f $(KERNEL_TARGET) /boot/home/config/add-ons/kernel/drivers/bin
-	mkdir -p /boot/home/config/add-ons/kernel/drivers/dev/misc
-	ln -sf ../../bin/$(KERNEL_TARGET) /boot/home/config/add-ons/kernel/drivers/dev/misc/$(KERNEL_TARGET)
-
-Makefile: Makefile.in ../config.status
-	cd ..; CONFIG_FILES=kernel/Makefile CONFIG_HEADERS= $(SHELL) config.status
diff -Nur bochs-2.0.2+20030829.old/plex86/kernel/fault-mon.c bochs-2.0.2+20030829/plex86/kernel/fault-mon.c
--- bochs-2.0.2+20030829.old/plex86/kernel/fault-mon.c	2003-01-01 17:32:04.000000000 +0000
+++ bochs-2.0.2+20030829/plex86/kernel/fault-mon.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,306 +0,0 @@
-/*
- *  plex86: run multiple x86 operating systems concurrently
- *  Copyright (C) 1999-2003 Kevin P. Lawton
- *
- *  fault-mon.c:  fault/int handlers for VM monitor - monitor space.
- *
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Lesser General Public
- *  License as published by the Free Software Foundation; either
- *  version 2 of the License, or (at your option) any later version.
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- */
-
-
-#include "plex86.h"
-#define IN_MONITOR_SPACE
-#include "monitor.h"
-
-
-
-
-
-/* The monitor stack frame.  When an exception or interrupt occurrs
- * during the execution of either guest or monitor code, the following
- * values are pushed.
- * 
- * ss
- * esp
- * eflags    Values pushed by the CPU and interrupt stub.  To simplify
- * cs        things, the stub pushes an error of zero for those
- * eip       events which don't naturally cause an error push, and
- * error     also pushes the vector of the exception/interrupt.
- * vector
- *
- * eax
- * ecx
- * edx       General registers, pushed with a PUSHA instruction,
- * ebx       by code below.
- * <esp>
- * ebp
- * esi
- * edi
- *
- * es
- * ds        Segment selectors, pushed by code below.
- * fs
- * gs
- */
-
-void handleMonFault(guest_context_t *monContext);
-
-  static inline
-Bit32u readCR2(void)
-{
-  Bit32u cr2;
-  asm volatile ("movl %%cr2, %0" : "=r" (cr2));
-  return( cr2 );
-}
-
-
-asm (
-".text                  \n\t"
-
-/* __handle_fault:  This is called by all of the monitor's fault handler
- *     stubs.  A fault could have originated from execution of the guest
- *     (due to virtualization conditions or natural fault generation) or
- *     from the monitor (currently only due to bugs in the monitor).
- */
-".globl __handle_fault  \n\t"
-"__handle_fault:        \n\t"
-"  pushal               \n\t" /* Save general registers */
-"  pushl %es            \n\t" /* Save segment registers */
-"  pushl %ds            \n\t"
-"  pushl %fs            \n\t"
-"  pushl %gs            \n\t"
-"  movl  60(%esp), %eax     \n\t" /* CS pushed by CPU from fault */
-"  andl  $3, %eax           \n\t" /* Check CS.RPL bits */
-"  jz    __fault_from_mon   \n\t" /* RPL0 means from monitor */
-
-/* We have determined that the fault was from guest code.  Prepare
- * to call the monitor C code to do most of the fault handling.
- */
-"__fault_from_guest:    \n\t"
-"  movl  %ss, %eax      \n\t" /* Copy SS into DS/ES */
-"  movl  %eax, %ds      \n\t"
-"  movl  %eax, %es      \n\t"
-"  cld                  \n\t" /* gcc-compiled code needs this */
-"  pushl %esp           \n\t" /* Push pointer to saved guest context for C call.*/
-"  call handleGuestFault\n\t" /* Call the C monitor fault handler. */
-"  addl $4, %esp        \n\t" /* Remove arg from stack. */
-".globl __ret_to_guest  \n\t" /* Fault handled, work back to guest. */
-"__ret_to_guest:        \n\t"
-/* Return to the guest.  Restore registers from the monitor stack. */
-"  popl  %gs            \n\t" /* Restore guest segments */
-"  popl  %fs            \n\t"
-"  popl  %ds            \n\t"
-"  popl  %es            \n\t"
-"  popal                \n\t" /* Restore guest general registers */
-"  addl  $8, %esp       \n\t" /* Ignore vector and error dwords */
-"  iret                 \n\t" /* Resume execution of guest */
-
-
-"__fault_from_mon:               \n\t"
-"  cld                           \n\t" /* gcc-compiled code needs this */
-"  pushl %esp                    \n\t" /* Push pointer to context. */
-"  call handleMonFault           \n\t" /* Call C code for real work */
-"  addl $4, %esp                 \n\t"
-/* Return to monitor.  Restore state from the monitor stack. */
-"__ret_to_monitor:      \n\t"
-"  popl  %gs            \n\t" /* Restore monitor segments */
-"  popl  %fs            \n\t"
-"  popl  %ds            \n\t"
-"  popl  %es            \n\t"
-"  popal                \n\t" /* Restore monitor general registers */
-"  addl  $8, %esp       \n\t" /* ignore vector and error dwords */
-"  iret                 \n\t" /* Resume execution of monitor */
-
-
-/*
- * Hardware interrupt handler stub
- */
-".globl __handle_int    \n\t" /* Return to monitor code */
-"__handle_int:          \n\t"
-"  pushal               \n\t" /* Save guest general registers */
-"  pushl %es            \n\t" /* Save guest segment registers */
-"  pushl %ds            \n\t"
-"  pushl %fs            \n\t"
-"  pushl %gs            \n\t"
-
-"  movl  %ss, %eax      \n\t" /* Copy SS into DS/ES */
-"  movl  %eax, %ds      \n\t"
-"  movl  %eax, %es      \n\t"
-"  cld                  \n\t" /* gcc-compiled code needs this */
-"  pushl %esp           \n\t"
-"  call handleInt       \n\t" /* monitor interrupt handler */
-"  addl $4, %esp        \n\t"
-"  cmpl $0x1, %eax      \n\t" /* Was interrupt generated from monitor code? */
-"  je   __ret_to_monitor\n\t" /* Yes, so return to monitor code */
-"  jmp  __ret_to_guest  \n\t" /* No, so return to guest code */
-);
-
-
-
-  unsigned
-handleInt(guest_context_t *context)
-/*
- * handleInt(): Redirect a hardware interrupt back to the host
- */
-{
-  nexus_t *nexus = (nexus_t *) (((Bit32u) context) & 0xfffff000);
-  vm_t    *vm    = (vm_t *) nexus->vm;
-  unsigned from_monitor;
-  Bit64u t1;
-
-  t1 = vm_rdtsc();
-
-  if ( (context->cs & 0x0003) == 0x0003 ) {
-    /* End of elapsed guest execution duration.  Add elapsed */
-    /* cycles to time framework. */
-    vm->system.cyclesElapsed += (t1 - vm->system.t0);
-
-    from_monitor = 0; /* Event from guest code */
-    }
-  else {
-    from_monitor = 1; /* Event from monitor code */
-    }
-
-  /* Interrupts are off naturally here. */
-  vm->mon_request = MonReqRedirect;
-  vm->redirect_vector = context->vector;
-  vm->guest.__mon2host();
-  return(from_monitor);
-}
-
-
-  void
-handleGuestFault(guest_context_t *context)
-/*  Handle a fault from the guest.  Called from the assembly stub
- *  __handle_fault.
- */
-{
-  nexus_t *nexus = (nexus_t *) (((Bit32u) context) & 0xfffff000);
-  vm_t    *vm    = (vm_t *) nexus->vm;
-  Bit32u  cr2    = readCR2();
-  Bit64u  t1;
-
-  /* End of elapsed guest execution duration */
-  t1 = vm_rdtsc();
-  vm->system.cyclesElapsed += (t1 - vm->system.t0);
-
-#warning "Delete these checks"
-#if ANAL_CHECKS
-  if ( !context->eflags.fields.if_ )
-    monpanic(vm, "handleGuestFault: guest IF=0.\n");
-  if ( context->eflags.fields.vm )
-    monpanic(vm, "handleGuestFault: eflags.VM=1.\n");
-#endif
-
-  STI();
-
-  switch ( context->vector ) {
-    case ExceptionDB: /* 1 */
-      monpanic(vm, "handleGuestFault: #DB, method=%u not coded\n",
-        vm->executeMethod);
-#if 0
-      if (vm->executeMethod == RunGuestNMethodBreakpoint) {
-        /* Breakpoint generated because we requested it via TF=1 */
-        }
-      else {
-        monpanic(vm, "handleGuestFault: #DB, method=%u not coded\n",
-          vm->executeMethod);
-        }
-#endif
-      break;
-
-    case ExceptionBR: /* 5 */
-monpanic(vm, "handleGuestFault: BR unfinished.\n");
-      /* BOUND instruction fault; array index not in bounds */
-monpanic(vm, "handleGuestFault: emulate_exception was here.\n");
-      /*emulate_exception(vm, context->vector, 0);*/
-      break;
-
-    case ExceptionDE: /* 0 */
-    case ExceptionBP: /* 3 */
-    case ExceptionOF: /* 4 */
-    case ExceptionNM: /* 7 */
-    case ExceptionMF: /* 16 */
-      toHostGuestFault(vm, context->vector);
-      /*monpanic(vm, "handleGuestFault: DE/BP/OF/NM/MF unfinished.\n");*/
-      /*monpanic(vm, "handleGuestFault: %u\n", context->vector);*/
-      /* emulate_interrupt(vm, context->vector); */
-      break;
-
-    case ExceptionNP: /* 11 */
-    case ExceptionSS: /* 12 */
-    case ExceptionAC: /* 17 */
-monpanic(vm, "handleGuestFault: NP/SS/AC unfinished.\n");
-      /* use emulate_xyz() */
-      /*interrupt(vm, context->vector, 0, 1, context->error); */
-      monpanic(vm, "handleGuestFault: %u\n", context->vector);
-      break;
-
-    case ExceptionUD: /* 6 */
-    case ExceptionGP: /* 13 */
-      toHostGuestFault(vm, context->vector);
-      break;
-
-    case ExceptionPF: /* 14 */
-      guestPageFault(vm, context, cr2);
-      break;
-
-    default:
-      monpanic(vm, "handleGuestFault: Unhandled Fault: %u\n", context->vector);
-      break;
-    }
-}
-
-  void
-handleMonFault(guest_context_t *monContext)
-{
-  nexus_t *nexus = (nexus_t *) (((Bit32u) monContext) & 0xfffff000);
-  vm_t    *vm    = (vm_t *) nexus->vm;
-
-  if (vm->inMonFault)
-    monpanic(vm, "handleMonFault called recursively.\n");
-  vm->inMonFault = 1;
-monpanic(vm, "handleMonFault: vector=%u\n", monContext->vector);
-
-  /* Fault occurred inside monitor code. */
-
-  switch ( monContext->vector ) {
-    case ExceptionPF:
-    case ExceptionGP:
-      {
-      Bit32u cr2;
-      /*unsigned us, rw;*/
-
-      cr2 = readCR2();
-      STI();
-
-      if (monContext->error & 0x8) /* If RSVD bits used in PDir */
-        monpanic(vm, "handleMF: RSVD\n");
-      /*us = G_GetCPL(vm)==3;*/
-      /*rw = (monContext->error >> 1) & 1;*/
-      monpanic(vm, "handleMF: \n");
-      break;
-      }
-
-    default:
-      monpanic(vm, "hMF: vector=%u\n", monContext->vector);
-      break;
-    }
-
-  /*vm->abort_code = 1;*/
-  /*monpanic_nomess(vm);*/
-  CLI();
-  vm->inMonFault = 0;
-}
diff -Nur bochs-2.0.2+20030829.old/plex86/kernel/freebsd/Makefile bochs-2.0.2+20030829/plex86/kernel/freebsd/Makefile
--- bochs-2.0.2+20030829.old/plex86/kernel/freebsd/Makefile	2003-01-01 17:32:05.000000000 +0000
+++ bochs-2.0.2+20030829/plex86/kernel/freebsd/Makefile	1970-01-01 00:00:00.000000000 +0000
@@ -1,6 +0,0 @@
-# FreeBSD Kernel module makefile
-
-SRCS=	../plex86.o
-KMOD=	plex86
-
-.include <bsd.kmod.mk>
diff -Nur bochs-2.0.2+20030829.old/plex86/kernel/host-beos.c bochs-2.0.2+20030829/plex86/kernel/host-beos.c
--- bochs-2.0.2+20030829.old/plex86/kernel/host-beos.c	2003-01-01 17:32:04.000000000 +0000
+++ bochs-2.0.2+20030829/plex86/kernel/host-beos.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,219 +0,0 @@
-#include <Drivers.h>
-#include <KernelExport.h>
-#include <OS.h>
-#include <SupportDefs.h>
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-
-#include "plex86.h"
-#include "monitor.h"
-
-
-#define read_flags() ({ \
-        unsigned int __dummy; \
-        __asm__( \
-                                "pushfl\n\t" \
-                                "popl   %0\n\t" \
-                :"=r" (__dummy)); \
-        __dummy; \
-})
-#define write_flags(x) \
-        __asm__("push %0\n\tpopfl\n\t": :"r" (x))
-
-
-
-struct cookie {
-	sem_id		sem;
-
-	int			mon_ok;
-
-	uint32		irq_cnt[17];
-};
-
-static status_t
-driver_open(const char *name, ulong flags, void **_cookie)
-{
-	struct cookie *cookie;
-	status_t err;
-
-	cookie = calloc(sizeof(*cookie), 1);
-	if (!cookie)
-		return ENOMEM;
-	cookie->sem = create_sem(1, "plex86 mutex");
-	if (cookie->sem < 0) {
-		err = cookie->sem;
-		goto err1;
-	}
-	*_cookie = cookie;
-	return B_OK;
-
-err1:
-	free(cookie);
-	return err;
-}
-
-static status_t
-driver_close(void *cookie)
-{
-	return B_OK;
-}
-
-static status_t
-driver_free(void *_cookie)
-{
-	struct cookie *cookie = (struct cookie *)_cookie;
-	delete_sem(cookie->sem);
-	free(cookie);
-	return B_OK;
-}
-
-static status_t
-driver_read(void *cookie, off_t pos, void *buf, size_t *count)
-{
-	return B_OK;
-}
-
-
-static status_t
-driver_write(void *cookie, off_t pos, const void *buf, size_t *count)
-{
-	return B_OK;
-}
-
-static status_t
-driver_ioctl(void *_cookie, ulong cmd, void *buf, size_t len)
-{
-	struct cookie *cookie = (struct cookie *)_cookie;
-	uint32		cr0, arg, eflags_orig;
-	uchar		soft_int_vector;
-	status_t	err;
-
-	arg = *(uint32 *)buf;
-
-	switch (cmd) {
-		/* Allocate unpaged memory for the VM. */
-		/* arg is the number of megabytes to allocate */
-		/* Memory returned must not be pageable by the */
-		/* host OS, since the VM monitor will run in this */
-		/* memory as well.  Perhaps later, we can let */
-		/* the guest OS run in paged memory and reflect */
-		/* the page faults back to the host OS. */
-		case 0x6b02:
-			acquire_sem(cookie->sem);
-			init_monitor(MASTER_PIC_BASE_VECTOR, SLAVE_PIC_BASE_VECTOR, IRQ16_BASE_VECTOR);
-			cookie->mon_ok = 1;
-			release_sem(cookie->sem);
-			return B_OK;
-		
-		case 0x6b03:
-			/* linux-specific hack, unnecessary under BeOS */
-			return B_OK;
-		
-		/* run guest context for a time slice */
-		case 0x6b04:
-		{
-			cpu_status ps;
-
-			acquire_sem(cookie->sem);
-
-			if (!cookie->mon_ok) {
-				release_sem(cookie->sem);
-				return EPERM;
-			}
-
-			ps = disable_interrupts();
-
-			/* clear NT/IF/TF */
-			eflags_orig = read_flags();
-			write_flags(eflags_orig & ~0x00004300);
-
-			__host2guest();
-
-			write_flags(eflags_orig & ~0x00000200);
-
-			restore_interrupts(ps);
-
-			switch ( monitor_info.ret_because ) {
-				case RET_BECAUSE_IRQ:
-					/* reported vector is actually the IRQ# */
-
-					soft_int_vector = MASTER_PIC_BASE_VECTOR + monitor_info.vector;
-					soft_int(soft_int_vector);
-					cookie->irq_cnt[monitor_info.vector]++;
-					dprintf("plex86: irq %u\n", monitor_info.vector);
-					err = B_OK;
-					break;
-			
-				case RET_BECAUSE_INT:
-					dprintf("plex86: int %u\n", monitor_info.vector);
-					err = EFAULT;
-					break;
-
-				case RET_BECAUSE_EXC:
-					dprintf("plex86: exc %u\n", monitor_info.vector);
-					err = EFAULT;
-					break;
-
-				case RET_BECAUSE_TEST:
-					dprintf("plex86: test\n");
-					err = B_OK;
-					break;
-
-				default:
-					dprintf("plex86: unknown ret_because\n");
-					err = B_OK;
-					break;
-			}
-
-			release_sem(cookie->sem);
-			return err;
-		}
-		
-		case 0x6b05: /* tear down VM environment */
-			acquire_sem(cookie->sem);
-			cookie->mon_ok = 0;
-			release_sem(cookie->sem);
-			return B_OK;
-	}
-
-	return ENOSYS;
-}
-
-device_hooks driver_device = {
-	driver_open,
-	driver_close,
-	driver_free,
-	driver_ioctl,
-	driver_read,
-	driver_write
-};
-
-status_t
-init_driver (void)
-{
-	return B_OK;
-}
-
-void
-uninit_driver(void)
-{
-}
-
-const char **
-publish_devices(void)
-{
-	static const char *driver_names[] = {
-		"misc/plex86",
-		NULL
-	};
-	return (const char **)driver_names;
-}
-
-device_hooks *
-find_device(const char *name)
-{
-	return &driver_device;
-}
-
diff -Nur bochs-2.0.2+20030829.old/plex86/kernel/host-freebsd.c bochs-2.0.2+20030829/plex86/kernel/host-freebsd.c
--- bochs-2.0.2+20030829.old/plex86/kernel/host-freebsd.c	2003-01-01 17:32:04.000000000 +0000
+++ bochs-2.0.2+20030829/plex86/kernel/host-freebsd.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,569 +0,0 @@
-/*
- * plex86: run multiple x86 operating systems concurrently
- * 
- * Copyright (C) 2000 Frank van der Linden (fvdl@wasabisystems.com)
- * Copyright (C) 2000 Alexander Langer <alex@big.endian.de>
- * 
- * License as published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- * 
- * This library is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
- * License for more details.
- * 
- * You should have received a copy of the GNU Lesser General Public License
- * along with this library; if not, write to the Free Software Foundation,
- * Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- */
-
-#define DIAGNOSTIC 1
-#define CDEV_MAJOR	20
-#define timer_t __bsd_timer_t
-#define write_eflags __freebsd_write_eflags
-#define read_eflags __freebsd_read_eflags
-
-/* XXX recheck, which includes are needed */
-#include <sys/param.h>
-#include <sys/types.h>
-#include <sys/systm.h>
-
-#include <sys/proc.h>
-#include <sys/conf.h>
-#include <sys/exec.h>
-#include <sys/malloc.h>
-#include <sys/syslog.h>
-#include <sys/queue.h>
-#include <sys/signalvar.h>
-#include <sys/mman.h>
-#include <sys/kernel.h>
-#include <sys/linker.h>
-#include <sys/sysproto.h>
-
-#include <sys/module.h>
-
-#include <vm/vm.h>
-
-#include <machine/cpu.h>
-
-#undef timer_t
-#undef write_eflags
-#undef read_eflags
-
-#include "plex86.h"
-#define IN_HOST_SPACE
-#include "monitor.h"
-
-static          MALLOC_DEFINE(M_PLEX86, "plex86", "Plex86 mem");
-
-static d_open_t plex86_open;
-static d_close_t plex86_close;
-static d_mmap_t plex86_mmap;
-static d_ioctl_t plex86_ioctl;
-
-static unsigned retrieve_phy_pages(Bit32u *, int, void *, unsigned, int);
-static vm_t    *find_vm(struct proc * p);
-static void     register_vm(vm_t * vm, struct proc * p);
-static void     unregister_all(struct proc * p);
-
-static struct cdevsw plex86_cdevsw = {
-    /* open */	plex86_open,
-    /* close */	plex86_close,
-    /* read */	noread,
-    /* write */	nowrite,
-    /* ioctl */	plex86_ioctl,
-    /* poll */	nopoll,
-    /* mmap */	plex86_mmap,
-    /* strat */	nostrategy,
-    /* name */	"plex86",
-    /* major */	CDEV_MAJOR,
-    /* dump */	nodump,
-    /* psize */	nopsize,
-    /* flags */	0,
-    /* bmaj */	-1
-};
-
-/* For use with make_dev/destroy_dev */
-static dev_t    plex86_dev;
-
-static struct plex86_softc {
-    int             sc_open;
-}               plex86sc;
-
-monitor_pages_t monitor_pages;
-
-/*
- * Hash table stuff to maintain proc <-> vm mapping. 23 entries should be
- * plenty.. unless someone plans to run more than 23 guest OSs..
- * 
- * Note that a process can only open the device once with this scheme.
- */
-
-LIST_HEAD(plex86_hashhead, plex86_vmentry);
-
-struct plex86_vmentry {
-    pid_t           vm_pid;
-    vm_t           *vm_vm;
-    LIST_ENTRY(plex86_vmentry) vm_entry;
-};
-
-struct plex86_hashhead *plex86_hashtbl;
-u_long          plex86_hashmask;
-
-#define PLEX86_VMHASHSIZE	23
-#define PLEX86_VMHASH(p)	((u_long)((p)->p_pid) & plex86_hashmask)
-
-static int
-plex86_open(dev_t dev, int flags, int fmt, struct proc * p)
-{
-    vm_t           *vm;
-
-    if (suser_xxx(p->p_ucred, p, p->p_acflag) != 0)
-	return (EPERM);
-
-    vm = find_vm(p);
-    if (vm == NULL) {
-	vm = malloc(sizeof(vm_t), M_PLEX86, M_WAITOK);
-	if (vm == NULL)
-	    return EIO;
-	memset(vm, 0, sizeof(vm_t));
-	register_vm(vm, p);
-	plex86sc.sc_open++;
-    } else
-	return (EBUSY);
-
-  /* Kernel independent device open code. */
-  hostDeviceOpenInit(vm);
-
-#ifdef FREEBSD_PLEX86_DEBUG
-    printf("plex86: pid %u opened device, vm %p\n", p->p_pid, vm);
-#endif
-
-    return (0);
-}
-
-int
-plex86_close(dev_t dev, int flags, int fmt, struct proc * p)
-{
-    unregister_all(p);
-    plex86sc.sc_open = 0;
-#ifdef FREEBSD_PLEX86_DEBUG
-    printf("plex86: pid %u closed device\n", p->p_pid);
-#endif
-    return (0);
-}
-
-int
-plex86_mmap(dev_t dev, vm_offset_t offset, int nprot)
-{
-    struct proc    *p = curproc;
-    int             page;
-    vm_offset_t     endguestoff;
-    vm_t           *vm;
-
-    vm = find_vm(p);
-    if (vm == NULL)
-	return (ENXIO);
-
-#warning "kludge to mmap message buffer"
-    endguestoff = (vm_offset_t) (vm->pages.guest_n_megs * 1024 * 1024);
-    if (offset >= endguestoff && nprot == PROT_READ) {
-	page = (offset - endguestoff) / PAGE_SIZE;
-	return (vm->pages.log_buffer[page]);
-    }
-    page = offset / PAGE_SIZE;
-    if (page < 0 || page > vm->pages.guest_n_pages) {
-	log(LOG_WARNING, "plex86: mmap: offset %lx out of range\n",
-	    (unsigned long) offset);
-	return -1;
-    }
-    return vm->pages.guest[page];
-}
-
-int
-plex86_ioctl(dev_t dev, u_long cmd, caddr_t data, int flags,
-	     struct proc * p)
-{
-    int             error;
-    vm_t           *vm;
-
-    vm = find_vm(p);
-    if (vm == NULL)
-	return EINVAL;
-
-    switch (cmd) {
-    case PLEX86_ALLOCVPHYS:
-	{
-	    unsigned        arg = *((unsigned *) data);
-	    guest_cpu_t     guest_cpu;
-
-	    if (vm->mon_state != MON_STATE_UNINITIALIZED ||
-		vm->pages.guest_n_megs != 0)
-		return EBUSY;
-	    if (arg > PLEX86_MAX_PHY_MEGS || arg < 4 || (arg & ~0x3) != arg)
-		return EINVAL;
-
-	    /* Allocate memory */
-	    error = allocVmPages(vm, arg);
-	    if (error != 0) {
-		log(LOG_WARNING, "plex86: allocVmPages failed (%d)\n",
-		    error);
-		return ENOMEM;
-	    }
-	    if (init_guest_phy_mem(vm) != 0) {
-		log(LOG_ERR, "plex86: init_guest_phy_mem failed\n");
-		unallocVmPages(vm);
-		return EFAULT;
-	    }
-	    getCpuResetValues(&guest_cpu);
-	    log(LOG_WARNING, "plex86: cpu.cr0 = 0x%x\n", guest_cpu.cr0);
-	    if (!init_monitor(vm, 0, 0, &guest_cpu) ||
-		!setGuestCPU(vm, 0, &guest_cpu) ||
-		!mapMonitor(vm, guest_cpu.eflags, 0)) {
-		log(LOG_ERR, "plex86: init_monitor failed\n");
-		unallocVmPages(vm);
-		return EFAULT;
-	    }
-	    break;
-	}
-
-    case PLEX86_TEARDOWN:
-	unallocVmPages(vm);
-	break;
-
-    case PLEX86_ALLOCINT:
-	return EINVAL;
-    case PLEX86_RELEASEINT:
-	return EINVAL;
-    case PLEX86_PRESCANDEPTH:
-	{
-	    unsigned long   arg = *(unsigned long *) data;
-
-	    if ((arg < PrescanDepthMin) || (arg > PrescanDepthMax)) {
-		log(LOG_WARNING, "plex86: Requested prescan depth %lu"
-		    " out of range [%u..%u]\n", arg, PrescanDepthMin,
-		    PrescanDepthMax);
-		return EINVAL;
-	    }
-	    vm->prescanDepth = (unsigned) arg;
-	    break;
-	}
-    case PLEX86_SETINTR:
-	ioctlSetIntr(vm, *(unsigned long *) data);
-	break;
-    case PLEX86_SET_A20:
-	{
-	    unsigned long   arg = *(unsigned long *) data;
-	    if (!ioctlSetA20E(vm, arg))
-		return EINVAL;
-	    break;
-	}
-    case PLEX86_MESSAGEQ:
-	{
-	    vm_messages_t   msg;
-
-	    if (vm->mon_state != MON_STATE_RUNNABLE)
-		return EINVAL;
-
-	    error = copyin(*(void **) data, &msg.header, sizeof msg.header);
-	    if (error != 0)
-		return error;
-
-	    if ((msg.header.msg_len + sizeof(msg.header)) > sizeof(msg))
-		return EINVAL;
-
-	    if (msg.header.msg_len != 0) {
-		error = copyin(&((vm_messages_t *) * (void **) data)->msg,
-			       &msg.msg, msg.header.msg_len);
-		if (error != 0)
-		    return error;
-	    }
-	    if (ioctlMessageQ(vm, &msg)) {
-		log(LOG_WARNING, "plex86: ioctlMessageQ failed\n");
-		return EINVAL;
-	    }
-	    error = copyout(&msg, *(void **) data,
-			    sizeof(msg.header) + msg.header.msg_len);
-	    return error;
-	}
-    case PLEX86_RESET:
-	break;
-
-    case PLEX86_PHYMEM_MOD:
-	break;
-    case PLEX86_FORCE_INT:
-	if (vm->mon_state != MON_STATE_RUNNABLE)
-	    return -EINVAL;
-	vm->dbg_force_int = 0x100 | (unsigned) data;
-	break;
-    case PLEX86_PRESCANRING3:
-	{
-	    unsigned long   arg = *(unsigned long *) data;
-	    if (arg > PrescanRing3On) {
-		log(LOG_WARNING,
-		    "plex86: Requested PrescanRing3 val(%lu) OOB\n",
-		    arg);
-		return EINVAL;
-	    }
-	    vm->prescanRing3 = arg;
-	    break;
-	}
-
-    default:
-	log(LOG_WARNING, "plex86: unknown ioctl %lx\n", cmd);
-	return EINVAL;
-    }
-    return 0;
-}
-
-static void
-register_vm(vm_t * vm, struct proc * p)
-{
-    struct plex86_hashhead *php;
-    struct plex86_vmentry *vhp;
-
-    php = &plex86_hashtbl[PLEX86_VMHASH(p)];
-#if DIAGNOSTIC
-    for (vhp = php->lh_first; vhp != NULL; vhp = vhp->vm_entry.le_next) {
-	if (vhp->vm_pid == p->p_pid)
-	    panic("plex86: vm already registered, pid %u\n",
-		  p->p_pid);
-    }
-#endif
-    vhp = malloc(sizeof(struct plex86_vmentry), M_PLEX86, M_WAITOK);
-    vhp->vm_pid = p->p_pid;
-    vhp->vm_vm = vm;
-    LIST_INSERT_HEAD(php, vhp, vm_entry);
-}
-
-static void
-unregister_vm(vm_t * vm, struct proc * p)
-{
-    struct plex86_hashhead *php;
-    struct plex86_vmentry *vhp;
-
-    php = &plex86_hashtbl[PLEX86_VMHASH(p)];
-    for (vhp = php->lh_first; vhp != NULL; vhp = vhp->vm_entry.le_next) {
-	if (vhp->vm_pid == p->p_pid) {
-	    LIST_REMOVE(vhp, vm_entry);
-	    free(vhp->vm_vm, M_PLEX86);
-	    free(vhp, M_PLEX86);
-	    break;
-	}
-    }
-}
-
-static void
-unregister_all(struct proc * p)
-{
-    int             i;
-    struct plex86_hashhead *php;
-    struct plex86_vmentry *vhp;
-
-    php = &plex86_hashtbl[PLEX86_VMHASH(p)];
-    if (php == NULL)
-	return;
-    for (vhp = php->lh_first; vhp != NULL;
-	 vhp = vhp->vm_entry.le_next) {
-#ifdef FREEBSD_PLEX86_DEBUG
-	printf("plex86: unregister vm %p, pid %u\n",
-	       vhp->vm_vm, vhp->vm_pid);
-#endif
-	LIST_REMOVE(vhp, vm_entry);
-	if (vhp->vm_vm != NULL)
-	    free(vhp->vm_vm, M_PLEX86);
-	if (vhp != NULL)
-	    free(vhp, M_PLEX86);
-    }
-}
-
-static vm_t    *
-find_vm(struct proc * p)
-{
-    struct plex86_hashhead *php;
-    struct plex86_vmentry *vhp;
-
-    php = &plex86_hashtbl[PLEX86_VMHASH(p)];
-    for (vhp = php->lh_first; vhp != NULL; vhp = vhp->vm_entry.le_next) {
-	if (vhp->vm_pid == p->p_pid)
-	    return vhp->vm_vm;
-    }
-
-    return NULL;
-}
-
-static unsigned
-retrieve_phy_pages(Bit32u * page, int max_pages, void *addr_v, unsigned size,
-		   int aligned)
-{
-    Bit32u          start_addr;
-    unsigned        n_pages, i;
-
-    if (!aligned)
-	start_addr = (Bit32u) addr_v & ~(PAGE_SIZE - 1);
-    else {
-	start_addr = (Bit32u) addr_v;
-	if (start_addr & (PAGE_SIZE - 1)) {
-	    log(LOG_WARNING, "plex86: retrieve_phy_pages: address "
-		"%p not aligned\n", addr_v);
-	    return 0;
-	}
-    }
-
-    n_pages = (size + PAGE_SIZE - 1) / PAGE_SIZE;
-    if (n_pages > max_pages) {
-	log(LOG_WARNING, "plex86: retrieve_phy_pages: page list "
-	    "too small\n");
-	return (0);
-    }
-    for (i = 0; i < n_pages; i++) {
-	page[i] = kvtop((vm_offset_t) start_addr) / PAGE_SIZE;
-	start_addr += PAGE_SIZE;
-    }
-
-    return n_pages;
-}
-
-unsigned
-host_idle(void)
-{
-#if defined(want_resched)
-    if (want_resched) {
-#endif
-	yield(curproc, NULL); /* XXX */
-	need_resched(); /* XXX */
-#if defined(want_resched)
-    }
-#endif
-    printf("resched done\n");
-    return (CURSIG(curproc) == 0);
-}
-
-void           *
-host_alloc(unsigned long size)
-{
-    /*
-     * XXX - it wants this page-aligned apparently.
-	 */
-    if (size <= (PAGE_SIZE / 2))
-	size = PAGE_SIZE;
-    return (malloc(size, M_PLEX86, M_WAITOK));
-}
-
-void
-host_free(void *ptr)
-{
-    free(ptr, M_PLEX86);
-}
-
-unsigned
-host_map(Bit32u * page, int max_pages, void *ptr, unsigned size)
-{
-    return retrieve_phy_pages(page, max_pages, ptr, size, 1);
-}
-
-void           *
-host_alloc_page(void)
-{
-    return malloc(PAGE_SIZE, M_PLEX86, M_WAITOK);
-}
-
-void
-host_free_page(void *ptr)
-{
-    return free(ptr, M_PLEX86);
-}
-
-Bit32u
-host_map_page(void *ptr)
-{
-    Bit32u          u;
-
-    if (ptr == NULL)
-	return 0;
-    u = kvtop(ptr) / PAGE_SIZE;
-#if FREEBSD_PLEX86_DEBUG
-    printf("host_map_page(%p) -> %x\n", ptr, u);
-#endif
-    return u;
-}
-
-void
-hostprint(char *fmt,...)
-{
-    va_list         args;
-    int             ret;
-    unsigned char   buffer[256];
-
-    va_start(args, fmt);
-    ret = vsnprintf(buffer, 256, fmt, args);
-    if (ret == -1)
-	log(LOG_WARNING,
-	    "plex86: hostprint: vsnprintf returns error.\n");
-    else
-	log(LOG_WARNING, "plex86: %s\n", buffer);
-}
-
-static int
-plex86_modevent(module_t mod, int type, void *data)
-{
-    linker_file_t   lf;
-    int             error = 0;
-
-    switch (type) {
-    case MOD_LOAD:
-	plex86_hashtbl = NULL;
-
-	lf = linker_find_file_by_name("plex86");
-	if (lf == NULL) {
-	    printf("plex86: can't find linker_file 'plex86'\n");
-	    return (ENXIO);
-	}
-	monitor_pages.startOffset = lf->address;
-  monitor_pages.startOffsetPageAligned =
-      monitor_pages.startOffset & 0xfffff000;
-
-	if ((monitor_pages.n_pages = retrieve_phy_pages(monitor_pages.page,
-							PLEX86_MAX_MONITOR_PAGES,
-							lf->address,
-							lf->size,
-							0)) == 0) {
-	    log(LOG_WARNING, "plex86: could not store physical "
-		"addresses for monitor pages\n");
-	    return (ENXIO);
-	}
-	plex86_hashtbl = hashinit(PLEX86_VMHASHSIZE,
-				  M_PLEX86, &plex86_hashmask);
-
-	if (!hostModuleInit()) {
-	    log(LOG_WARNING, "hostModuleInit error\n");
-	    error = EINVAL;
-	}
-
-	plex86_dev = make_dev(&plex86_cdevsw, 0 /* minor */ , UID_ROOT,
-			      GID_WHEEL, 0600, "plex86");
-
-	printf("plex86: Module loaded.\n");
-	return (0);
-	break;
-    case MOD_UNLOAD:
-	if (plex86sc.sc_open != 0)
-	    return (EBUSY);
-
-	destroy_dev(plex86_dev);
-
-	if (plex86_hashtbl != NULL) {
-	    free(plex86_hashtbl, M_PLEX86);
-	}
-	printf("plex86: Module unloaded.\n");
-	break;
-
-    default:
-	error = ENXIO;
-	break;
-    }
-    return (error);
-}
-
-MODULE_VERSION(plex86, 1);
-DEV_MODULE(plex86, plex86_modevent, 0);
diff -Nur bochs-2.0.2+20030829.old/plex86/kernel/host-linux.c bochs-2.0.2+20030829/plex86/kernel/host-linux.c
--- bochs-2.0.2+20030829.old/plex86/kernel/host-linux.c	2003-01-10 04:27:51.000000000 +0000
+++ bochs-2.0.2+20030829/plex86/kernel/host-linux.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,800 +0,0 @@
-/*
- *  plex86: run multiple x86 operating systems concurrently
- *  Copyright (C) 1999-2003 Kevin P. Lawton
- *
- *  host-linux.c: Linux specific VM host driver functionality
- *
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Lesser General Public
- *  License as published by the Free Software Foundation; either
- *  version 2 of the License, or (at your option) any later version.
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- */
-
-#include "plex86.h"
-#define IN_HOST_SPACE
-#include "monitor.h"
-
-#include <linux/config.h>
-#include <linux/module.h>
-#include <linux/types.h>
-#include <linux/kernel.h>
-#include <linux/fs.h>
-#include <linux/mm.h>
-#include <linux/proc_fs.h>
-#include <linux/wrapper.h>
-#include <linux/version.h>
-#include <asm/irq.h>
-#include <asm/atomic.h>
-
-
-#ifndef VERSION_CODE
-#  define VERSION_CODE(vers,rel,seq) ( ((vers)<<16) | ((rel)<<8) | (seq) )
-#endif
-
-
-#if LINUX_VERSION_CODE < VERSION_CODE(2,4,20)
-/* I use get_user_pages() to find and pin physical pages of memory
- * underlying the guest physical memory malloc()'d from user space.
- * This became an exported symbol available for kernel modules
- * as of 2.4.20.  You will have to recode some functions for
- * lesser kernels.
- */
-#  error "Currently, you need Linux kernel 2.4.20 or above."
-#endif
-
-
-#if LINUX_VERSION_CODE >= VERSION_CODE(2,1,0)
-#  include <asm/uaccess.h>
-#endif
-
-#include <asm/io.h>
-
-
-
-/************************************************************************/
-/* Compatibility macros & convenience functions for older kernels       */
-/************************************************************************/
-
-#ifndef EXPORT_NO_SYMBOLS
-#  define EXPORT_NO_SYMBOLS register_symtab(NULL)
-#endif
-
-#if LINUX_VERSION_CODE >= VERSION_CODE(2,1,29)
-#  define proc_register_dynamic proc_register
-#endif
-
-#if LINUX_VERSION_CODE < VERSION_CODE(2,2,0)
-#define NEED_RESCHED need_resched
-#else
-#define NEED_RESCHED current->need_resched
-#endif
-
-
-
-/* Instrumentation of how many hardware interrupts were redirected
- * to the host, while the VM monitor/guest was running.  This can be
- * written to by multiple contexts, so it needs SMP protection.
- */
-static atomic_t interruptRedirCount[256];
-
-
-
-#if LINUX_VERSION_CODE < VERSION_CODE(2,1,0)
-  static inline unsigned long
-copy_from_user(void *to, const void *from, unsigned long n)
-{
-  int i;
-  if ( (i = verify_area(VERIFY_READ, from, n)) != 0 )
-    return i;
-  memcpy_fromfs(to, from, n);
-  return 0;
-}
-  static inline unsigned long
-copy_to_user(void *to, const void *from, unsigned long n)
-{
-  int i;
-  if ( (i = verify_area(VERIFY_WRITE, to, n)) != 0 )
-    return i;
-  memcpy_tofs(to, from, n);
-  return 0;
-}
-#endif
-
-#if LINUX_VERSION_CODE >= VERSION_CODE(2,1,18) && !defined(THIS_MODULE)
-/* Starting with version 2.1.18, the __this_module symbol is present,
- * but the THIS_MODULE #define was introduced much later ...
- */
-#define THIS_MODULE (&__this_module)
-#endif
-
-
-/************************************************************************/
-/* Declarations                                                         */
-/************************************************************************/
-
-/* Use dynamic major number allocation. (Set non-zero for static allocation) */
-#define PLEX86_MAJOR 0
-static int plex_major = PLEX86_MAJOR;
-#if LINUX_VERSION_CODE >= VERSION_CODE(2,1,18)
-MODULE_PARM(plex_major, "i");
-MODULE_PARM_DESC(plex_major, "major number (default " __MODULE_STRING(PLEX86_MAJOR) ")");
-#endif
-
-/* The kernel segment base. */
-#if LINUX_VERSION_CODE < VERSION_CODE(2,1,0)
-#  define KERNEL_OFFSET 0xc0000000
-#else
-#  define KERNEL_OFFSET 0x00000000
-#endif
-
-
-/* File operations. */
-static int plex86_ioctl(struct inode *, struct file *, unsigned int,
-                        unsigned long);
-static int plex86_open(struct inode *, struct file *);
-
-#if LINUX_VERSION_CODE >= VERSION_CODE(2,1,31)
-static int plex86_release(struct inode *, struct file *);
-#else
-static void plex86_release(struct inode *, struct file *);
-#endif
-
-#if LINUX_VERSION_CODE >= VERSION_CODE(2,1,0)
-static int plex86_mmap(struct file * file, struct vm_area_struct * vma);
-#else
-static int plex86_mmap(struct inode * inode, struct file * file,
-                       struct vm_area_struct * vma);
-#endif
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,9)
-/* New License scheme. */
-#ifdef MODULE_LICENSE
-MODULE_LICENSE("GPL"); /* Close enough.  Keeps kernel from complaining. */
-#endif
-#endif
-
-
-
-/************************************************************************/
-/* Structures / Variables                                               */
-/************************************************************************/
-
-static int      retrieveKernelModulePages(void);
-static unsigned retrievePhyPages(Bit32u *page, int max_pages, void *addr,
-                                 unsigned size);
-
-
-
-static struct file_operations plex86_fops = {
-#if LINUX_VERSION_CODE >= VERSION_CODE(2,4,0)
-  owner:    THIS_MODULE,
-#endif
-  mmap:     plex86_mmap,
-  ioctl:    plex86_ioctl,
-  open:     plex86_open,
-  release:  plex86_release,
-  };
-
-
-#ifdef CONFIG_DEVFS_FS
-#include <linux/devfs_fs_kernel.h>
-devfs_handle_t my_devfs_entry;
-#endif
-
-/* For the /proc/driver/plex86 entry. */
-#if LINUX_VERSION_CODE >= VERSION_CODE(2,4,0) /* XXX - How far back? */
-int plex86_read_procmem(char *, char **, off_t, int);
-#else
-int plex86_read_procmem(char *, char **, off_t, int, int);
-#endif
-
-#if LINUX_VERSION_CODE < VERSION_CODE(2,3,25)
-static struct proc_dir_entry plex86_proc_entry = {
-  0,                  /* dynamic inode */
-  6, "driver/plex86",     /* len, name */
-  S_IFREG | S_IRUGO,  /* mode */
-  1, 0, 0,
-  0,
-  NULL,
-  &plex86_read_procmem,  /* read function */
-  };
-#endif
-
-#if CONFIG_X86_PAE
-#  error "CONFIG_X86_PAE defined for this kernel, but unhandled in plex86"
-#endif
-
-/************************************************************************/
-/* Main kernel module code                                              */
-/************************************************************************/
-
-  int
-init_module(void)
-{
-  int err;
-
-  /* Initialize structures which are not specific to each VM.  These
-   * are things which are set only once upon kernel module initialization.
-   */
-  memset(&kernelModulePages, 0, sizeof(kernelModulePages));
-  memset(&interruptRedirCount, 0, sizeof(interruptRedirCount));
-
-  /* Register the device with the kernel. */
-  err = register_chrdev(plex_major, "plex86", &plex86_fops);
-  if (err < 0) {
-    printk(KERN_WARNING "plex86: can't get major %d\n", plex_major);
-    return(err);
-    }
-  /* If this was a dynamic allocation, save the major for
-   * the release code
-   */
-  if(!plex_major)
-    plex_major = err;
-
-  /* Register the /proc entry. */
-#ifdef CONFIG_PROC_FS
-#if LINUX_VERSION_CODE >= VERSION_CODE(2,3,25)
-  if (!create_proc_info_entry("driver/plex86", 0, NULL, plex86_read_procmem))
-    printk(KERN_ERR "plex86: registering /proc/driver/plex86 failed\n");
-#else
-  proc_register_dynamic(&proc_root, &plex86_proc_entry);
-#endif
-#endif
-
-  /* Register /dev/misc/plex86 with devfs. */
-#ifdef CONFIG_DEVFS_FS
-  my_devfs_entry = devfs_register(NULL, "misc/plex86", 
-                                  DEVFS_FL_DEFAULT, 
-                                  plex_major, 0 /* minor mode*/, 
-                                  S_IFCHR | 0666, &plex86_fops,
-                                  NULL /* "info" */);
-  if (!my_devfs_entry)
-    printk(KERN_ERR "plex86: registering misc/plex86 devfs entry failed\n");
-#endif
-
-  /* Retrieve the monitor physical pages. */
-  if ( !retrieveKernelModulePages() ) {
-    printk(KERN_ERR "plex86: retrieveKernelModulePages returned error\n");
-    err = -EINVAL;
-    goto fail_retrieve_pages;
-    }
-
-  /* Kernel independent code to be run when kernel module is loaded. */
-  if ( !hostModuleInit() ) {
-    printk(KERN_ERR "plex86: genericModuleInit returned error\n");
-    err = -EINVAL;
-    goto fail_cpu_capabilities;
-    }
-
-  /* Success. */
-  EXPORT_NO_SYMBOLS;
-  return(0);
-
-fail_cpu_capabilities:
-fail_retrieve_pages:
-  /* Unregister /proc entry. */
-#ifdef CONFIG_PROC_FS
-#if LINUX_VERSION_CODE >= VERSION_CODE(2,3,25)
-  remove_proc_entry("driver/plex86", NULL);
-#else
-  proc_unregister(&proc_root, plex86_proc_entry.low_ino);
-#endif
-#endif
-
-  /* Unregister device. */
-  unregister_chrdev(plex_major, "plex86");
-  return err;
-}
-
-  void
-cleanup_module(void)
-{
-  /* Unregister device. */
-  unregister_chrdev(plex_major, "plex86");
-
-  /* Unregister /proc entry. */
-#ifdef CONFIG_PROC_FS
-#if LINUX_VERSION_CODE >= VERSION_CODE(2,3,25)
-  remove_proc_entry("driver/plex86", NULL);
-#else
-  proc_unregister(&proc_root, plex86_proc_entry.low_ino);
-#endif
-#endif
-
-#ifdef CONFIG_DEVFS_FS
-  devfs_unregister(my_devfs_entry);
-#endif
-}
-
-
-
-/************************************************************************/
-/* Open / Release a VM                                                  */
-/************************************************************************/
-
-  int
-plex86_open(struct inode *inode, struct file *filp)
-{
-  vm_t *vm;
-#if LINUX_VERSION_CODE < VERSION_CODE(2,4,0)
-  MOD_INC_USE_COUNT;
-#endif
-
-  /* Allocate a VM structure. */
-  if ( (vm = hostOSAllocZeroedMem(sizeof(vm_t))) == NULL )
-    return -ENOMEM;
-  filp->private_data = vm;
-  
-  /* Kernel independent device open code. */
-  hostDeviceOpen(vm);
-
-  return(0);
-}
-
-
-#if LINUX_VERSION_CODE >= VERSION_CODE(2,1,31)
-  int
-#else
-  void
-#endif
-plex86_release(struct inode *inode, struct file *filp)
-{
-  vm_t *vm = (vm_t *)filp->private_data;
-  filp->private_data = NULL;
-
-  /* Free the virtual memory. */
-  hostUnallocVmPages( vm );
-
-  /* Free the VM structure. */
-  memset( vm, 0, sizeof(*vm) );
-  vfree( vm );
-
-#if LINUX_VERSION_CODE < VERSION_CODE(2,4,0)
-  MOD_DEC_USE_COUNT;
-#endif
-
-#if LINUX_VERSION_CODE >= VERSION_CODE(2,1,31)
-  return(0);
-#endif
-}
-
-
-  int
-plex86_ioctl(struct inode *inode, struct file *filp,
-             unsigned int cmd, unsigned long arg)
-{
-  vm_t *vm = (vm_t *)filp->private_data;
-  int ret;
-
-  /* Call non host-specific ioctl() code which calls back to this
-   * module only when it needs host-specific features.
-   */
-  ret = hostIoctlGeneric(vm, inode, filp, cmd, arg);
-
-  /* Convert from plex86 errno codes to host-specific errno codes.  Not
-   * very exciting.
-   */
-  if ( ret < 0 )
-    ret = - hostOSConvertPlex86Errno(- ret);
-  return( ret );
-}
-
-
-  int
-#if LINUX_VERSION_CODE >= VERSION_CODE(2,1,0)
-plex86_mmap(struct file * file, struct vm_area_struct * vma)
-#else
-plex86_mmap(struct inode * inode, struct file * file, struct vm_area_struct * vma)
-#endif
-{
-  vm_t *vm = (vm_t *)file->private_data;
-  UNUSED(vm);
-  return -EINVAL;
-}
-
-
-/************************************************************************/
-/* Status reporting:  /proc code                                        */
-/************************************************************************/
-
-  int
-plex86_read_procmem(char *buf, char **start, off_t offset,
-#if LINUX_VERSION_CODE >= VERSION_CODE(2,4,0)
-                    int len
-#else
-                    int len, int unused
-#endif
-                    )
-{
-  unsigned i;
-  len = 0;
-  len += sprintf(buf, "monitor-->host interrupt reflection counts\n");
-  for (i=0; i<256; i++) {
-    int count;
-    count = atomic_read( &interruptRedirCount[i] );
-    if (count)
-      len += sprintf(buf+len, "  0x%2x:%10u\n", i, count);
-    }
-  return(len);
-}
-
-
-  int
-retrieveKernelModulePages(void)
-{
-  /* 
-   * Retrieve start address and size of this module.
-   *
-   * Note that with old kernels, we cannot access the module info (size),
-   * hence we rely on the fact that Linux lets at least one page of 
-   * virtual address space unused after the end of the module.
-   */
-#ifdef THIS_MODULE
-  Bit32u   driverStartAddr = (Bit32u) THIS_MODULE;
-  unsigned size            = THIS_MODULE->size;
-#else
-  Bit32u   driverStartAddr = (Bit32u) &mod_use_count_;
-  unsigned size            = 0;  /* Actual size determined below */
-#endif
-  Bit32u   driverStartAddrPageAligned = driverStartAddr & ~0xfff;
-
-  int    nPages;
-
-  if (driverStartAddr != driverStartAddrPageAligned) {
-    /* Pretend this kernel module starts at the beginning of the page. */
-    /* If size is known, we have to add the extra offset from the beginning
-     * of the page.
-     */
-    if (size)
-      size += (driverStartAddr & 0xfff);
-    }
-
-  nPages = retrievePhyPages(kernelModulePages.ppi, Plex86MaxKernelModulePages,
-                            (void *) driverStartAddrPageAligned, size);
-  if (nPages == 0) {
-    printk(KERN_ERR "plex86: retrieveKernelModulePages: retrieve returned error.\n");
-    return( 0 ); /* Error. */
-    }
-  printk(KERN_WARNING "plex86: %u monitor pages located\n", nPages);
-
-  kernelModulePages.startOffset            = driverStartAddr;
-  kernelModulePages.startOffsetPageAligned = driverStartAddrPageAligned;
-  kernelModulePages.nPages                 = nPages;
-  return( 1 ); /* OK. */
-}
-
-
-  unsigned
-retrievePhyPages(Bit32u *page, int max_pages, void *addr_v, unsigned size)
-{
-  /*  
-   * Grrr.  There doesn't seem to be an exported mechanism to retrieve
-   * the physical pages underlying a vmalloc()'ed area.  We do it the
-   * hard way ... 
-   */
-  pageEntry_t *host_pgd;
-  Bit32u host_cr3;
-  Bit32u addr; // start_addr;
-  unsigned n_pages;
-  int i;
-
-  addr = (Bit32u) addr_v;
-  if ( addr & 0xfff ) {
-    printk(KERN_ERR "plex86: retrievePhyPages: not page aligned!\n");
-    return 0;
-    }
-
-  if (!addr) {
-    printk(KERN_ERR "plex86: retrievePhyPages: addr NULL!\n");
-    return 0;
-    }
-
-  if (size == 0) {
-    /* Size unknown.  Determine by cycling through page tables until
-     * we find one which is not present.  We will assume that means
-     * the end of the data structure.  Set the number of pages to
-     * cycle through, to one more than the maximum requested.  This
-     * way we'll look through enough pages.
-     */
-    n_pages = max_pages + 1;
-    }
-  else {
-    n_pages = BytesToPages(size);
-    if ( n_pages > max_pages ) {
-      printk(KERN_ERR "plex86: retrievePhyPages: n=%u > max=%u\n",
-         n_pages, max_pages);
-      return 0;
-      }
-    }
-
-  asm volatile ("movl %%cr3, %0" : "=r" (host_cr3));
-  host_pgd = (pageEntry_t *)(phys_to_virt(host_cr3 & ~0xfff));
-
-  for (i = 0; i < n_pages; i++) {
-    Bit32u laddr;
-    unsigned long lpage;
-    pgd_t *pgdPtr; pmd_t *pmdPtr; pte_t *ptePtr;
-    pgd_t  pgdVal; pmd_t  pmdVal; pte_t  pteVal;
-
-    laddr = KERNEL_OFFSET + ((Bit32u) addr);
-
-    lpage = VMALLOC_VMADDR(laddr);
-
-    /* About to traverse the page tables.  We need to lock others
-     * out of them briefly.  Newer Linux versions can do a fine-grained
-     * lock on the page tables themselves.  Older ones have to do
-     * a "big kernel lock".
-     */
-#if LINUX_VERSION_CODE >= VERSION_CODE(2,3,10)
-    spin_lock(&init_mm.page_table_lock);
-#else
-    lock_kernel(); /* Big kernel lock. */
-#endif
-    pgdPtr = pgd_offset(&init_mm, lpage);
-    pmdPtr = pmd_offset(pgdPtr, lpage);
-    ptePtr = pte_offset(pmdPtr, lpage);
-
-    pgdVal = *pgdPtr;
-    pmdVal = *pmdPtr;
-    pteVal = *ptePtr;
-
-#if LINUX_VERSION_CODE >= VERSION_CODE(2,3,10)
-    spin_unlock(&init_mm.page_table_lock);
-#else
-    unlock_kernel(); /* Big kernel unlock. */
-#endif
-
-    if ( !(pgdVal.pgd & 1) ||
-         !(pmdVal.pmd & 1) ||
-         !(pteVal.pte_low & 1) ) {
-      if (size == 0)
-        return i; /* Report number of pages until area ended. */
-      printk(KERN_ERR "plex86: retrievePhyPages: "
-                      "PDE.P==0: i=%u, n=%u laddr=0x%x\n", i, n_pages, laddr);
-      return 0; /* Error, ran into unmapped page in memory range. */
-      }
-
-    /* Abort if our page list is too small. */
-    if (i >= max_pages) {
-      printk(KERN_WARNING "plex86: page list is too small!\n");
-      printk(KERN_WARNING "plex86: n_pages=%u, max_pages=%u\n",
-           n_pages, max_pages);
-      return 0;
-      }
-    /* Get physical page address for this virtual page address. */
-    page[i] = pte_val(pteVal) >> 12;
-    /* Increment to the next virtual page address. */
-    addr += 4096;
-    }
-  return(n_pages);
-}
-
-
-
-/************************************************************************
- * The requisite host-specific functions.  An implementation of each of
- * these functions needs to be offered for each host-XYZ.c file.
- ************************************************************************/
-
-
-  unsigned
-hostOSIdle(void)
-{
-  if (NEED_RESCHED)
-    schedule();
-
-  /* return !current_got_fatal_signal(); */
-  return( ! signal_pending(current) );
-}
-
-  void *
-hostOSAllocZeroedMem(unsigned long size)
-{
-  void *ptr;
-
-  ptr = vmalloc(size);
-  if ( ((Bit32u) ptr) & 0x00000fff )
-    return( 0 ); /* Error. */
-
-  /* Zero pages.  This also demand maps the pages in, which we need
-   * since we'll cycle through all the pages to get the physical
-   * address mappings.
-   */
-  mon_memzero(ptr, size);
-  return( ptr );
-}
-
-  void
-hostOSFreeMem(void *ptr)
-{
-  vfree(ptr);
-}
-
-  void *
-hostOSAllocZeroedPage(void)
-{
-  return( (void *) get_zeroed_page(GFP_KERNEL) );
-}
-
-  void
-hostOSFreePage(void *ptr)
-{
-  free_page( (Bit32u)ptr );
-}
-
-
-  unsigned
-hostOSGetAllocedMemPhyPages(Bit32u *page, int max_pages, void *ptr, unsigned size)
-{
-  return( retrievePhyPages(page, max_pages, ptr, size) );
-}
-
-  Bit32u
-hostOSGetAllocedPagePhyPage(void *ptr)
-{
-  if (!ptr) return 0;
-  /* return MAP_NR(ptr); */
-  return(__pa(ptr) >> PAGE_SHIFT);
-}
-
-  void
-hostOSPrint(char *fmt, ...)
-{
-#warning "Fix hostPrint"
-#if 0
-  va_list args;
-  int ret;
-  unsigned char buffer[256];
-
-  va_start(args, fmt);
-  ret = mon_vsnprintf(buffer, 256, fmt, args);
-  if (ret == -1) {
-    printk(KERN_ERR "plex86: hostPrint: vsnprintf returns error.\n");
-    }
-  else {
-    printk(KERN_WARNING "plex86: %s\n", buffer);
-    }
-#endif
-}
-
-
-  int
-hostOSConvertPlex86Errno(unsigned ret)
-{
-  switch (ret) {
-    case 0: return(0);
-    case Plex86ErrnoEBUSY:  return(EBUSY);
-    case Plex86ErrnoENOMEM: return(ENOMEM);
-    case Plex86ErrnoEFAULT: return(EFAULT);
-    case Plex86ErrnoEINVAL: return(EINVAL);
-    case Plex86ErrnoEACCES: return(EACCES);
-    case Plex86ErrnoEAGAIN: return(EAGAIN);
-    default:
-      printk(KERN_ERR "plex86: ioctlAllocVPhys: case %u\n", ret);
-      return(EINVAL);
-    }
-}
-
-
-  Bit32u
-hostOSKernelOffset(void)
-{
-  return( KERNEL_OFFSET );
-}
-
-  void
-hostOSModuleCountReset(vm_t *vm, void *inode, void *filp)
-{
-#if LINUX_VERSION_CODE < VERSION_CODE(2,4,0)
-  while (MOD_IN_USE) {
-    MOD_DEC_USE_COUNT;
-    }
-    
-  MOD_INC_USE_COUNT; /* bump back to 1 so release can decrement */
-#endif
-}
-
-  unsigned long
-hostOSCopyFromUser(void *to, void *from, unsigned long len)
-{
-  return( copy_from_user(to, from, len) );
-}
-
-  unsigned long
-hostOSCopyToUser(void *to, void *from, unsigned long len)
-{
-  return( copy_to_user(to, from, len) );
-}
-
-  Bit32u
-hostOSGetAndPinUserPage(vm_t *vm, Bit32u userAddr, void **osSpecificPtr,
-                      Bit32u *ppi, Bit32u *kernelAddr)
-{
-  int    ret;
-  struct page **pagePtr;
-  struct page *page;
-
-  pagePtr = (struct page **) osSpecificPtr;
-  ret = get_user_pages(current,
-                       current->mm,
-                       (unsigned long) userAddr,
-                       1, /* 1 page. */
-                       1, /* 'write': intent to write. */
-                       0, /* 'force': ? */
-                       pagePtr,
-                       NULL /* struct vm_area_struct *[] */
-                       );
-  if (ret != 1) {
-    printk(KERN_ERR "plex86: hostGetAndPinUserPages: failed.\n");
-    return(0); /* Error. */
-    }
-
-  page = *pagePtr; /* The returned "struct page *" value. */
-
-  /* Now that we have a list of "struct page *", one for each physical
-   * page of memory of the user space process's requested area, we can
-   * calculate the physical page address by simple pointer arithmetic
-   * based on "mem_map".
-   */
-  *ppi = page - mem_map;
-  if (kernelAddr) {
-    /* Caller wants a kernel address returned which maps to this physical
-     * address.
-     */
-    *kernelAddr = (Bit32u) kmap( page );
-#warning "FIXME: Check return value here."
-#warning "Also, conditionally compile for version and high memory support."
-    }
-  return(1); /* OK. */
-}
-
-  void
-hostOSUnpinUserPage(vm_t *vm, Bit32u userAddr, void *osSpecificPtr,
-                          Bit32u ppi, Bit32u *kernelAddr, unsigned dirty)
-{
-#if 0
-  /* Here is some sample code from Linux 2.4.18, mm/memory.c:__free_pte() */
-	struct page *page = pte_page(pte);
-  if ((!VALID_PAGE(page)) || PageReserved(page))
-    return;
-  if (pte_dirty(pte))
-    set_page_dirty(page);
-  free_page_and_swap_cache(page);
-#endif
-
-	struct page *page;
-
-  page = (struct page *) osSpecificPtr;
-  /* If a kernel address is passed, that means that previously we created
-   * a mapping for this physical page in the kernel address pace.
-   * We should unmap it.  Only really useful for pages allocated from
-   * high memory.
-   */
-  if (kernelAddr)
-    kunmap(page);
-
-  /* If the page was dirtied due to the guest running in the VM, we
-   * need to tell the kernel about that since it is not aware of
-   * the VM page tables.
-   */
-  if (dirty)
-    set_page_dirty(page);
-
-  /* Release/unpin the page. */
-  put_page(page);
-}
-
-  void
-hostOSInstrumentIntRedirCount(unsigned interruptVector)
-{
-  atomic_inc( &interruptRedirCount[interruptVector] );
-}
diff -Nur bochs-2.0.2+20030829.old/plex86/kernel/host-netbsd.c bochs-2.0.2+20030829/plex86/kernel/host-netbsd.c
--- bochs-2.0.2+20030829.old/plex86/kernel/host-netbsd.c	2003-01-01 17:32:04.000000000 +0000
+++ bochs-2.0.2+20030829/plex86/kernel/host-netbsd.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,566 +0,0 @@
-/*
- *  plex86: run multiple x86 operating systems concurrently
- *
- *  Copyright (C) 2000 Frank van der Linden (fvdl@wasabisystems.com)
- *
- *  host-netbsd.c: NetBSD-specific code for kernel module.
- *
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Lesser General Public
- *  License as published by the Free Software Foundation; either
- *  version 2 of the License, or (at your option) any later version.
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- */
-
-
-/* XXXX stuff that conflicts with NetBSD namespace */
-
-#define timer_t __bsd_timer_t
-#define write_eflags __netbsd_write_eflags
-#define read_eflags __netbsd_read_eflags
-
-#include <sys/param.h>
-#include <sys/types.h>
-#include <sys/systm.h>
-#include <sys/proc.h>
-#include <sys/conf.h>
-#include <sys/exec.h>
-#include <sys/lkm.h>
-#include <sys/malloc.h>
-#include <sys/null.h>
-#include <sys/syslog.h>
-#include <sys/queue.h>
-#include <sys/signalvar.h>
-#include <sys/mman.h>
-
-#undef NETBSD_PLEX86_DEBUG
-
-#if __NetBSD_Version__ > 105009900
-#include <uvm/uvm_extern.h>
-#include <uvm/uvm_param.h>
-#else
-#include <vm/vm.h>
-#endif
-
-#undef timer_t
-#undef write_eflags
-#undef read_eflags
-
-#include "plex86.h"
-#define IN_HOST_SPACE
-#include "monitor.h"
-
-int plex86_open(dev_t dev, int oflags, int devtype, struct proc *p);
-int plex86_close(dev_t dev, int cflags, int devtype, struct proc *p);
-paddr_t plex86_mmap(dev_t dev, off_t offset, int length);
-int plex86_ioctl(dev_t dev, u_long cmd, caddr_t data, int flags,
-		 struct proc *p);
-
-static int plex86_handle(struct lkm_table *, int);
-static vm_t *find_vm(struct proc *);
-static void register_vm(vm_t *, struct proc *);
-static void unregister_all(void);
-#if 0
-static void unregister_vm(vm_t *, struct proc *);
-#endif
-
-static unsigned retrieve_phy_pages(Bit32u *, int, void *, unsigned, int);
-
-static struct cdevsw plex86dev = {
-	plex86_open, plex86_close, 
-	(dev_type_read((*))) enodev, (dev_type_write((*))) enodev,
-	plex86_ioctl, (dev_type_stop((*))) enodev, 0,
-	seltrue, plex86_mmap, 0
-};
-
-static struct plex86_softc {
-	int sc_open;
-} plex86sc;
-
-MOD_DEV("plex86", LM_DT_CHAR, -1, &plex86dev)
-
-monitor_pages_t monitor_pages;
-
-/*
- * Hash table stuff to maintain proc <-> vm mapping.
- * 23 entries should be plenty.. unless someone plans to run more than
- * 23 guest OSs..
- *
- * Note that a process can only open the device once with this scheme.
- */
-
-LIST_HEAD(plex86_hashhead, plex86_vmentry);
-
-struct plex86_vmentry {
-	pid_t	vm_pid;
-	vm_t	*vm_vm;
-	LIST_ENTRY(plex86_vmentry) vm_entry;
-};
-
-struct plex86_hashhead *plex86_hashtbl;
-u_long plex86_hashmask;
-
-#define PLEX86_VMHASHSIZE	23
-#define PLEX86_VMHASH(p)	((u_long)((p)->p_pid) & plex86_hashmask)
-
-int
-plex86_lkmentry(struct lkm_table *lkmtp, int cmd, int ver)
-{
-	DISPATCH(lkmtp, cmd, ver, plex86_handle, plex86_handle, plex86_handle)
-}
-
-static int 
-plex86_handle(struct lkm_table *lkmtp, int cmd)
-{
-	int error = 0;
-	
-	switch (cmd) {
-	case LKM_E_LOAD:
-		if (lkmexists(lkmtp)) 
-			return EEXIST;
-		monitor_pages.startOffset = lkmtp->area;
-    monitor_pages.startOffsetPageAligned =
-        monitor_pages.startOffset & 0xfffff000;
-		monitor_pages.n_pages = lkmtp->size / PAGE_SIZE;
-		if (retrieve_phy_pages(monitor_pages.page,
-		    PLEX86_MAX_MONITOR_PAGES, (void *)lkmtp->area,
-		    lkmtp->size, 0) == 0) {
-			log(LOG_WARNING, "plex86: could not store physical "
-			    "addresses for monitor pages\n");
-			return EIO;
-		}
-#if __NetBSD_Version__ > 105009900
-		plex86_hashtbl = hashinit(PLEX86_VMHASHSIZE, HASH_LIST,
-		    M_DEVBUF, M_WAITOK, &plex86_hashmask);
-#else
-		plex86_hashtbl = hashinit(PLEX86_VMHASHSIZE, M_DEVBUF,
-		    M_WAITOK, &plex86_hashmask);
-#endif
-		if (!hostModuleInit()) {
-			log(LOG_WARNING, "hostModuleInit error\n");
-			error = EINVAL;
-		}
-
-		break;
-		
-	case LKM_E_UNLOAD:
-		if (plex86sc.sc_open != 0)
-			return EBUSY;
-		free(plex86_hashtbl, M_DEVBUF);
-		break;
-		
-	case LKM_E_STAT:
-		break;
-
-	default:
-		error = EIO;
-		break;
-	}
-	return error;
-}
-
-int
-plex86_open(dev_t dev, int oflags, int devtype, struct proc *p)
-{
-	vm_t *vm;
-
-	if (suser(p->p_ucred, &p->p_acflag) != 0)
-		return EPERM;
-
-	vm = find_vm(p);
-	if (vm == NULL) {
-		vm = malloc(sizeof (vm_t), M_DEVBUF, M_WAITOK);
-		if (vm == NULL)
-			return EIO;
-                memset(vm, 0, sizeof(vm_t));
-		register_vm(vm, p);
-		plex86sc.sc_open++;
-	} else
-		return EBUSY;
-
-  /* Kernel independent device open code. */
-  hostDeviceOpenInit(vm);
-
-#ifdef NETBSD_PLEX86_DEBUG
-	printf("plex86: pid %u opened device, vm %p\n", p->p_pid, vm);
-#endif
-	return 0;
-}
-
-int
-plex86_close(dev_t dev, int cflags, int devtype, struct proc *p)
-{
-	unregister_all();
-	plex86sc.sc_open = 0;
-#ifdef NETBSD_PLEX86_DEBUG
-	printf("plex86: pid %u closed device\n", p->p_pid);
-#endif
-	return 0;
-}
-
-paddr_t
-plex86_mmap(dev_t dev, off_t offset, int prot)
-{
-	struct proc *p = curproc;
-	vm_t *vm;
-	int page;
-	off_t endguestoff;
-
-	vm = find_vm(p);
-	if (vm == NULL)
-		return ENXIO;
-#if 1
-#warning "kludge to mmap message buffer"
-	endguestoff = (off_t)(vm->pages.guest_n_megs * 1024 * 1024);
-	if (offset >= endguestoff && prot == PROT_READ) {
-		page = (offset - endguestoff) / PAGE_SIZE;
-		return vm->pages.log_buffer[page];
-	}
-#endif
-
-	page = offset / PAGE_SIZE;
-	if (page < 0 || page > vm->pages.guest_n_pages) {
-		log(LOG_WARNING, "plex86: mmap: offset %lx out of range\n",
-		    (unsigned long)offset);
-		return -1;
-	}
-
-	return vm->pages.guest[page];
-}
-
-int
-plex86_ioctl(dev_t dev, u_long cmd, caddr_t data, int flags,
-	     struct proc *p)
-{
-	int error;
-	vm_t *vm;
-
-	vm = find_vm(p);
-	if (vm == NULL)
-		return EINVAL;
-
-	switch (cmd) {
-	case PLEX86_ALLOCVPHYS:
-	{
-		unsigned long arg = *((unsigned long*)data);
-		guest_cpu_t guest_cpu;
-
-		if (vm->mon_state != MON_STATE_UNINITIALIZED ||
-		    vm->pages.guest_n_megs != 0)
-			return EBUSY;
-		printf("plex86_ioctl: ALLOCVPHYS: requested size %lu\n",
-		    arg);
-		if (arg > PLEX86_MAX_PHY_MEGS || arg < 4 || (arg & ~0x3) != arg)
-			return EINVAL;
-
-		/* Allocate memory */
-		error = allocVMPages(vm, arg);
-		if (error != 0) {
-			log(LOG_WARNING, "plex86: allocVMPages failed (%d)\n",
-			    error);
-			return ENOMEM;
-		}
-
-		if (init_guest_phy_mem(vm) != 0) {
-			log(LOG_ERR, "plex86: init_guest_phy_mem failed\n");
-			unallocVMPages(vm);
-			return EFAULT;
-		}
-
-		getCpuResetValues(&guest_cpu);
-		log(LOG_WARNING, "plex86: cpu.cr0 = 0x%x\n", guest_cpu.cr0);
-		if (!init_monitor(vm, 0, 0, &guest_cpu) ||
-		    !setGuestCPU(vm, 0, &guest_cpu) ||
-		    !mapMonitor(vm, guest_cpu.eflags, 0)) {
-			log(LOG_ERR, "plex86: init_monitor failed\n");
-			unallocVMPages(vm);
-			return EFAULT;
-		}
-		break;
-	}
-
-	case PLEX86_TEARDOWN:
-		unallocVMPages(vm);
-		break;
-
-	case PLEX86_ALLOCINT:
-		return EINVAL;
-	case PLEX86_RELEASEINT:
-		return EINVAL;
-	case PLEX86_PRESCANDEPTH:
-	{
-		unsigned long arg = *(unsigned long *)data;
-
-		if ((arg < PrescanDepthMin) || (arg > PrescanDepthMax)) {
-			log(LOG_WARNING, "plex86: Requested prescan depth %lu"
-			    " out of range [%u..%u]\n", arg, PrescanDepthMin,
-			    PrescanDepthMax);
-			return EINVAL;
-		}
-		vm->prescanDepth = (unsigned)arg;
-		break;
-	}
-	case PLEX86_SETINTR:
-		ioctlSetIntr(vm, *(unsigned long *)data);
-		break;
-	case PLEX86_SET_A20:
-	{
-		unsigned long arg = *(unsigned long *)data;
-		if (!ioctlSetA20E(vm, arg))
-			return EINVAL;
-		break;
-	}
-	case PLEX86_MESSAGEQ:
-	{
-		vm_messages_t msg;
-
-		if (vm->mon_state != MON_STATE_RUNNABLE)
-			return EINVAL;
-
-		error = copyin(*(void **)data, &msg.header, sizeof msg.header);
-		if (error != 0)
-			return error;
-
-		if ((msg.header.msg_len + sizeof(msg.header)) > sizeof(msg))
-			return EINVAL;
-
-		if (msg.header.msg_len != 0) {
-			error = copyin(&((vm_messages_t *)*(void **)data)->msg,
-			    &msg.msg, msg.header.msg_len);
-			if (error != 0)
-				return error;
-		}
-
-#warning "deal with LDT %gs and %fs that the NetBSD kernel uses"
-		/* XXXX */
-		__asm("movl $0, %eax");
-		__asm("movl %eax, %gs");
-		__asm("movl %eax, %fs");
-
-		if (ioctlMessageQ(vm, &msg)) {
-			log(LOG_WARNING, "plex86: ioctlMessageQ failed\n");
-			return EINVAL;
-		}
-
-		error = copyout(&msg, *(void **)data,
-		    sizeof (msg.header) + msg.header.msg_len);
-		return error;
-	}
-	case PLEX86_RESET:
-		break;
-	case PLEX86_PHYMEM_MOD:
-		break;
-	case PLEX86_FORCE_INT:
-		if (vm->mon_state != MON_STATE_RUNNABLE)
-			return -EINVAL;
-		vm->dbg_force_int = 0x100 | (unsigned)data;
-		break;
-	case PLEX86_PRESCANRING3:
-	{
-		unsigned long arg = *(unsigned long *)data;
-		if (arg > PrescanRing3On) {
-			log(LOG_WARNING,
-			    "plex86: Requested PrescanRing3 val(%lu) OOB\n",
-			    arg);
-			return EINVAL;
-		}
-		vm->prescanRing3 = arg;
-		break;
-	}
-	case PLEX86_GENERIC:
-		return 0;
-
-	default:
-		log(LOG_WARNING, "plex86: unknown ioctl %lx\n", cmd);
-		return EINVAL;
-	}
-	return 0;
-}
-
-static void
-register_vm(vm_t *vm, struct proc *p)
-{
-	struct plex86_hashhead *php;
-	struct plex86_vmentry *vhp;
-
-	php = &plex86_hashtbl[PLEX86_VMHASH(p)];
-#ifdef DIAGNOSTIC
-	for (vhp = php->lh_first; vhp != NULL; vhp = vhp->vm_entry.le_next) {
-		if (vhp->vm_pid == p_pid)
-			panic("plex86: vm already registered, pid %u\n",
-			    p->pid);
-	}
-#endif
-	vhp = malloc(sizeof (struct plex86_vmentry), M_DEVBUF, M_WAITOK);
-	vhp->vm_pid = p->p_pid;
-	vhp->vm_vm = vm;
-	LIST_INSERT_HEAD(php, vhp, vm_entry);
-}
-
-#if 0
-static void
-unregister_vm(vm_t *vm, struct proc *p)
-{
-	struct plex86_hashhead *php;
-	struct plex86_vmentry *vhp;
-
-	php = &plex86_hashtbl[PLEX86_VMHASH(p)];
-	for (vhp = php->lh_first; vhp != NULL; vhp = vhp->vm_entry.le_next) {
-		if (vhp->vm_pid == p->p_pid) {
-			LIST_REMOVE(vhp, vm_entry);
-			free(vhp->vm_vm, M_DEVBUF);
-			free(vhp, M_DEVBUF);
-			break;
-		}
-	}
-}
-#endif
-
-static void
-unregister_all(void)
-{
-	int i;
-	struct plex86_hashhead *php;
-	struct plex86_vmentry *vhp;
-
-	for (i = 0; i < PLEX86_VMHASHSIZE; i++) {
-		php = &plex86_hashtbl[i];
-		for (vhp = php->lh_first; vhp != NULL;
-		    vhp = vhp->vm_entry.le_next) {
-#ifdef NETBSD_PLEX86_DEBUG
-			printf("plex86: unregister vm %p, pid %u\n",
-			    vhp->vm_vm, vhp->vm_pid);
-#endif
-			LIST_REMOVE(vhp, vm_entry);
-			free(vhp->vm_vm, M_DEVBUF);
-			free(vhp, M_DEVBUF);
-		}
-	}
-}
-
-static vm_t *
-find_vm(struct proc *p)
-{
-	struct plex86_hashhead *php;
-	struct plex86_vmentry *vhp;
-
-	php = &plex86_hashtbl[PLEX86_VMHASH(p)];
-	for (vhp = php->lh_first; vhp != NULL; vhp = vhp->vm_entry.le_next) {
-		if (vhp->vm_pid == p->p_pid)
-			return vhp->vm_vm;
-	}
-
-	return NULL;
-}
-
-static unsigned
-retrieve_phy_pages(Bit32u *page, int max_pages, void *addr_v, unsigned size,
-		   int aligned)
-{
-	Bit32u start_addr;
-	unsigned n_pages, i;
-
-	if (!aligned)
-		start_addr = (Bit32u)addr_v & ~(PAGE_SIZE-1);
-	else {
-		start_addr = (Bit32u)addr_v;
-		if (start_addr & (PAGE_SIZE -1)) {
-			log(LOG_WARNING, "plex86: retrieve_phy_pages: address "
-			    "%p not aligned\n", addr_v);
-			return 0;
-		}
-	}
-
-	n_pages = (size + PAGE_SIZE - 1)  / PAGE_SIZE;
-	if (n_pages > max_pages) {
-		log(LOG_WARNING, "plex86: retrieve_phy_pages: page list "
-		    "too small\n");
-		return 0;
-	}
-
-	for (i = 0; i < n_pages; i++) {
-		page[i] = vtophys((vaddr_t)start_addr) / PAGE_SIZE;
-		start_addr += PAGE_SIZE;
-	}
-
-	return n_pages;
-}
-
-unsigned
-host_idle(void)
-{
-	if (want_resched)
-		yield();
-	return (CURSIG(curproc) == 0);
-}
-
-void *
-host_alloc(unsigned long size)
-{
-	/*
-	 * XXX - it wants this page-aligned apparently.
-	 */
-	if (size <= (PAGE_SIZE / 2))
-		size = PAGE_SIZE;
-	return malloc(size, M_DEVBUF, M_WAITOK);
-}
-
-void
-host_free(void *ptr)
-{
-	free(ptr, M_DEVBUF);
-}
-
-unsigned
-host_map(Bit32u *page, int max_pages, void *ptr, unsigned size)
-{
-	return retrieve_phy_pages(page, max_pages, ptr, size, 1);
-}
-
-void *
-host_alloc_page(void)
-{
-	return malloc(PAGE_SIZE, M_DEVBUF, M_WAITOK);
-}
-
-void
-host_free_page(void *ptr)
-{
-	return free(ptr, M_DEVBUF);
-}
-
-Bit32u
-host_map_page(void *ptr)
-{
-	Bit32u u;
-
-	if (ptr == NULL)
-		return 0;
-	u = vtophys(ptr) / PAGE_SIZE;
-	/* printf("host_map_page(%p) -> %x\n", ptr, u); */
-	return u;
-}
-
-void
-hostprint(char *fmt, ...)
-{
-	va_list args;
-	int ret;
-	unsigned char buffer[256];
-
-	va_start(args, fmt);
-	ret = mon_vsnprintf(buffer, 256, fmt, args);
-	if (ret == -1)
-		log(LOG_WARNING,
-		    "plex86: hostprint: vsnprintf returns error.\n");
-	else
-		log(LOG_WARNING, "plex86: %s\n", buffer);
-}
diff -Nur bochs-2.0.2+20030829.old/plex86/kernel/host-null.c bochs-2.0.2+20030829/plex86/kernel/host-null.c
--- bochs-2.0.2+20030829.old/plex86/kernel/host-null.c	2003-01-10 04:27:51.000000000 +0000
+++ bochs-2.0.2+20030829/plex86/kernel/host-null.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,161 +0,0 @@
-/*
- *  plex86: run multiple x86 operating systems concurrently
- *  Copyright (C) 1999-2003 Kevin P. Lawton
- *
- *  host-null.c: host OS specific stubs.  These provide a reference for
- *    ports of plex86 to various host OSes.
- *
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Lesser General Public
- *  License as published by the Free Software Foundation; either
- *  version 2 of the License, or (at your option) any later version.
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- */
-
-#include "plex86.h"
-#define IN_HOST_SPACE
-#include "monitor.h"
-
-/* Note: for comments on what various functions are expected to do, as
- *   well as a reference implemntation, read the 'host-linux.c' file.
- *   It's likely the most up-to-date.
- */
-
-
-/* OS specific includes here. */
-
-
-/* Some declarations for the entry points etc here. */
-
-
-
-
-kernelModulePages_t kernelModulePages;
-
-#define NULL 0
-
-  int
-main(int argc, char *argv[])
-{
-  vm_t *vm = NULL;
-
-  hostModuleInit();
-  hostDeviceOpen(vm);
-  hostIoctlGeneric(vm, NULL, NULL, 0, 0);
-  return(0);
-}
-
-  void
-hostOSReservePhyPages(vm_t *vm, Bit32u *hostPhyPages, unsigned nPages)
-{
-}
-
-  void
-hostOSUnreservePhyPages(vm_t *vm, Bit32u *hostPhyPages, unsigned nPages)
-{
-}
-
-
-
-  unsigned
-hostOSIdle(void)
-{
-  return 0;
-}
-
-  void *
-hostOSAllocZeroedMem(unsigned long size)
-{
-  return 0;
-}
-
-  void
-hostOSFreeMem(void *ptr)
-{
-}
-
-  void *
-hostOSAllocZeroedPage(void)
-{
-  return 0;
-}
-
-  void
-hostOSFreePage(void *ptr)
-{
-}
-
-
-  unsigned
-hostOSGetAllocedMemPhyPages(Bit32u *page, int max_pages, void *ptr, unsigned size)
-{
-  return 0;
-}
-
-  Bit32u
-hostOSGetAllocedPagePhyPage(void *ptr)
-{
-  return 0;
-}
-
-  void
-hostOSPrint(char *fmt, ...)
-{
-}
-
-
-  int
-hostOSConvertPlex86Errno(unsigned ret)
-{
-  return 0;
-}
-
-
-  Bit32u
-hostOSKernelOffset(void)
-{
-  return 0;
-}
-
-  void
-hostOSModuleCountReset(vm_t *vm, void *inode, void *filp)
-{
-}
-
-  unsigned long
-hostOSCopyFromUser(void *to, void *from, unsigned long len)
-{
-  return 0;
-}
-
-  unsigned long
-hostOSCopyToUser(void *to, void *from, unsigned long len)
-{
-  return 0;
-}
-
-  Bit32u
-hostOSGetAndPinUserPage(vm_t *vm, Bit32u userAddr, void **osSpecificPtr,
-                      Bit32u *ppi, Bit32u *kernelAddr)
-{
-  return 0;
-}
-
-  void
-hostOSUnpinUserPage(vm_t *vm, Bit32u userAddr, void *osSpecificPtr,
-                          Bit32u ppi, Bit32u *kernelAddr, unsigned dirty)
-{
-}
-
-  void
-hostOSInstrumentIntRedirCount(unsigned interruptVector)
-{
-}
diff -Nur bochs-2.0.2+20030829.old/plex86/kernel/include/descriptor2.h bochs-2.0.2+20030829/plex86/kernel/include/descriptor2.h
--- bochs-2.0.2+20030829.old/plex86/kernel/include/descriptor2.h	2003-01-01 17:32:05.000000000 +0000
+++ bochs-2.0.2+20030829/plex86/kernel/include/descriptor2.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,66 +0,0 @@
-/*
- *  plex86: run multiple x86 operating systems concurrently
- *  Copyright (C) 1999-2003 Kevin P. Lawton
- *
- *  descriptor2.h: defines for descriptors and selectors
- *
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Lesser General Public
- *  License as published by the Free Software Foundation; either
- *  version 2 of the License, or (at your option) any later version.
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- */
-
-
-#ifndef __DESCRIPTOR2_H__
-#define __DESCRIPTOR2_H__
-
-
-typedef struct 
-{
-    Bit16u   offset_low;
-    selector_t selector;
-  unsigned count:5;
-    unsigned RESERVED:3;
-    unsigned type:5;
-    unsigned dpl:2;
-    unsigned p:1;
-    Bit16u   offset_high;
-} __attribute__ ((packed)) gate_t;
-
-
-#define SET_INT_GATE(d, S,O,P,DPL, D) {\
-    d.selector = (S);\
-    d.offset_high = (O) >> 16;\
-    d.offset_low = (O) & 0xffff;\
-    d.RESERVED = 0;\
-    d.type = ((D)<<3) | 0x6;\
-    d.dpl = (DPL);\
-    d.p = (P);\
-}
-
-#define SET_TRAP_GATE(d, S,O,P,DPL, D) {\
-    d.selector = (S);\
-    d.offset_high = (O) >> 16;\
-    d.offset_low = (O) & 0xffff;\
-    d.RESERVED = 0;\
-    d.type = ((D)<<3) | 0x7;\
-    d.dpl = (DPL);\
-    d.p = (P);\
-}
-
-typedef struct 
-{
-    Bit32u offset;
-    Bit16u selector;
-} __attribute ((packed)) far_jmp_info_t;
-
-#endif  /* __DESCRIPTOR2_H__ */
diff -Nur bochs-2.0.2+20030829.old/plex86/kernel/include/eflags.h bochs-2.0.2+20030829/plex86/kernel/include/eflags.h
--- bochs-2.0.2+20030829.old/plex86/kernel/include/eflags.h	2003-01-01 17:32:05.000000000 +0000
+++ bochs-2.0.2+20030829/plex86/kernel/include/eflags.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,78 +0,0 @@
-/*
- *  plex86: run multiple x86 operating systems concurrently
- *  Copyright (C) 1999-2003 Kevin P. Lawton
- *
- *  eflags.h: Bitfields of EFLAGS registers
- *
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Lesser General Public
- *  License as published by the Free Software Foundation; either
- *  version 2 of the License, or (at your option) any later version.
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- */
-
-#ifndef __EFLAGS_H__
-#define __EFLAGS_H__
-
-/*
- * the eflags field looks like this:
- * bit:  0  1 2  3 4  5 6  7  8  9  A  B  C/D  E  F 10 11 12 13  14  15 16
- * flg:  CF 1 PF 0 AF 0 ZF SF TF IF DF OF IOPL NT 0 RF VM AC VIF VIP ID 0
- */
-
-#define FLG_CF    (1<<0)
-#define FLG_PF    (1<<2)
-#define FLG_AF    (1<<4)
-#define FLG_ZF    (1<<6)
-#define FLG_SF    (1<<7)
-#define FLG_TF    (1<<8)
-#define FLG_IF    (1<<9)
-#define FLG_DF    (1<<10)
-#define FLG_OF    (1<<11)
-#define FLG_IOPL  (3<<12)
-#define FLG_NT    (1<<14)
-#define FLG_RF    (1<<16)
-#define FLG_VM    (1<<17)
-#define FLG_AC    (1<<18)
-#define FLG_VIF   (1<<19)
-#define FLG_VIP   (1<<20)
-#define FLG_ID    (1<<21)
-
-
-typedef union {
-  struct {
-    Bit8u cf:1;
-    Bit8u R1:1;
-    Bit8u pf:1;
-    Bit8u R3:1;
-    Bit8u af:1;
-    Bit8u R5:1;
-    Bit8u zf:1;
-    Bit8u sf:1;
-    Bit8u tf:1;
-    Bit8u if_:1;
-    Bit8u df:1;
-    Bit8u of:1;
-    Bit8u iopl:2;
-    Bit8u nt:1;
-    Bit8u R15:1;
-    Bit8u rf:1;
-    Bit8u vm:1;
-    Bit8u ac:1;
-    Bit8u vif:1;
-    Bit8u vip:1;
-    Bit8u id:1;
-    Bit16u R31_22:10;
-    } __attribute__ ((packed)) fields;
-  Bit32u raw;
-  } __attribute__ ((packed)) eflags_t;
-
-#endif  /* __EFLAGS_H__ */
diff -Nur bochs-2.0.2+20030829.old/plex86/kernel/include/guest_context.h bochs-2.0.2+20030829/plex86/kernel/include/guest_context.h
--- bochs-2.0.2+20030829.old/plex86/kernel/include/guest_context.h	2003-01-01 17:32:05.000000000 +0000
+++ bochs-2.0.2+20030829/plex86/kernel/include/guest_context.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,59 +0,0 @@
-/*
- *  plex86: run multiple x86 operating systems concurrently
- *  Copyright (C) 1999-2003 Kevin P. Lawton
- *
- *  guest_context.h: monitor stack frame after exception/interrupt
- *
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Lesser General Public
- *  License as published by the Free Software Foundation; either
- *  version 2 of the License, or (at your option) any later version.
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- */
-
-#ifndef __GUEST_CONTEXT_H__
-#define __GUEST_CONTEXT_H__
-
-#include "eflags.h"
-
-/* This is the guest context (from ring3) pushed on the monitor stack (ring0)
- * during an exception/interrupt.  Part is pushed automatically by the
- * CPU, part by the interrupt handling code.
- *
- * Values are pushed starting with the end of this structure, towards
- * the beginning, since stack pushes descend in address.
- */
-typedef struct {
-  Bit32u  gs;
-  Bit32u  fs;
-  Bit32u  ds;
-  Bit32u  es;
- 
-  Bit32u  edi;
-  Bit32u  esi;
-  Bit32u  ebp;
-  Bit32u  dummy_esp;
-  Bit32u  ebx;
-  Bit32u  edx;
-  Bit32u  ecx;
-  Bit32u  eax;
- 
-  Bit32u  vector;
-  Bit32u  error;
- 
-  Bit32u  eip;
-  Bit32u  cs;
-  eflags_t  eflags;
-  Bit32u  esp;
-  Bit32u  ss;
-  } guest_context_t;
-
-#endif  /* __GUEST_CONTEXT_H__ */
diff -Nur bochs-2.0.2+20030829.old/plex86/kernel/include/monitor.h bochs-2.0.2+20030829/plex86/kernel/include/monitor.h
--- bochs-2.0.2+20030829.old/plex86/kernel/include/monitor.h	2003-01-10 04:27:51.000000000 +0000
+++ bochs-2.0.2+20030829/plex86/kernel/include/monitor.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,709 +0,0 @@
-/*
- *  plex86: run multiple x86 operating systems concurrently
- *  Copyright (C) 1999-2003 Kevin P. Lawton
- *
- *  monitor.h: main VM monitor defines
- *
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Lesser General Public
- *  License as published by the Free Software Foundation; either
- *  version 2 of the License, or (at your option) any later version.
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- */
-
-#ifndef __MONITOR_H__
-#define __MONITOR_H__
-
-#if defined(__NetBSD__) || defined(__FreeBSD__)
-#include <machine/stdarg.h>
-#else
-#include <stdarg.h>
-#endif
-
-
-#include "descriptor.h"
-#include "descriptor2.h"
-#include "tss.h"
-#include "paging.h"
-#include "eflags.h"
-#include "guest_context.h"
-
-#ifndef UNUSED
-#  define UNUSED(x) ((void)(x))
-#endif
-
-
-/* Method1: push event info (CPU pushes error code before) */
-typedef struct 
-{
-  Bit8u  pushl;    /* Always 0x68 == pushl            */
-  Bit32u vector;   /* Interrupt vector number         */
-  Bit8u  jmp;      /* Always 0xe9 == jmp              */
-  Bit32u reloc;    /* Relative offset of destination  */
-} __attribute__ ((packed)) idt_method1_t;
-
-/* Method2: push a dummy error first, then event info */
-typedef struct 
-{
-  Bit8u  pushla;   /* Always 0x68 == pushl            */
-  Bit32u dummy;    /* Dummy error code                */
-  Bit8u  pushlb;   /* Always 0x68 == pushl            */
-  Bit32u vector;   /* Interrupt vector number         */
-  Bit8u  jmp;      /* Always 0xe9 == jmp              */
-  Bit32u reloc;    /* Relative offset of destination  */
-} __attribute__ ((packed)) idt_method2_t;
-
-typedef union 
-{
-  idt_method1_t m1;
-  idt_method2_t m2;
-} idt_stub_t;
-
-
-/* Nexus fields.  This C structure maps to identical assembly */
-/* fields in nexus.S.  Make sure to update both!  These fields */
-/* are accessible to the nexus code during the transition from */
-/* host<->guest and are stored in a single page. */
-
-typedef struct {
-  /* guest pointer to vm_t structure. */
-  void          *vm;
-
-  /* These fields are only used by the transition code. */
-  /* They hold all info necessary to switch back to the host. */
-  gdt_info_t     host_gdt_info;
-  gdt_info_t     host_idt_info;
-  far_jmp_info_t host_jmp_info;
-  far_jmp_info_t host_stack_info;
-  Bit16u         host_ldt_sel;
-  Bit16u         host_tss_sel;
-  Bit32u         host_cr0;
-  Bit32u         host_cr2;
-  Bit32u         host_cr3;
-  Bit32u         host_cr4;
-
-  /* These fields are filled by the host-side code, and used  */
-  /* by the transition code.  They contain all info necessary */
-  /* to switch to the monitor/guest address space. */
-  /* This info changes whenever the monitor migrates. */
-  gdt_info_t     mon_gdt_info;
-  gdt_info_t     mon_idt_info;
-  far_jmp_info_t mon_jmp_info;
-  far_jmp_info_t mon_stack_info;
-  Bit16u         mon_ldt_sel;
-  Bit16u         mon_tss_sel;
-  Bit32u         mon_base;
-  Bit32u         mon_cr0;
-  Bit32u         mon_cr3;
-  Bit32u         mon_cr4;
-  Bit32u         mon_eflags;
-
-  /* These fields contain info used by the transition code to */
-  /* create the temporary identity mapping.  They never change. */
-  pageEntry_t    transition_pde;
-  pageEntry_t   *transition_pde_p_host;
-  pageEntry_t   *transition_pde_p_mon;
-  Bit32u         transition_laddr;
-} __attribute__ ((packed)) nexus_t;
-
-
-/* For reference, the following describes where bits from the guest */
-/* eflags register are stored/managed. */
-/* */
-/* Key: */
-/*  g: Flag value as requested by guest */
-/*  V: Virtualized flag value, as loaded in eflags when guest is executing */
-/*  ?: Unhandled yet, request of set bit causes panic for now */
-/* */
-/*   === ======= ====== ======= ======= ======= */
-/*  |I|V|V|A|V|R|0|N|IO|O|D|I|T|S|Z|0|A|0|P|1|C| flag */
-/*  |D|I|I|C|M|F| |T|PL|F|F|F|F|F|F| |F| |F| |F| */
-/*  | |P|F| | | | | |  | | | | | | | | | | | | | */
-/*  |g|?|?|g|V|g|g|g|VV|g|g|V|g|g|g|g|g|g|g|g|g| context->eflags */
-/*  | |?|?| |g| | | |gg| | |g| | | | | | | | | | veflags */
-
-/* #define VirtualizedEflags 0x001a3200 */
-#define VirtualizedEflags 0x001a3300
-
-
-/* I define the 'nexus' as the set of data structures which */
-/* must exist in the current linear guest address space.  The */
-/* host linear address space is not available while the current */
-/* guest code is running, since we are using a completely */
-/* different set of page mappings for the guest.  However, */
-/* at some point an exception/interrupt will occur.  The */
-/* interrupt mechanisms require that several structures exist in */
-/* the current linear address space in order to service such */
-/* an event.  These data structures make up part of our VM, */
-/* a thin layer which exists in the guest.  Following is a */
-/* list of what data structures compose this 'nexus': */
-/* */
-/*     - IDT (max  2048 bytes) */
-/*     - GDT (max 65536 bytes) */
-/*     - LDT (max 65536 bytes) */
-/*     - TSS (max  8328 = 104 + 32 int redir + 8192 I/O permissions) */
-/*     - kernel stack page */
-/*     - transition code (host <--> guest) */
-/*     - interrupt handler stubs */
-/*     - Page Tables; PDE & PTE pages. */
-
-/*
- * Sizes of various nexus data structures used by the monitor
- */
-
-#define PLEX86_MAX_PHY_MEGS 32
-#define PAGESIZE 4096
-
-#define IDT_STUB_SIZE 15
-#define BytesToPages(b) ( ((b)+4095) >> 12 )
-
-#define MON_IDT_SIZE       (8*256)
-#define MON_GDT_SIZE       (8*512)
-#define MON_LDT_SIZE       (8*1)
-#define MON_IDT_STUBS_SIZE (IDT_STUB_SIZE*256)
-#define MON_TSS_SIZE       (104)
-
-#define MON_IDT_PAGES       BytesToPages(MON_IDT_SIZE)
-#define MON_GDT_PAGES       BytesToPages(MON_GDT_SIZE)
-#define MON_LDT_PAGES       BytesToPages(MON_LDT_SIZE)
-#define MON_IDT_STUBS_PAGES BytesToPages(MON_IDT_STUBS_SIZE)
-#define MON_TSS_PAGES       BytesToPages(MON_TSS_SIZE)
-
-#define MAX_MON_GUEST_PAGES    (PLEX86_MAX_PHY_MEGS * 256)
-/* +++ MON_PAGE_TABLES is kind of random */
-#define MON_PAGE_TABLES    (10*((PLEX86_MAX_PHY_MEGS+3) >> 2))
-
-#define MAX_VM_STRUCT_PAGES (68)
-
-#define LOG_BUFF_PAGES 1
-#define LOG_BUFF_SIZE  ((LOG_BUFF_PAGES)*4096)
-
-/*
- *  Pages allocated for the VM by the host kernel driver.
- *  N Megs of physical memory are allocated, per the user's
- *  request, for the guest OS/application code.
- *  Additionally, some other overhead pages are allocated
- *  for structures such as the page directory, page tables,
- *  and other virtualized facilities.
- */
-
-typedef struct {
-  /* requested size of the guest[] array in megs and pages */
-  unsigned guest_n_megs;
-  unsigned guest_n_pages;
-  unsigned guest_n_bytes;
-
-  /* pages comprising the vm_t struct itself. */
-  Bit32u vm[MAX_VM_STRUCT_PAGES];
-
-  /* for the monitor's page directory */
-  Bit32u page_dir;
-
-  /* for the monitor's page table */
-  Bit32u page_tbl[MON_PAGE_TABLES];
-
-  /* Map of the linear addresses of page tables currently */
-  /* mapped into the monitor space. */
-  Bit32u page_tbl_laddr_map;
-
-  /* for the extra page table that maps our nexus code and structures */
-  Bit32u nexus_page_tbl;
-
-  /* For the CPU state passed between user and kernel/monitor space. */
-  Bit32u guest_cpu;
-  void  *guest_cpu_hostOSPtr;
-
-  /* We need a Page Table for identity mapping the transition code */
-  /* between host and monitor spaces. */
-  Bit32u transition_PT;
-
-  Bit32u log_buffer[LOG_BUFF_PAGES];
-  void  *log_buffer_hostOSPtr[LOG_BUFF_PAGES];
-
-  /* Physical addresses of host pages which comprise the actual */
-  /* monitor structures.  These will be mapped into the current */
-  /* guest task's linear address space as well. */
-  Bit32u nexus;
-  Bit32u idt[MON_IDT_PAGES];
-  Bit32u gdt[MON_GDT_PAGES];
-  Bit32u ldt[MON_LDT_PAGES];
-  Bit32u tss[MON_TSS_PAGES];
-  Bit32u idt_stubs[MON_IDT_STUBS_PAGES];
-  } vm_pages_t;
-
-
-typedef struct {
-  pageEntry_t  *page_dir;
-  page_t       *page_tbl;
-  unsigned     *page_tbl_laddr_map;
-  page_t       *nexus_page_tbl;
-  guest_cpu_t  *guest_cpu;
-  page_t       *transition_PT;
-  unsigned char *log_buffer;
-  Bit8u        *code_phy_page; /* only use in mon space */
-  Bit8u        *tmp_phy_page0; /* only use in mon space */
-  Bit8u        *tmp_phy_page1; /* only use in mon space */
-
-  nexus_t      *nexus;
-  /* Pointer into the monitor stack, so we can easily retrieve the */
-  /* stack snapshot upon interrupt/exception. */
-  guest_context_t *guest_context;
-  gate_t       *idt;
-  descriptor_t *gdt;
-  descriptor_t *ldt;
-  tss_t        *tss;
-  idt_stub_t   *idt_stubs;
-  } vm_addr_t;
-
-
-/* These bits define the possible usage and attributes assigned */
-/* to a particular guest physical page.  These are useful for keeping */
-/* track of what kinds of system structures are contained in a page */
-/* at a given time, and if the page has associated cached code */
-/* information in the prescan logic.  We can also tag particular */
-/* pages with other more static attributes. */
-
-typedef union {
-  struct {
-    Bit32u access_perm:2;     /* */
-    Bit32u lmap_count:2;      /* */
-    Bit32u ptbl:1;            /* page table */
-    Bit32u pdir:1;            /* page directory */
-    Bit32u spare0:1;          /* (spare) */
-    Bit32u memMapIO:1;        /* MemMapIO */
-    Bit32u RO:1;              /* RO */
-    Bit32u allocated:1;       /* Allocated */
-    Bit32u pinned:1;          /* Pinned by host OS. */
-    Bit32u spare1:1;          /* (spare) */
-    Bit32u laddr_backlink:20; /* 1st unvirtualized laddr backlink */
-    } __attribute__ ((packed)) fields;
-  Bit32u raw;
-  } __attribute__ ((packed)) phy_page_attr_t;
-
-typedef struct {
-  phy_page_attr_t attr;
-  Bit64u tsc; /* for comparing to CR3 timestamp counter */
-
-  Bit32u hostPPI;
-  } __attribute__ ((packed)) phyPageInfo_t;
-
-/* Possible values of the access_perm field above. */
-#define PagePermRW      0
-#define PagePermRO      1
-#define PagePermEmulate 2
-#define PagePermNA PagePermEmulate  /* No Access is synomym */
-
-
-/* Bitmasks to access fields in structure above. */
-#define PageUsagePTbl             0x010
-#define PageUsagePDir             0x020
-
-#define PageUsageMemMapIO         0x080
-#define PageUsageRO               0x100
-#define PageUsageAllocated        0x200
-#define PageUsageSwappable        0x400
-
-/* Group of attributes which retain their value, even when CR3 */
-/* is reloaded and the page mappings are flushed. */
-#define PageUsageSticky \
-  ( PageUsageMemMapIO | PageUsageRO | \
-    PageUsageAllocated | PageUsageSwappable )
-
-/* Group of attributes which are not compatible with a Page Table */
-/* occupying a physical page. */
-#define PageBadUsage4PTbl \
-  ( PageUsagePDir | PageUsageMemMapIO | PageUsageRO )
-
-/* Group of attributes which are not compatible with a Page Directory */
-/* occupying a physical page.  Keep in mind, when the PDir is marked, */
-/* no other dynamic bits will be set. */
-#define PageBadUsage4PDir \
-  ( PageUsageMemMapIO | PageUsageRO )
-
-#define PageUsageCausesNA \
-  ( PageUsagePTbl | PageUsagePDir | PageUsageMemMapIO )
-#define PageUsageCausesRO \
-  ( PageUsageRO )
-
-#define PDEUnhandled 0x000001d8
-#define PTEUnhandled 0x00000198
-
-
-#define ExceptionDE   0 /* Divide Error (fault) */
-#define ExceptionDB   1 /* Debug (fault/trap) */
-#define ExceptionBP   3 /* Breakpoint (trap) */
-#define ExceptionOF   4 /* Overflow (trap) */
-#define ExceptionBR   5 /* BOUND (fault) */
-#define ExceptionUD   6
-#define ExceptionNM   7
-#define ExceptionDF   8
-#define ExceptionTS  10
-#define ExceptionNP  11
-#define ExceptionSS  12
-#define ExceptionGP  13
-#define ExceptionPF  14
-#define ExceptionMF  16
-#define ExceptionAC  17
-
-
-#define CR0_PE  (1<<0)
-#define CR0_MP  (1<<1)
-#define CR0_EM  (1<<2)
-#define CR0_TS  (1<<3)
-#define CR0_ET  (1<<4)
-#define CR0_NE  (1<<5)
-#define CR0_WP  (1<<16)
-#define CR0_AM  (1<<18)
-#define CR0_NW  (1<<29)
-#define CR0_CD  (1<<30)
-#define CR0_PG  (1<<31)
-
-/*
- * Complete state of the VM (Virtual Machine).
- */
-typedef struct {
-  Bit32u guestPhyMemAddr; /* Ptr to malloced memory from user space. */
-
-  /* Store eflags values of the guest which are virtualized to
-   * run in the monitor
-   */
-  eflags_t veflags;
-
-  unsigned executeMethod;
-  unsigned vmState;
-
-  unsigned mon_request;
-  unsigned guestFaultNo;
-  Bit32u   pinReqPPI;
-
-  unsigned redirect_vector;
-
-  Bit32u   kernel_offset;
-
-#define MonitorSpace 0
-#define UserSpace    1
-#define HostSpace    2
-
-  volatile unsigned inMonFault;
-
-  /* Extra info on aborts, especially when a message can't
-   * be printed out
-   */
-  unsigned abort_code;
-
-  struct {
-    Bit64u     t0; /* TSC before excecution of guest code */
-    Bit64u     cyclesElapsed; /* Cycles of guest execution */
-    unsigned   a20Enable;    /* A20 line enabled? */
-    Bit32u     a20AddrMask;  /* mask to apply to phy address */
-    Bit32u     a20IndexMask; /* mask to apply to phy address */
-    } system;
-
-  cpuid_info_t guestCPUIDInfo;
-
-/* This macro yields a physical address after applying the A20 line
- * enable mask to the original physical address.
- */
-#define A20Addr(vm, paddr) ( (paddr) & ((vm)->system.a20AddrMask) )
-#define A20PageIndex(vm, pi) ( (pi) & ((vm)->system.a20IndexMask) )
-
-  /* Keep an index of the next available Page Table */
-  unsigned  ptbl_laddr_map_i;
-
-  Bit32u mon_pde_mask; /* Upper 10 bits of monitor lin addr space */
-  Bit32u mon_pdi;      /* Same value shifted down 22 bits. */
-  Bit64u vpaging_tsc; /* time stamp of last page mappings flush */
-
-  /* We need to keep track of what each of the guest's physical */
-  /* pages contains, and maintain some additional attributes. */
-  /* We determine which kinds of information reside in the page, */
-  /* dynamically. */
-  phyPageInfo_t pageInfo[MAX_MON_GUEST_PAGES];
-
-  /* This is a hack for now.  I need to store the "struct page *"
-   * information returned by get_user_pages() in the Linux kernel.
-   * Should clean this up.
-   */
-  void  *hostStructPagePtr[MAX_MON_GUEST_PAGES];
-
-  /* A revolving queue, which stores information on guest physical memory
-   * pages which are currently pinned.  Only a certain number of pages
-   * may be pinned at any one time.  This is a really simplistic
-   * strategy - when the Q is full, the page which was pinned the
-   * longest time ago is unpinned to make room.  It's a
-   * "least recently pinned" strategy.
-   */
-#define MaxPhyPagesPinned 1024  /* 4Megs of pinned pages max per VM. */
-  struct {
-    unsigned nEntries; /* Number of entries in table. */
-    unsigned tail;
-    Bit32u ppi[MaxPhyPagesPinned]; /* Physical Page Index of pinned guest page. */
-    } guestPhyPagePinQueue;
-
-  struct {
-    volatile unsigned event; /* Any log event occurred. */
-    /* Inactive, OK to dump to host and change */
-    volatile unsigned locked;
-    /* Number of times buffer wrapped since last print to kernel */
-    /*   debug facility */
-    volatile unsigned offset; /* Current index within buffer */
-    volatile unsigned error;  /* Error printing. (ex. string too long) */
-    } log_buffer_info;
-
-  vm_pages_t         pages;  /* memory pages allocated by the host */
-
-  /* Host specific fields.  These fields should NOT be accessed */
-  /* from code which may execute in either host or monitor/guest */
-  /* spaces, unless you need to _specifically_ manipulate a */
-  /* host-specific field. */
-  struct {
-    vm_addr_t    addr;   /* addresses of data structures in host space */
-    void       (*__host2mon)(void);   /* Host to guest nexus entry point */
-    pageEntry_t  nexus_pde;           /* PDE pointing to nexus page table */
-    } host;
-
-  /* Guest specific fields.  These fields should NOT be accessed */
-  /* from code which may execute in either host or monitor/guest */
-  /* spaces, unless you need to _specifically_ manipulate a */
-  /* guest-specific field. */
-  struct {
-    vm_addr_t    addr;   /* addresses of data structures in guest space */
-    void       (*__mon2host)(void);  /* monitor to host entry point */
-    } guest;
-  } vm_t;
-
-
-extern char __nexus_start, __nexus_end, __mon_cs;
-extern char __host2mon, __mon2host, __handle_fault, __handle_int;
-extern char __ret_to_guest;
-
-
-
-/*
- * This structure describes the pages containing the code/data
- * of the monitor itself (inside the kernel module)
- */
-
-#define Plex86MaxKernelModulePages 128
-
-typedef struct {
-  /* Virtual address space occupied by the kernel module. */
-  Bit32u startOffset;
-  Bit32u startOffsetPageAligned;
-  unsigned nPages; /* Number of pages. */
-    
-  /* A list of the Physical Page Indeces of the pages comprising the
-   * kernel module.  A PPI is just the physical page address >> 12.
-   */
-  Bit32u ppi[Plex86MaxKernelModulePages];
-  } kernelModulePages_t;
-
-extern kernelModulePages_t kernelModulePages;
-extern cpuid_info_t        hostCpuIDInfo;
-
-
-
-#if !defined(IN_HOST_SPACE) && !defined(IN_MONITOR_SPACE)
-#error "No space defined for this file"
-#endif
-
-
-#if defined(IN_HOST_SPACE) || defined(IN_MONITOR_SPACE)
-
-void  mon_memzero(void *ptr, int size);
-void  mon_memcpy(void *dst, void *src, int size);
-void *mon_memset(void *s, unsigned c, unsigned n);
-
-/*
- *  We need to set the monitor CS/DS base address so that the module pages,
- *  which are mapped starting at linear address 'laddr' into the guest address
- *  space, reside at the same offset relative to the monitor CS base as they
- *  reside relative to the kernel CS base in the host address space.  This way,
- *  we can execute the (non-relocatable) module code within the guest address
- *  space ...
- */
-#define MON_BASE_FROM_LADDR(laddr) \
-    ((laddr) - kernelModulePages.startOffsetPageAligned)
-
-
-/* ============================================================
- * These are the functions which are available in either of the
- * host or monitor/guest spaces.
- */
-
-
-/* Access to label offsets in nexus.S... From the host address perspective */
-#define HOST_NEXUS_OFFSET(vm, field) \
-    ( ((Bit32u)vm->host.addr.nexus) + \
-      (((Bit32u) &field) - ((Bit32u) &__nexus_start)) )
-
-/* From the monitor/guest address perspective. */
-#define MON_NEXUS_OFFSET(vm, field) \
-    ( ((Bit32u)vm->guest.addr.nexus) + \
-      (((Bit32u) &field) - ((Bit32u) &__nexus_start)) )
-
-  static __inline__ Bit64u
-vm_rdtsc(void) {
-  Bit64u ret;
-  asm volatile (
-    "rdtsc"
-    : "=A" (ret)
-    );
-  return ret;
-  }
-#endif  /* {HOST, MONITOR} */
-
-
-
-
-#ifdef IN_HOST_SPACE
-/* ==========================================================
- * These are the functions which are available to the monitor
- * running in the host space.
- */
-
-
-/*
- * Generate a software interrupt
- */
-
-#define soft_int(n)                             \
-    asm volatile (                              \
-        "    movb %b0, __soft_int_vector \n\t"  \
-        "    jmp __soft_int_n            \n\t"  \
-        "__soft_int_n:                   \n\t"  \
-        "    sti                         \n\t"  \
-        "    .byte 0xcd                  \n\t"  \
-        "__soft_int_vector:              \n\t"  \
-        "    .byte 0x00                  \n\t"  \
-        :                                       \
-        : "r" ((Bit8u) (n) )                    \
-        : "memory"                              \
-    )
-
-#define Plex86ErrnoEBUSY      1
-#define Plex86ErrnoENOMEM     2
-#define Plex86ErrnoEFAULT     3
-#define Plex86ErrnoEINVAL     4
-#define Plex86ErrnoEACCES     5
-#define Plex86ErrnoEAGAIN     6
-
-#define vm_save_flags(x) \
-  asm volatile("pushfl ; popl %0": "=g" (x): :"memory")
-
-#define vm_restore_flags(x) \
-  asm volatile("pushl %0 ; popfl": :"g" (x): "memory", "cc")
-
-
-int      hostInitMonitor(vm_t *);
-unsigned hostMapMonitor(vm_t *);
-unsigned hostInitGuestPhyMem(vm_t *);
-void     hostUnallocVmPages(vm_t *);
-int      hostAllocVmPages(vm_t *, plex86IoctlRegisterMem_t *registerMsg);
-void     hostInitShadowPaging(vm_t *vm);
-void     hostDeviceOpen(vm_t *);
-unsigned hostModuleInit(void);
-unsigned hostGetCpuCapabilities(void);
-int      hostIoctlGeneric(vm_t *vm, void *inode, void *filp,
-                          unsigned int cmd, unsigned long arg);
-int      hostIoctlExecute(vm_t *vm, plex86IoctlExecute_t *executeMsg);
-int      hostIoctlRegisterMem(vm_t *vm, plex86IoctlRegisterMem_t *registerMsg);
-void     hostCopyGuestStateToUserSpace(vm_t *vm);
-void     hostReleasePinnedUserPages(vm_t *vm);
-unsigned hostHandlePagePinRequest(vm_t *vm, Bit32u reqPPI);
-
-/* These are the functions that the host-OS-specific file of the
- * plex86 device driver must define.
- */
-unsigned hostOSIdle(void);
-void    *hostOSAllocZeroedMem(unsigned long size);
-void     hostOSFreeMem(void *ptr);
-void    *hostOSAllocZeroedPage(void);
-void     hostOSFreePage(void *ptr);
-unsigned hostOSGetAllocedMemPhyPages(Bit32u *page, int max_pages, void *ptr,
-                                   unsigned size);
-Bit32u   hostOSGetAndPinUserPage(vm_t *vm, Bit32u userAddr, void **osSpecificPtr,
-             Bit32u *ppi, Bit32u *kernelAddr);
-void     hostOSUnpinUserPage(vm_t *vm, Bit32u userAddr, void *osSpecificPtr,
-             Bit32u ppi, Bit32u *kernelAddr, unsigned dirty);
-Bit32u   hostOSGetAllocedPagePhyPage(void *ptr);
-void     hostOSPrint(char *fmt, ...);
-Bit32u   hostOSKernelOffset(void);
-int      hostOSConvertPlex86Errno(unsigned ret);
-void     hostOSModuleCountReset(vm_t *vm, void *inode, void *filp);
-void     hostOSInstrumentIntRedirCount(unsigned interruptVector);
-unsigned long hostOSCopyFromUser(void *to, void *from, unsigned long len);
-unsigned long hostOSCopyToUser(void *to, void *from, unsigned long len);
-
-#endif  /* HOST Space */
-
-
-
-
-#ifdef IN_MONITOR_SPACE
-/* ==========================================================
- * These are the functions which are available to the monitor
- * running in the monitor/guest space.
- */
-
-void sysFlushPrintBuf(vm_t *);
-void sysRemapMonitor(vm_t *);
-int  monprint(vm_t *, char *fmt, ...);
-int  mon_vsnprintf(char *str, unsigned size, const char *fmt,
-                   va_list args);
-void resetPrintBuf(vm_t *);
-
-/* Translate from guest laddr to monitor laddr. */
-#define Guest2Monitor(vm, laddr) ( ((Bit32u) (laddr)) - \
-                                   vm->guest.addr.nexus->mon_base )
-
-void monpanic(vm_t *, char *fmt, ...) __attribute__ ((noreturn));
-void monpanic_nomess(vm_t *);
-
-void toHostGuestFault(vm_t *, unsigned fault);
-void toHostPinUserPage(vm_t *, Bit32u ppi);
-
-void guestPageFault(vm_t *, guest_context_t *context, Bit32u cr2);
-void *open_guest_phy_page(vm_t *, Bit32u ppage_index, Bit8u *mon_offset);
-void close_guest_phy_page(vm_t *, Bit32u ppage_index);
-
-#define MapLinOK              0
-#define MapLinMonConflict     1
-#define MapLinAlreadyMapped   2
-#define MapLinPPageOOB        3
-#define MapLinException       4
-#define MapLinEmulate         5
-unsigned mapGuestLinAddr(vm_t *, Bit32u guest_laddr,
-                         Bit32u *guest_ppage_index, unsigned us,
-                         unsigned rw, Bit32u attr, Bit32u *error);
-unsigned addPageAttributes(vm_t *, Bit32u ppi, Bit32u attr);
-phyPageInfo_t *getPageUsage(vm_t *, Bit32u ppage_index);
-void virtualize_lconstruct(vm_t *, Bit32u l0, Bit32u l1, unsigned perm);
-
-unsigned getMonPTi(vm_t *, unsigned pdi, unsigned source);
-#define invlpg_mon_offset(mon_offset) \
-  asm volatile ("invlpg (%0)": :"r" (mon_offset): "memory")
-
-/* For now nothing, but we should conditionally compile in code
- * to panic when the expression is not true.
- */
-
-#define VM_ASSERT(vm, expression) \
-  if ( !(expression) ) \
-    monpanic(vm, "Assertion (%s) failed at %s:%u", \
-             #expression, __FILE__, __LINE__)
-
-#define CLI() asm volatile ("cli": : : "memory")
-#define STI() asm volatile ("sti": : : "memory")
-
-#endif  /* MONITOR Space. */
-
-#endif  /* __MONITOR_H__ */
diff -Nur bochs-2.0.2+20030829.old/plex86/kernel/include/paging.h bochs-2.0.2+20030829/plex86/kernel/include/paging.h
--- bochs-2.0.2+20030829.old/plex86/kernel/include/paging.h	2003-01-01 17:32:05.000000000 +0000
+++ bochs-2.0.2+20030829/plex86/kernel/include/paging.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,51 +0,0 @@
-/*
- *  plex86: run multiple x86 operating systems concurrently
- *  Copyright (C) 1999-2003 Kevin P. Lawton
- *
- *  paging.h: defines for x86 paging structures
- *
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Lesser General Public
- *  License as published by the Free Software Foundation; either
- *  version 2 of the License, or (at your option) any later version.
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- */
-
-#ifndef __PAGING_H__
-#define __PAGING_H__
-
-#define PG_D 0x00000040
-#define PG_A 0x00000020
-
-/* Page Directory/Table format */
-typedef union {
-  Bit32u raw;
-  struct {
-    Bit32u  P:1;
-    Bit32u  RW:1;
-    Bit32u  US:1;
-    Bit32u  PWT:1;
-    Bit32u  PCD:1;
-    Bit32u  A:1;
-    Bit32u  D:1;
-    Bit32u  PS:1;
-    Bit32u  G:1;
-    Bit32u  avail:3;
-    Bit32u  base:20;
-    } __attribute__ ((packed)) fields;
-  } __attribute__ ((packed)) pageEntry_t;
-
-typedef union {
-  Bit8u       bytes[4096];
-  pageEntry_t pte[1024];
-  } page_t;
-
-#endif  /* __PAGING_H__ */
diff -Nur bochs-2.0.2+20030829.old/plex86/kernel/include/tss.h bochs-2.0.2+20030829/plex86/kernel/include/tss.h
--- bochs-2.0.2+20030829.old/plex86/kernel/include/tss.h	2003-01-01 17:32:05.000000000 +0000
+++ bochs-2.0.2+20030829/plex86/kernel/include/tss.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,50 +0,0 @@
-/*
- *  plex86: run multiple x86 operating systems concurrently
- *  Copyright (C) 1999-2003 Kevin P. Lawton
- *
- *  tss.h: defines for x86 hardware tasking structures
- *
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Lesser General Public
- *  License as published by the Free Software Foundation; either
- *  version 2 of the License, or (at your option) any later version.
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- */
-
-#ifndef __TSS_H__
-#define __TSS_H__
-
-typedef struct 
-{
-    Bit16u back, RESERVED0;      /* Backlink */
-    Bit32u esp0;                 /* The CK stack pointer */
-    Bit16u ss0,  RESERVED1;      /* The CK stack selector */
-    Bit32u esp1;                 /* The parent KL stack pointer */
-    Bit16u ss1,  RESERVED2;      /* The parent KL stack selector */
-    Bit32u esp2;                 /* Unused */
-    Bit16u ss2,  RESERVED3;      /* Unused */
-    Bit32u cr3;                  /* The page directory pointer */
-    Bit32u eip;                  /* The instruction pointer */
-    Bit32u eflags;               /* The flags */
-    Bit32u eax, ecx, edx, ebx;   /* The general purpose registers */
-    Bit32u esp, ebp, esi, edi;   /* The special purpose registers */
-    Bit16u es,   RESERVED4;      /* The extra selector */
-    Bit16u cs,   RESERVED5;      /* The code selector */
-    Bit16u ss,   RESERVED6;      /* The application stack selector */
-    Bit16u ds,   RESERVED7;      /* The data selector */
-    Bit16u fs,   RESERVED8;      /* And another extra selector */
-    Bit16u gs,   RESERVED9;      /* ... and another one */
-    Bit16u ldt,  RESERVED10;     /* The local descriptor table */
-    Bit16u trap;                 /* The trap flag (for debugging) */
-    Bit16u io;                   /* The I/O Map base address */
-} __attribute__ ((packed)) tss_t;
-
-#endif  /* __TSS_H__ */
diff -Nur bochs-2.0.2+20030829.old/plex86/kernel/monitor-host.c bochs-2.0.2+20030829/plex86/kernel/monitor-host.c
--- bochs-2.0.2+20030829.old/plex86/kernel/monitor-host.c	2003-01-10 04:27:51.000000000 +0000
+++ bochs-2.0.2+20030829/plex86/kernel/monitor-host.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,1886 +0,0 @@
-/*
- *  plex86: run multiple x86 operating systems concurrently
- *  Copyright (C) 1999-2003 Kevin P. Lawton
- *
- *  monitor-host.c:  This file contains the top-level monitor code,
- *    accessible from the host space. (kernel independent code)
- *
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Lesser General Public
- *  License as published by the Free Software Foundation; either
- *  version 2 of the License, or (at your option) any later version.
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- */
-
-
-#include "plex86.h"
-#define IN_HOST_SPACE
-#include "monitor.h"
-
-
-/* =====================================================================
- * Plex86 module global variables.  This should be the _only_ place
- * where globals are declared.  Since plex86 supports multiple VMs, almost
- * all data is stored per-VM.  For the few variables which are global
- * to all VMs, we have to be careful to access them in SMP friendly ways.
- * The ones which are written upon kernel module initialization are fine,
- * since they are only written once.
- * =====================================================================
- */
-
-/* Info regarding the physical pages that comprise the kernel module,
- * including physical page information.  This is written (once) at
- * kernel module initialization time.  Thus there are no SMP access issues.
- */
-kernelModulePages_t kernelModulePages;
-
-/* Information of the host processor as returned by the CPUID
- * instruction.  This is written (once) at kernel module initialization time.
- * Thus there no are SMP access issues.
- */
-cpuid_info_t hostCpuIDInfo;
-
-
-/* Some constants used by the VM logic.  Since they're "const", there are
- * no problems with SMP access.
- */
-static const selector_t nullSelector = { raw: 0 };
-static const descriptor_t nullDescriptor = {
-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-  };
-
-
-
-
-static int  hostInitIDTSlot(vm_t *vm, unsigned vec, int type);
-static void hostMapMonPages(vm_t *vm, Bit32u *, unsigned, Bit32u *, page_t *,
-                            unsigned user, unsigned writable, char *name);
-#if ANAL_CHECKS
-static void hostMapBlankPage(vm_t *vm, Bit32u *laddr_p, page_t *pageTable);
-#endif
-
-#define RW0 0
-#define RW1 1
-#define US0 0
-#define US1 1
-
-#define IDT_INTERRUPT          0
-#define IDT_EXCEPTION_ERROR    1
-#define IDT_EXCEPTION_NOERROR  2
-
-
-
-
-
-  unsigned
-hostModuleInit(void)
-{
-  /* Kernel independent stuff to do at kernel module load time. */
-
-  if (!hostGetCpuCapabilities()) {
-    hostOSPrint("getCpuCapabilities returned error\n");
-    return(0); /* Fail. */
-    }
-  else {
-#if 0
-    hostOSPrint("ptype:%u, family:%u, model:%u stepping:%u\n",
-        hostCpuIDInfo.procSignature.fields.procType,
-        hostCpuIDInfo.procSignature.fields.family,
-        hostCpuIDInfo.procSignature.fields.model,
-        hostCpuIDInfo.procSignature.fields.stepping);
-#endif
-    }
-
-  /* xxx Should check that host CS.base is page aligned here. */
-
-#if 1
-  {
-  Bit32u cr0;
-
-  asm volatile ( "movl %%cr0, %0" : "=r" (cr0) );
-  hostOSPrint("host CR0=0x%x\n", cr0);
-  }
-#endif
-
-  return(1); /* Pass. */
-}
-
-  void
-hostDeviceOpen(vm_t *vm)
-{
-  /* Kernel independent stuff to do at device open time. */
-
-  /* Zero out entire VM structure. */
-  mon_memzero( vm, sizeof(vm_t) );
-
-  vm->vmState = VMStateFDOpened;
-}
-
-  int
-hostInitMonitor(vm_t *vm)
-{
-  unsigned pdi, pti;
-  unsigned int i;
-  Bit32u nexus_size;
-  page_t  *pageTable;
-  Bit32u laddr, base;
-  int r;
-
-  vm->kernel_offset = hostOSKernelOffset();
-
-  vm->system.a20Enable = 1; /* Start with A20 line enabled. */
-  vm->system.a20AddrMask  = 0xffffffff; /* All address lines contribute. */
-  vm->system.a20IndexMask = 0x000fffff; /* All address lines contribute. */
-
-  /* Initialize nexus */
-  mon_memzero(vm->host.addr.nexus, 4096);
-
-  /* Copy transition code (nexus) into code page allocated for this VM. */
-  nexus_size = ((Bit32u) &__nexus_end) - ((Bit32u) &__nexus_start);
-  if (nexus_size > 4096)
-    goto error;
-  mon_memcpy(vm->host.addr.nexus, &__nexus_start, nexus_size);
-
-
-  /* Init the convenience pointers. */
-
-  /* Pointer to host2mon routine inside nexus page */
-  vm->host.__host2mon = (void (*)(void)) HOST_NEXUS_OFFSET(vm, __host2mon);
-
-  /* Pointer to guest context on monitor stack */
-  vm->host.addr.guest_context = (guest_context_t *)
-    ( (Bit32u)vm->host.addr.nexus + PAGESIZE - sizeof(guest_context_t) );
-
-  /* Zero out various monitor data structures */
-  mon_memzero(vm->host.addr.log_buffer, 4096*LOG_BUFF_PAGES);
-  mon_memzero(&vm->log_buffer_info,
-              sizeof(vm->log_buffer_info));
-  mon_memzero(vm->host.addr.page_dir, 4096);
-  mon_memzero(vm->host.addr.guest_cpu, 4096);
-  mon_memzero(vm->host.addr.idt, MON_IDT_PAGES*4096);
-  mon_memzero(vm->host.addr.gdt, MON_GDT_PAGES*4096);
-  mon_memzero(vm->host.addr.ldt, MON_LDT_PAGES*4096);
-  mon_memzero(vm->host.addr.tss, MON_TSS_PAGES*4096);
-  mon_memzero(vm->host.addr.idt_stubs, MON_IDT_STUBS_PAGES*4096);
-
-  vm->guestPhyPagePinQueue.nEntries = 0;
-  vm->guestPhyPagePinQueue.tail = 0;
-
-  /*
-   *  ================
-   *  Nexus Page Table
-   *  ================
-   *
-   *  All structures needed by the monitor inside the guest environment
-   *  (code to perform the transition between host<-->guest, fault handler
-   *  code, various processor data structures like page directory, GDT,
-   *  IDT, TSS etc.) are mapped into a single Page Table.
-   *
-   *  This allows us to migrate the complete nexus to anywhere in the
-   *  guest address space by just updating a single (unused) page directory
-   *  entry in the monitor/guest page directory to point to this nexus
-   *  page table.
-   *
-   *  To simplify nexus migration, we try to avoid storing guest linear
-   *  addresses to nexus structures as far as possible.  Instead, we use
-   *  offsets relative to the monitor code/data segments.  As we update
-   *  the base of these segments whenever the monitor migrates, the net
-   *  effect is that those *offsets* remain valid across nexus migration. 
-   */
-
-  /* Fill in the PDE flags.  The US bit is set to 1 (user access).
-   * All of the US bits in the monitor PTEs are set to 0 (system access).
-   */
-  vm->host.nexus_pde.fields.base = vm->pages.nexus_page_tbl;
-  vm->host.nexus_pde.fields.avail = 0;
-  vm->host.nexus_pde.fields.G = 0;      /* not global */
-  vm->host.nexus_pde.fields.PS = 0;     /* 4K pages */
-  vm->host.nexus_pde.fields.D = 0;      /* (unused in pde) */
-  vm->host.nexus_pde.fields.A = 0;      /* not accessed */
-  vm->host.nexus_pde.fields.PCD = 0;    /* normal caching */
-  vm->host.nexus_pde.fields.PWT = 0;    /* normal write-back */
-  vm->host.nexus_pde.fields.US = 1;     /* user access (see above) */
-  vm->host.nexus_pde.fields.RW = 1;     /* read or write */
-  vm->host.nexus_pde.fields.P = 1;      /* present in memory */
-
-  /* Clear Page Table. */
-  pageTable = vm->host.addr.nexus_page_tbl;
-  mon_memzero(pageTable, 4096);
-
-  /* xxx Comment here */
-  laddr = 0;
-  base = MON_BASE_FROM_LADDR(laddr);
-
-  hostMapMonPages(vm, kernelModulePages.ppi, kernelModulePages.nPages, &laddr,
-                  pageTable, US0, RW1, "Monitor code/data pages");
-
-
-#if ANAL_CHECKS
-  hostMapBlankPage(vm, &laddr, pageTable);
-#endif
-
-  vm->guest.addr.nexus = (nexus_t *) (laddr - base);
-  hostMapMonPages(vm, &vm->pages.nexus, 1, &laddr, pageTable, US0, RW1, "Nexus");
-  vm->guest.addr.guest_context = (guest_context_t *)
-    ( (Bit32u)vm->guest.addr.nexus + PAGESIZE - sizeof(guest_context_t) );
-
-#if ANAL_CHECKS
-  hostMapBlankPage(vm, &laddr, pageTable);
-#endif
-  vm->host.addr.nexus->vm = (void *) (laddr - base);
-  hostMapMonPages(vm, vm->pages.vm, BytesToPages(sizeof(*vm)),
-                  &laddr, pageTable, US0, RW1, "VM structure");
-
-#if ANAL_CHECKS
-  hostMapBlankPage(vm, &laddr, pageTable);
-#endif
-  vm->guest.addr.idt = (gate_t *) (laddr - base);
-  hostMapMonPages(vm, vm->pages.idt, MON_IDT_PAGES, &laddr, pageTable, US0, RW1,
-                  "IDT");
-
-#if ANAL_CHECKS
-  hostMapBlankPage(vm, &laddr, pageTable);
-#endif
-  vm->guest.addr.gdt = (descriptor_t *) (laddr - base);
-  hostMapMonPages(vm, vm->pages.gdt, MON_GDT_PAGES, &laddr, pageTable, US0, RW1,
-                  "GDT");
-
-#if ANAL_CHECKS
-  hostMapBlankPage(vm, &laddr, pageTable);
-#endif
-  vm->guest.addr.ldt = (descriptor_t *) (laddr - base);
-  hostMapMonPages(vm, vm->pages.ldt, MON_LDT_PAGES, &laddr, pageTable, US0, RW1,
-                  "LDT");
-
-#if ANAL_CHECKS
-  hostMapBlankPage(vm, &laddr, pageTable);
-#endif
-  vm->guest.addr.tss = (tss_t *) (laddr - base);
-  hostMapMonPages(vm, vm->pages.tss, MON_TSS_PAGES, &laddr, pageTable, US0, RW1,
-                  "TSS");
-
-#if ANAL_CHECKS
-  hostMapBlankPage(vm, &laddr, pageTable);
-#endif
-  vm->guest.addr.idt_stubs = (idt_stub_t *) (laddr - base);
-  hostMapMonPages(vm, vm->pages.idt_stubs, MON_IDT_STUBS_PAGES, &laddr,
-                  pageTable, US0, RW1, "IDT stubs");
-
-#if ANAL_CHECKS
-  hostMapBlankPage(vm, &laddr, pageTable);
-#endif
-  /* Monitor Page Directory */
-  vm->guest.addr.page_dir = (pageEntry_t *) (laddr - base);
-  hostMapMonPages(vm, &vm->pages.page_dir, 1, &laddr, pageTable, US0, RW1,
-                  "Monitor Page Directory");
-
-#if ANAL_CHECKS
-  hostMapBlankPage(vm, &laddr, pageTable);
-#endif
-  /* Nexus Page Table */
-  vm->guest.addr.nexus_page_tbl = (page_t *) (laddr - base);
-  hostMapMonPages(vm, &vm->pages.nexus_page_tbl, 1, &laddr, pageTable, US0, RW1,
-                  "Nexus Page Table");
-
-#if ANAL_CHECKS
-  hostMapBlankPage(vm, &laddr, pageTable);
-#endif
-  /* Map virtualized guest page tables into monitor. */
-  vm->guest.addr.page_tbl = (page_t *) (laddr - base);
-  hostMapMonPages(vm, vm->pages.page_tbl, MON_PAGE_TABLES,
-                  &laddr, pageTable, US0, RW1, "Guest Page Tables");
-
-#if ANAL_CHECKS
-  hostMapBlankPage(vm, &laddr, pageTable);
-#endif
-  /* Map of linear addresses of page tables mapped into monitor */
-  vm->guest.addr.page_tbl_laddr_map = (unsigned *) (laddr - base);
-  hostMapMonPages(vm, &vm->pages.page_tbl_laddr_map, 1, &laddr, pageTable,
-                  US0, RW1, "Page Table Laddr Map");
-
-#if ANAL_CHECKS
-  hostMapBlankPage(vm, &laddr, pageTable);
-#endif
-  /* Guest CPU state (mapped RW into user space also). */
-  vm->guest.addr.guest_cpu = (guest_cpu_t *) (laddr - base);
-  hostMapMonPages(vm, &vm->pages.guest_cpu, 1, &laddr,
-                  pageTable, US0, RW1, "Guest CPU State");
-
-
-#if ANAL_CHECKS
-  hostMapBlankPage(vm, &laddr, pageTable);
-#endif
-  /*
-   *  We need a buffer to implement a debug print facility which
-   *  can work in either host or monitor space.  Map the buffer
-   *  into monitor/guest space.
-   */
-  vm->guest.addr.log_buffer = (unsigned char *) (laddr - base);
-  hostMapMonPages(vm, vm->pages.log_buffer, LOG_BUFF_PAGES, &laddr,
-                  pageTable, US0, RW1, "Log Buffer");
-
-  {
-  /* The physical addresses of the following pages are not */
-  /* yet established.  Pass dummy info until they are mapped. */
-  Bit32u tmp[1];
-  tmp[0] = 0;
-
-#if ANAL_CHECKS
-  hostMapBlankPage(vm, &laddr, pageTable);
-#endif
-  /* Window into the guest's current physical code page */
-  vm->guest.addr.code_phy_page = (unsigned char *) (laddr - base);
-  hostMapMonPages(vm, tmp, 1, &laddr, pageTable, US0, RW1, "Code Phy Page");
-
-#if ANAL_CHECKS
-  hostMapBlankPage(vm, &laddr, pageTable);
-#endif
-  /* Temporary window into a guest physical page, for accessing */
-  /* guest GDT, IDT, etc info. */
-  vm->guest.addr.tmp_phy_page0 = (unsigned char *) (laddr - base);
-  hostMapMonPages(vm, tmp, 1, &laddr, pageTable, US0, RW1, "Tmp Phy Page0");
-
-  vm->guest.addr.tmp_phy_page1 = (unsigned char *) (laddr - base);
-  hostMapMonPages(vm, tmp, 1, &laddr, pageTable, US0, RW1, "Tmp Phy Page1");
-  }
-
-#if ANAL_CHECKS
-  hostMapBlankPage(vm, &laddr, pageTable);
-#endif
-
-  hostOSPrint("Using %u/1024 PTE slots in 4Meg monitor range.\n",
-              (laddr >> 12) & 0x3ff);
-
-  /* Pointer to mon2host routine inside nexus page */
-  vm->guest.__mon2host = (void (*)(void)) MON_NEXUS_OFFSET(vm, __mon2host);
-
-
-  /*
-   *  =====================
-   *  Transition Page Table
-   *  =====================
-   *
-   *  To aid in the transition between host<-->monitor/guest spaces,
-   *  we need to have an address identity map situation for at least
-   *  one page; the page containing the transition code.   As we do
-   *  not know in advance whether this linear address range is in use
-   *  by the guest as well, we set aside a complete additional Page
-   *  Table, which contains only a single PTE pointing to the nexus page.
-   *
-   *  To create the identity map, we simply change the corresponding
-   *  monitor page directory entry to point to this transition Page Table.
-   *  This happens transparently inside the host<-->guest transition code; 
-   *  both the guest/monitor code and the host side code never see this 
-   *  transition page table entered into the page directory!
-   *
-   *  NOTE: We need to ensure that the nexus page table never spans the
-   *        same 4Meg linear address space region as this page table!
-   *        As we are free to choose the nexus linear address, this is
-   *        not a problem.
-   */
-
-  /* Get full linear address of nexus code page, as seen in host space. */
-  laddr = (Bit32u)vm->host.addr.nexus + vm->kernel_offset;
-  pdi = laddr >> 22;
-  pti = (laddr >> 12) & 0x3ff;
-
-  /*
-   *  We need to be able to access the PDE in the monitor page directory
-   *  that corresponds to this linear address from both host and monitor 
-   *  address spaces.
-   */
-  vm->host.addr.nexus->transition_pde_p_host = vm->host.addr.page_dir + pdi;
-  vm->host.addr.nexus->transition_pde_p_mon  = (pageEntry_t *)
-                        (((Bit32u)vm->guest.addr.page_dir) + (pdi << 2));
-  vm->host.addr.nexus->transition_laddr = laddr;
-
-  /* Fill in the PDE flags */
-  vm->host.addr.nexus->transition_pde.fields.base = vm->pages.transition_PT;
-  vm->host.addr.nexus->transition_pde.fields.avail = 0;
-  vm->host.addr.nexus->transition_pde.fields.G = 0;   /* not global */
-  vm->host.addr.nexus->transition_pde.fields.PS = 0;  /* 4K pages */
-  vm->host.addr.nexus->transition_pde.fields.D = 0;   /* (unused in pde) */
-  vm->host.addr.nexus->transition_pde.fields.A = 0;   /* not accessed */
-  vm->host.addr.nexus->transition_pde.fields.PCD = 0; /* normal caching */
-  vm->host.addr.nexus->transition_pde.fields.PWT = 0; /* normal write-back*/
-  vm->host.addr.nexus->transition_pde.fields.US = 0;  /* no user access  */
-  vm->host.addr.nexus->transition_pde.fields.RW = 1;  /* read or write */
-  vm->host.addr.nexus->transition_pde.fields.P = 1;   /* present in memory*/
-
-  /* Clear Page Table; only one PTE is used. */
-  pageTable = vm->host.addr.transition_PT;
-  mon_memzero(pageTable, 4096);
-
-  /* Fill in the PTE for identity mapping the code page */
-  pageTable->pte[pti].fields.base = vm->pages.nexus;
-  pageTable->pte[pti].fields.avail = 0;
-  pageTable->pte[pti].fields.G = 0;      /* not global          */
-  pageTable->pte[pti].fields.PS = 0;     /* (unused in pte)     */
-  pageTable->pte[pti].fields.D = 0;      /* clean               */
-  pageTable->pte[pti].fields.A = 0;      /* not accessed        */
-  pageTable->pte[pti].fields.PCD = 0;    /* normal caching      */
-  pageTable->pte[pti].fields.PWT = 0;    /* normal write-back   */
-  pageTable->pte[pti].fields.US = 0;     /* user can not access */
-  pageTable->pte[pti].fields.RW = 1;     /* read or write       */
-  pageTable->pte[pti].fields.P = 1;      /* present in memory   */
-
-
-  /* 
-   *  Setup the TSS for the monitor/guest environment.
-   *
-   *  We don't need to set the pagedir in the TSS, because we don't 
-   *  actually jump to it anyway.  The TSS is just used to set the kernel 
-   *  stack and in a later stage, perhaps the I/O permission bitmap.
-   */
-
-  /* No task chain. */
-  vm->host.addr.tss->back = 0;
-
-  /* No debugging or I/O, for now. */
-  vm->host.addr.tss->trap = 0;
-  vm->host.addr.tss->io = sizeof(tss_t);
-
-  /* Monitor stack offset. */
-  vm->host.addr.tss->esp0 =
-    ((Bit32u)vm->guest.addr.nexus) + PAGESIZE;
-
-
-  /*
-   * Set up initial monitor code and stack offset.
-   */
-
-  vm->host.addr.nexus->mon_jmp_info.offset   = MON_NEXUS_OFFSET(vm, __mon_cs);
-  vm->host.addr.nexus->mon_stack_info.offset =
-      vm->host.addr.tss->esp0 - (sizeof(guest_context_t) + 48);
-/* xxx 48 above should be calculated from code below which winds
- * xxx up monitor stack.
- */
-
-
-  /*
-   *  Setup the IDT for the monitor/guest environment
-   */
-
-  r = 0;
-  r |= hostInitIDTSlot(vm,  0, IDT_EXCEPTION_NOERROR); /* Divide error        */
-  r |= hostInitIDTSlot(vm,  1, IDT_EXCEPTION_NOERROR); /* Debug exceptions    */
-  r |= hostInitIDTSlot(vm,  2, IDT_INTERRUPT);         /* NMI                 */
-  r |= hostInitIDTSlot(vm,  3, IDT_EXCEPTION_NOERROR); /* Breakpoint          */
-  r |= hostInitIDTSlot(vm,  4, IDT_EXCEPTION_NOERROR); /* Overflow            */
-  r |= hostInitIDTSlot(vm,  5, IDT_EXCEPTION_NOERROR); /* Bounds check        */
-  r |= hostInitIDTSlot(vm,  6, IDT_EXCEPTION_NOERROR); /* Invalid opcode      */
-  r |= hostInitIDTSlot(vm,  7, IDT_EXCEPTION_NOERROR); /* FPU not available   */
-  r |= hostInitIDTSlot(vm,  8, IDT_EXCEPTION_ERROR);   /* Double fault        */
-  r |= hostInitIDTSlot(vm,  9, IDT_EXCEPTION_NOERROR); /* FPU segment overrun */
-  r |= hostInitIDTSlot(vm, 10, IDT_EXCEPTION_ERROR);   /* Invalid TSS         */
-  r |= hostInitIDTSlot(vm, 11, IDT_EXCEPTION_ERROR);   /* Segment not present */
-  r |= hostInitIDTSlot(vm, 12, IDT_EXCEPTION_ERROR);   /* Stack exception     */
-  r |= hostInitIDTSlot(vm, 13, IDT_EXCEPTION_ERROR);   /* GP fault            */
-  r |= hostInitIDTSlot(vm, 14, IDT_EXCEPTION_ERROR);   /* Page fault          */
-  r |= hostInitIDTSlot(vm, 15, IDT_EXCEPTION_NOERROR); /* reserved            */
-  r |= hostInitIDTSlot(vm, 16, IDT_EXCEPTION_NOERROR); /* Coprocessor error   */
-  r |= hostInitIDTSlot(vm, 17, IDT_EXCEPTION_ERROR);   /* Alignment check     */
-  r |= hostInitIDTSlot(vm, 18, IDT_EXCEPTION_NOERROR); /* Machine check       */
-
-  /* Reserved exceptions */
-  for (i = 19; i < 32; i++)
-      r |= hostInitIDTSlot(vm, i, IDT_EXCEPTION_NOERROR);
-
-  /* Hardware interrupts */
-  for (i = 32; i < 256; i++)
-      r |= hostInitIDTSlot(vm, i, IDT_INTERRUPT);
-  if (r!=0) 
-      goto error;
-
-
-  /*
-   *  Setup the initial guest context
-   */
-
-  mon_memzero(vm->host.addr.guest_context, sizeof(guest_context_t));
-
-  /* Wind up the monitor stack for the initial transition via
-   * __host2mon.  At the tail end, monitor state is popped from the
-   * stack and a RET is executed.
-   */
-  {
-  Bit32u *ptr;
-
-  ptr = (Bit32u *) (((unsigned char *) vm->host.addr.guest_context) - 4);
-  *ptr-- = (Bit32u) &__ret_to_guest;
-  *ptr-- = 0x02; /* eflags: only reserved bit on */
-  *ptr-- = 0; /* eax */
-  *ptr-- = 0; /* ecx */
-  *ptr-- = 0; /* edx */
-  *ptr-- = 0; /* ebx */
-  *ptr-- = 0; /* esp dummy */
-  *ptr-- = 0; /* ebp */
-  *ptr-- = 0; /* esi */
-  *ptr-- = 0; /* edi */
-  *ptr-- = 0; /* FS; start with null value. */
-  *ptr-- = 0; /* GS; start with null value. */
-  }
-
-  vm->vmState |= VMStateInitMonitor;
-  vm->mon_request = MonReqNone;
-
-  return(1); /* all OK */
-
-error:
-  return(0); /* error */
-}
-
-
-
-  unsigned
-hostInitGuestPhyMem(vm_t *vm)
-{
-  unsigned i;
-  mon_memzero(vm->pageInfo, sizeof(vm->pageInfo));
-  for (i=0; i<vm->pages.guest_n_pages; i++) {
-    /* For now, we start out by preallocating physical pages */
-    /* for the guest, though not necessarily mapped into linear */
-    /* space. */
-    vm->pageInfo[i].attr.raw = 0;
-    vm->pageInfo[i].tsc = 0;
-    vm->pageInfo[i].attr.fields.allocated = 1;
-    }
- 
-  {
-  Bit32u rom_page;
-  unsigned npages;
- 
-  /* Mark BIOS ROM area as ReadOnly */
-  rom_page = 0xf0000 >> 12;
-  npages = (1 + 0xfffff - 0xf0000) / 4096;
-  for (i=0; i<npages; i++)
-    vm->pageInfo[rom_page + i].attr.fields.RO = 1;
-
-  /* Mark VGA BIOS ROM area as ReadOnly */
-  rom_page = 0xc0000 >> 12;
-  npages = (1 + 0xc7fff - 0xc0000) / 4096;
-  for (i=0; i<npages; i++)
-    vm->pageInfo[rom_page + i].attr.fields.RO = 1;
-  }
- 
-#if 1
-  /* Mark VGA framebuffer area as Memory Mapped IO */
-  {
-  Bit32u vga_page;
-  unsigned npages;
- 
-  vga_page = 0xa0000 >> 12;
-  npages = (1 + 0xbffff - 0xa0000) / 4096;
-  for (i=0; i<npages; i++)
-    vm->pageInfo[vga_page + i].attr.fields.memMapIO = 1;
-  }
-#endif
-
-  return(0);
-}
-
-
-  int
-hostInitIDTSlot(vm_t *vm, unsigned vec, int type)
-/*
- *  initIDTSlot():  Initialize a monitor IDT slot.
- */
-{
-  /* IDT slot stubs */
-
-  idt_stub_t *stub = &vm->host.addr.idt_stubs[vec];
-  Bit32u stub_mon = ((Bit32u) vm->guest.addr.idt_stubs) +
-                    vec*sizeof(idt_stub_t);
-
-  if (sizeof(idt_stub_t) != IDT_STUB_SIZE)
-    return( -1 );
-
-  switch (type) {
-    case IDT_INTERRUPT:
-      stub->m2.pushla = 0x68;
-      stub->m2.dummy  = 0;
-      stub->m2.pushlb = 0x68;
-      stub->m2.vector = vec;
-      stub->m2.jmp    = 0xe9;
-      stub->m2.reloc  = ((Bit32u) &__handle_int) -
-        (stub_mon + sizeof(idt_method2_t));
-      break;
-
-    case IDT_EXCEPTION_ERROR:
-      stub->m1.pushl  = 0x68;
-      stub->m1.vector = vec;
-      stub->m1.jmp    = 0xe9;
-      stub->m1.reloc  = ((Bit32u) &__handle_fault) -
-        (stub_mon + sizeof(idt_method1_t));
-      break;
-
-    case IDT_EXCEPTION_NOERROR:
-      stub->m2.pushla = 0x68;
-      stub->m2.dummy  = 0;
-      stub->m2.pushlb = 0x68;
-      stub->m2.vector = vec;
-      stub->m2.jmp    = 0xe9;
-      stub->m2.reloc  = ((Bit32u) &__handle_fault) -
-        (stub_mon + sizeof(idt_method2_t));
-      break;
-
-    default:
-      return -1;
-    }
-
-  /* Set the interrupt gate */
-  SET_INT_GATE(vm->host.addr.idt[vec],
-               nullSelector, stub_mon, D_PRESENT, D_DPL0, D_D32);
-  return 0;
-}
-
-
-/*
- *  Map pages allocated by host, into the linear address space of
- *  the monitor/guest, given the Page Table supplied.
- */
-
-  void
-hostMapMonPages(vm_t *vm, Bit32u *pages, unsigned n, Bit32u *laddr_p,
-                page_t *pageTable, unsigned user, unsigned writable, char *name)
-{
-  unsigned i, pti;
-
-
-#if 0
-hostOSPrint("hostMapMonPages: '%s' mapped at 0x%x .. 0x%x.\n",
-            name,
-            (*laddr_p) - MON_BASE_FROM_LADDR(0),
-            ((*laddr_p) + (n*4096)) - MON_BASE_FROM_LADDR(0) );
-#endif
-
-  pti = (*laddr_p >> 12) & 0x3ff;
-  for (i = 0; i < n; i++, pti++) {
-    if (pti > 1024)
-        break;  /* This should not happen! */
-
-    /* Fill in the PTE flags */
-    pageTable->pte[pti].fields.base = pages[i];
-    pageTable->pte[pti].fields.avail = 0;
-    pageTable->pte[pti].fields.G = 0;         /* not global */
-    pageTable->pte[pti].fields.PS = 0;        /* (unused in pte) */
-    pageTable->pte[pti].fields.D = 0;         /* clean */
-    pageTable->pte[pti].fields.A = 0;         /* not accessed */
-    pageTable->pte[pti].fields.PCD = 0;       /* normal caching */
-    pageTable->pte[pti].fields.PWT = 0;       /* normal write-back */
-    pageTable->pte[pti].fields.US = user;     /* 0=system, 1=user */
-    pageTable->pte[pti].fields.RW = writable; /* 0=RO, 1=RW */
-    pageTable->pte[pti].fields.P = 1;         /* present in memory */
-    }
-
-  /*
-   *  Advance linear address pointer, for the next set of pages
-   *  to be mapped.
-   */
-  *laddr_p += 4096 * n;
-}
-
-#if ANAL_CHECKS
-  void
-hostMapBlankPage(vm_t *vm, Bit32u *laddr_p, page_t *pageTable)
-{
-  unsigned pti;
- 
-  pti = (*laddr_p >> 12) & 0x3ff;
-  if (pti > 1024)
-    return;  /* This should not happen! */
- 
-  /* Fill in the PTE flags */
-  pageTable->pte[pti].fields.base = 0;
-  pageTable->pte[pti].fields.avail = 0;
-  pageTable->pte[pti].fields.G = 0;      /* not global */
-  pageTable->pte[pti].fields.PS = 0;     /* (unused in pte) */
-  pageTable->pte[pti].fields.D = 0;      /* clean */
-  pageTable->pte[pti].fields.A = 0;      /* not accessed */
-  pageTable->pte[pti].fields.PCD = 0;    /* normal caching */
-  pageTable->pte[pti].fields.PWT = 0;    /* normal write-back */
-  pageTable->pte[pti].fields.US = 0;
-  pageTable->pte[pti].fields.RW = 0;
-  pageTable->pte[pti].fields.P = 0;
- 
-  /*
-   *  Advance linear address pointer, for the next set of pages
-   *  to be mapped.
-   */
-  *laddr_p += 4096;
-}
-#endif
-
-  int
-hostIoctlGeneric(vm_t *vm, void *inode, void *filp,
-                 unsigned int cmd, unsigned long arg)
-{
-  switch (cmd) {
-
-    /*
-     * Set the guest CPUID info.
-     */
-    case PLEX86_CPUID:
-      {
-      if ( vm->vmState & VMStateGuestCPUID ) {
-        /* Can't change guest CPUID. */
-        return -Plex86ErrnoEINVAL;
-        }
-      if ( hostOSCopyFromUser(&vm->guestCPUIDInfo, (void *)arg,
-                              sizeof(vm->guestCPUIDInfo)) )
-        return -Plex86ErrnoEFAULT;
-/* xxx Value checks here. */
-      vm->vmState |= VMStateGuestCPUID;
-      return 0;
-      }
-
-    case PLEX86_REGISTER_MEMORY:
-      {
-      plex86IoctlRegisterMem_t registerMemMsg;
-      if ( hostOSCopyFromUser(&registerMemMsg, (void *)arg,
-                              sizeof(registerMemMsg)) )
-        return -Plex86ErrnoEFAULT;
-      return( hostIoctlRegisterMem(vm, &registerMemMsg) );
-      }
-
-    /*
-     * Tear down the VM environment.
-     */
-    case PLEX86_TEARDOWN:
-      if ( vm->vmState & VMStateRegisteredAll ) {
-        hostOSPrint("plex86: guest memory is still registered!\n");
-        /* Could effect the unpinning here and then do:
-         *   vm->vmState &= ~VMStateRegisteredAll;
-         */
-        return -Plex86ErrnoEBUSY;
-        }
-
-      hostUnallocVmPages(vm);
-      /* Fixme: deal with state better here. */
-
-      /* Reset state to only FD opened. */
-      vm->vmState = VMStateFDOpened;
-      return 0;
-
-
-    /*
-     * Execute the guest in the VM for a while.  The guest CPU state
-     * is specified in a memory window mmap()'d to user space.
-     */
-    case PLEX86_EXECUTE:
-      {
-      plex86IoctlExecute_t executeMsg;
-      int ret;
-
-      if ( hostOSCopyFromUser(&executeMsg, (void *)arg, sizeof(executeMsg)) )
-        return -Plex86ErrnoEFAULT;
-      ret = hostIoctlExecute(vm, &executeMsg);
-      if ( hostOSCopyToUser((void *)arg, &executeMsg, sizeof(executeMsg)) )
-        return -Plex86ErrnoEFAULT;
-      return ret;
-      }
-
-#warning "PLEX86_RESET should only conditionally compiled for debugging."
-    /*
-     * For debugging, when the module gets hosed, this is a way
-     * to reset the in-use count, so we can rmmod it.
-     */
-    case PLEX86_RESET:
-      hostOSModuleCountReset(vm, inode, filp);
-      return 0;
-
-
-    default:
-      hostOSPrint("plex86: unknown ioctl(%d) called\n", cmd);
-      return -Plex86ErrnoEINVAL;
-    }
-}
-
-  int
-hostIoctlExecute(vm_t *vm, plex86IoctlExecute_t *executeMsg)
-{
-  guest_cpu_t     *guest_cpu;
-  guest_context_t *guest_stack_context;
-  nexus_t *nexus;
-  unsigned s;
-  int retval;
-
-  if ( (vm->vmState != VMStateReady) ||
-       (vm->mon_request != MonReqNone) ) {
-    retval = Plex86NoExecute_VMState; /* Fail. */
-    goto handlePanic;
-    }
-
-  /* Only (virtualized) native execution is supported currently.
-   * Later, it will be interesting to breakpoint one instruction
-   * at-a-time using Plex86ExecuteMethodBreakpoint, for
-   * cosimulation.
-   */
-  if (executeMsg->executeMethod != Plex86ExecuteMethodNative) {
-    retval = Plex86NoExecute_Method; /* Fail. */
-    goto handleFail;
-    }
-
-  /* A pointer to the guest CPU state as passed from host-user space.
-   * This structure is memory mapped between user and kernel/monitor space.
-   */
-  guest_cpu = vm->host.addr.guest_cpu;
-
-  /* A pointer to the guest CPU state saved on the monitor stack. */
-  guest_stack_context =  vm->host.addr.guest_context;
-
-  /* =================================================================
-   * Before executing the guest in the VM, we must check that
-   * the guest conditions meet the requirements of the user-level-only
-   * VM.
-   * =================================================================
-   */
-
-  /* CR0:
-   *   PG(31)==1
-   *   CD(30)==? (look into this later)
-   *   NW(29)==? (look into this later)
-   *   AM(18)==pass-thru from guest
-   *   WP(16)==Don't care.  Monitor always sets this to 1.
-   *   NE( 5)==? (look into this later)
-   *   ET( 4)==? (look into this later)
-   *   TS( 3)==? (look into this later)
-   *   EM( 2)==? (look into this later)
-   *   MP( 1)==? (look into this later)
-   *   PE( 0)==1
-   */
-  /* 0x8005003b */
-  if ( (guest_cpu->cr0.raw & 0xe0000037) != 0x80000033 ) {
-    hostOSPrint("plex86: guest CR0=0x%x\n", guest_cpu->cr0.raw);
-    retval = Plex86NoExecute_CR0; /* Fail. */
-    goto handleFail;
-    }
-
-  /* CR4:
-   *   OSXMMEXCPT(10)==? (look into this later)
-   *   OSFXSR(9)==? (look into this later)
-   *   PCE(8)==? (look into this later)
-   *   PGE(7)==? (look into this later)
-   *   MCE(6)==? (look into this later)
-   *   PAE(5)==? (look into this later)
-   *   PSE(4)==? (look into this later)
-   *   DE(3)==? (look into this later)
-   *   TSD(2)==? (look into this later)
-   *   PVI(1)==? (look into this later)
-   *   VME(0)==? (look into this later)
-   */
-  if ( (guest_cpu->cr4.raw & 0x000007ff) != 0x00000000 ) {
-    hostOSPrint("plex86: guest CR4=0x%x\n", guest_cpu->cr4.raw);
-    retval = Plex86NoExecute_CR4; /* Fail. */
-    goto handleFail;
-    }
-
-  /* Guest CPL must be 3 (user-level).
-   * CS selector must not be NULL.
-   */
-  if ( (guest_cpu->sreg[SRegCS].sel.fields.rpl != 3) ||
-       (guest_cpu->sreg[SRegCS].sel.fields.index == 0) ||
-       (guest_cpu->sreg[SRegCS].des.dpl != 3) ) {
-    retval = Plex86NoExecute_CS; /* Fail. */
-    goto handleFail;
-    }
-
-  /* A20 line must be enabled. */
-  if ( guest_cpu->a20Enable != 1 ) {
-    retval = Plex86NoExecute_A20; /* Fail. */
-    goto handleFail;
-    }
-
-  /* Some code not really used now, since we only support A20 being enabled. */
-  {
-  unsigned newA20Enable;
-  newA20Enable = guest_cpu->a20Enable > 0; /* Make 0 or 1. */
-  if ( newA20Enable != vm->system.a20Enable ) {
-    if ( (!newA20Enable) && guest_cpu->cr0.fields.pg ) {
-      /* A20 disabled, paging on not supported.  Well, really I have to
-       * see if it matters.  This check was in old plex86 code.
-       */
-      retval = Plex86NoExecute_A20; /* Fail. */
-      goto handleFail;
-      }
-    vm->system.a20Enable = newA20Enable;
-    vm->system.a20AddrMask  = 0xffefffff | (newA20Enable << 20);
-    vm->system.a20IndexMask = 0x000ffeff | (newA20Enable << 8);
-    }
-  }
-
-  /* LDT not supported.
-   * Monitor uses GDT slots 1,2,3, so guest segments can not.
-   * Segment descriptor cache DPL should equal 3.
-   */
-  for (s=0; s<6; s++) {
-    unsigned selector = guest_cpu->sreg[s].sel.raw;
-    unsigned index;
-    /* Only care if selector is not NULL. */
-    if ( selector & 0xfffc ) {
-      if ( (selector & 0x0007) != 3 ) {
-        /* Either TI=1 (LDT usage) or RPL!=3. */
-        retval = Plex86NoExecute_Selector; /* Fail. */
-        goto handleFail;
-        }
-      index = selector >> 3;
-      if ( index <= 3 ) {
-        /* Selector index field uses one of the monitor GDT slots. */
-        retval = Plex86NoExecute_Selector; /* Fail. */
-        goto handleFail;
-        }
-      if ( index >= (MON_GDT_SIZE/8) ) {
-        /* Selector index field uses a slot beyond the monitor GDT size. */
-        retval = Plex86NoExecute_Selector; /* Fail. */
-        goto handleFail;
-        }
-      if ( guest_cpu->sreg[s].des.dpl != 3 ) {
-        retval = Plex86NoExecute_DPL; /* Fail. */
-        goto handleFail;
-        }
-      }
-    }
-
-  /* EFlags constraints:
-   *   VIP/VIF==0
-   *   VM==0
-   *   RF==0
-   *   NT==0
-   *   IOPL==0 (We may be able to allow this to be 0..2)
-   *   IF==1
-   *   TF==0
-   *   bit1==1
-   */
-  if ( (guest_cpu->eflags & (0x001b7302)) !=
-       (0x00000202) ) {
-    retval = Plex86NoExecute_EFlags; /* Fail. */
-    goto handleFail;
-    }
-
-  /* Notes on other stuff:
-   *  - CPUID emulation vs virtualization match.
-   */
-
-  /* NOTE: We should commit to executing the guest at this point.
-   *   We must not leave stray entries in the GDT.
-   */
-
-/* Install virtualized guest descriptors in GDT.
- * Either use descriptor caches from guest space, or we have
- * to chase down the GDT entries using the guest's paging
- * system.  Might be a cheaper/safe bet to just use the
- * descriptor caches.  If the guest reloads a descriptor,
- * just let the user space deal with it.
- */
-  for (s=0; s<6; s++) {
-    if ( (guest_cpu->sreg[s].sel.raw & 0xfffc) != 0) {
-      vm->host.addr.gdt[ guest_cpu->sreg[s].sel.fields.index ] =
-          guest_cpu->sreg[s].des;
-      }
-    }
-#warning "Have to clear out GDT"
-
-  guest_stack_context->gs = guest_cpu->sreg[SRegGS].sel.raw;
-  guest_stack_context->fs = guest_cpu->sreg[SRegFS].sel.raw;
-  guest_stack_context->ds = guest_cpu->sreg[SRegDS].sel.raw;
-  guest_stack_context->es = guest_cpu->sreg[SRegES].sel.raw;
-
-  /* Could use memcpy(); both are in order.  Pack both structs. */
-  guest_stack_context->edi = guest_cpu->edi;
-  guest_stack_context->esi = guest_cpu->esi;
-  guest_stack_context->ebp = guest_cpu->ebp;
-  guest_stack_context->dummy_esp = 0; /* Not needed. */
-  guest_stack_context->ebx = guest_cpu->ebx;
-  guest_stack_context->edx = guest_cpu->edx;
-  guest_stack_context->ecx = guest_cpu->ecx;
-  guest_stack_context->eax = guest_cpu->eax;
-
-  /* Fields vector/error are ignored for return to guest. */
-
-  /* CS:EIP */
-  guest_stack_context->eip = guest_cpu->eip;
-  guest_stack_context->cs  = guest_cpu->sreg[SRegCS].sel.raw;
-
-  guest_stack_context->eflags.raw = guest_cpu->eflags;
-  vm->veflags.raw = 0; /* Virtualized EFLAGS - implement later. */
-
-  guest_stack_context->esp = guest_cpu->esp;
-  guest_stack_context->ss  = guest_cpu->sreg[SRegSS].sel.raw;
-
-  /* Pointer to the fields in the nexus.S assembly code. */
-  nexus = vm->host.addr.nexus;
-
-#warning "Monitor CRx hacks"
-  nexus->mon_cr0 = 0x8001003b | /* PG/WP/NE/ET/TS/MP/PE */
-    (guest_cpu->cr0.raw & 0x00040000); /* Pass-thru AM from guest. */
-  /* Could move mon_cr3 load to mapMonitor. */
-  nexus->mon_cr3 = vm->pages.page_dir << 12;
-  nexus->mon_cr4 = 0x00000004; /* TSD=1 */
-
-/* vm->guest_cpu.cr0.raw = guest_cpu->cr0 | 0x32; */ /* +++ hack for now */
-
-// Notes:
-//   - Implement some of monPagingRemap from old code, since that
-//   was intended to be run/triggered by an initial mode change.
-//   - After execution of 1st timeslice, need to copy dynamic state
-//   from VM to guest_cpu area.
-//   - Deal with cycle counts etc.
-
-  hostInitShadowPaging(vm);
-
-  for (;;) {
-    unsigned long eflags;
-
-#if 0
-    /* If print buffer has contents, return to user space to print. */
-    if (vm->log_buffer_info.offset) {
-      vm->mon_msgs.header.msg_type = VMMessagePrintBuf;
-      vm->mon_msgs.header.msg_len  = 0;
-      vm->mon_request = MonReqNone; /* Request satisfied */
-      resetPrintBuf(vm); /* xxx Fix print mess */
-      retval = 100;
-      goto handleFail;
-      }
-#endif
-
-    vm_save_flags(eflags);
-    vm_restore_flags(eflags & ~0x00004300); /* clear NT/IF/TF */
-#if ANAL_CHECKS
-    if (!(eflags & 0x200)) {
-      vm_restore_flags(eflags);
-      hostOSPrint("ioctlExecute: EFLAGS.IF==0\n");
-      retval = 101; /* Fail. */
-      goto handlePanic;
-      }
-#endif
-
-    /* Call assembly routine to effect transition. */
-    vm->host.__host2mon();
-
-    /* First check for an asynchronous event (interrupt redirection) */
-    if ( vm->mon_request == MonReqRedirect ) {
-      vm_restore_flags(eflags & ~0x00000200); /* restore all but IF */
-      soft_int(vm->redirect_vector); /* sets IF to 1 */
-      hostOSInstrumentIntRedirCount(vm->redirect_vector);
-      vm->mon_request = MonReqNone; /* Request satisfied */
-      }
-
-    /* Event was synchronous; monitor requested a switch back to host. */
-    else {
-      vm_restore_flags(eflags);
-
-      /* Perform action requested by monitor. */
-      switch ( vm->mon_request ) {
-        case MonReqRemapMonitor:
-#if 0
-          if ( mapMonitor(vm) ) {
-            vm->mon_request = MonReqNone; /* Request satisfied */
-            break;
-            }
-          else {
-            hostOSPrint("mapMonitor failed.\n");
-            hostOSPrint("Panic w/ abort_code=%u\n", vm->abort_code);
-            retval = 102;
-            goto handlePanic;
-            }
-#endif
-          hostOSPrint("ioctlExecute: case MonReqRemapMonitor.\n");
-          retval = 103;
-          goto handlePanic;
-
-        case MonReqFlushPrintBuf:
-          hostOSPrint("ioctlExecute: case MonReqFlushPrintBuf.\n");
-          retval = 104;
-          goto handlePanic;
-
-        case MonReqGuestFault:
-          /* Encountered a guest fault. */
-          hostCopyGuestStateToUserSpace(vm);
-          executeMsg->cyclesExecuted       = 0; /* Handle later. */
-          executeMsg->instructionsExecuted = 0; /* Handle later. */
-          executeMsg->monitorState.state   = vm->vmState;
-          executeMsg->monitorState.request = vm->mon_request;
-          executeMsg->monitorState.guestFaultNo = vm->guestFaultNo;
-          vm->mon_request = MonReqNone;
-          return 0;
-
-        case MonReqPanic:
-          if (vm->abort_code)
-            hostOSPrint("Panic w/ abort_code=%u\n", vm->abort_code);
-          hostOSPrint("ioctlExecute: case MonReqPanic.\n");
-          retval = 106;
-          goto handlePanic;
-
-        case MonReqPinUserPage:
-          if ( !hostHandlePagePinRequest(vm, vm->pinReqPPI) ) {
-            retval = 108;
-            goto handlePanic;
-            }
-          continue; /* Back to VM monitor. */
-
-        default:
-          hostOSPrint("ioctlExecute: default case (%u).\n", vm->mon_request);
-          retval = 107;
-          goto handlePanic;
-        }
-      }
-
-    /* Let host decide whether we are allowed another timeslice */
-    if ( !hostOSIdle() ) {
-      /* We are returning only because the host wants to
-       * schedule other work.
-       */
-      executeMsg->monitorState.state   = vm->vmState;
-      executeMsg->monitorState.request = MonReqNone;
-      return 0;
-      }
-    }
-
-  /* Should not get here. */
-  retval = 109;
-  goto handlePanic;
-
-handleFail:
-  /* Handle inabilitiy to execute the guest due to certain state. */
-  executeMsg->monitorState.state   = vm->vmState;
-  executeMsg->monitorState.request = vm->mon_request;
-  return(retval);
-
-handlePanic:
-  vm->vmState  |= VMStatePanic;
-  vm->mon_request = MonReqPanic;
-  executeMsg->monitorState.state   = vm->vmState;
-  executeMsg->monitorState.request = vm->mon_request;
-  return(retval);
-}
-
-  void
-hostCopyGuestStateToUserSpace(vm_t *vm)
-{
-  guest_cpu_t     *guest_cpu;
-  guest_context_t *guest_stack_context;
-
-  /* A pointer to the guest CPU state as passed from host-user space.
-   * This structure is memory mapped between user and kernel/monitor space.
-   */
-  guest_cpu = vm->host.addr.guest_cpu;
-
-  /* A pointer to the guest CPU state saved on the monitor stack. */
-  guest_stack_context =  vm->host.addr.guest_context;
-
-  guest_cpu->sreg[SRegES].sel.raw = guest_stack_context->es;
-  if ( (guest_stack_context->es & 0xfffc) == 0 ) {
-    guest_cpu->sreg[SRegES].des = nullDescriptor;
-    guest_cpu->sreg[SRegES].valid = 0;
-    }
-  else {
-    guest_cpu->sreg[SRegES].des =
-      vm->host.addr.gdt[ guest_cpu->sreg[SRegES].sel.fields.index ];
-    guest_cpu->sreg[SRegES].valid = 1;
-    }
-
-  guest_cpu->sreg[SRegCS].sel.raw = guest_stack_context->cs;
-  if ( (guest_stack_context->cs & 0xfffc) == 0 ) {
-    guest_cpu->sreg[SRegCS].des = nullDescriptor;
-    guest_cpu->sreg[SRegCS].valid = 0;
-    }
-  else {
-    guest_cpu->sreg[SRegCS].des =
-      vm->host.addr.gdt[ guest_cpu->sreg[SRegCS].sel.fields.index ];
-    guest_cpu->sreg[SRegCS].valid = 1;
-    }
-
-  guest_cpu->sreg[SRegSS].sel.raw = guest_stack_context->ss;
-  if ( (guest_stack_context->ss & 0xfffc) == 0 ) {
-    guest_cpu->sreg[SRegSS].des = nullDescriptor;
-    guest_cpu->sreg[SRegSS].valid = 0;
-    }
-  else {
-    guest_cpu->sreg[SRegSS].des =
-      vm->host.addr.gdt[ guest_cpu->sreg[SRegSS].sel.fields.index ];
-    guest_cpu->sreg[SRegSS].valid = 1;
-    }
-
-  guest_cpu->sreg[SRegDS].sel.raw = guest_stack_context->ds;
-  if ( (guest_stack_context->ds & 0xfffc) == 0 ) {
-    guest_cpu->sreg[SRegDS].des = nullDescriptor;
-    guest_cpu->sreg[SRegDS].valid = 0;
-    }
-  else {
-    guest_cpu->sreg[SRegDS].des =
-      vm->host.addr.gdt[ guest_cpu->sreg[SRegDS].sel.fields.index ];
-    guest_cpu->sreg[SRegDS].valid = 1;
-    }
-
-  guest_cpu->sreg[SRegFS].sel.raw = guest_stack_context->fs;
-  if ( (guest_stack_context->fs & 0xfffc) == 0 ) {
-    guest_cpu->sreg[SRegFS].des = nullDescriptor;
-    guest_cpu->sreg[SRegFS].valid = 0;
-    }
-  else {
-    guest_cpu->sreg[SRegFS].des =
-      vm->host.addr.gdt[ guest_cpu->sreg[SRegFS].sel.fields.index ];
-    guest_cpu->sreg[SRegFS].valid = 1;
-    }
-
-  guest_cpu->sreg[SRegGS].sel.raw = guest_stack_context->gs;
-  if ( (guest_stack_context->gs & 0xfffc) == 0 ) {
-    guest_cpu->sreg[SRegGS].des = nullDescriptor;
-    guest_cpu->sreg[SRegGS].valid = 0;
-    }
-  else {
-    guest_cpu->sreg[SRegGS].des =
-      vm->host.addr.gdt[ guest_cpu->sreg[SRegGS].sel.fields.index ];
-    guest_cpu->sreg[SRegGS].valid = 1;
-    }
-
-  /* Could use memcpy(); both are in order.  Pack both structs. */
-  guest_cpu->edi = guest_stack_context->edi;
-  guest_cpu->esi = guest_stack_context->esi;
-  guest_cpu->ebp = guest_stack_context->ebp;
-  guest_cpu->esp = guest_stack_context->esp;
-  guest_cpu->ebx = guest_stack_context->ebx;
-  guest_cpu->edx = guest_stack_context->edx;
-  guest_cpu->ecx = guest_stack_context->ecx;
-  guest_cpu->eax = guest_stack_context->eax;
-
-  /* CS:EIP */
-  guest_cpu->eip = guest_stack_context->eip;
-
-  guest_cpu->eflags = guest_stack_context->eflags.raw;
-  /* vm->veflags.raw = 0; */ /* Virtualized EFLAGS - implement later. */
-}
-
-
-  int
-hostIoctlRegisterMem(vm_t *vm, plex86IoctlRegisterMem_t *registerMemMsg)
-{
-  unsigned error;
-
-  /* Do not allow duplicate allocation.  The file descriptor must be
-   * opened.  The guest CPUID info can be filled in later.
-   */
-  if ( (vm->vmState & ~VMStateGuestCPUID) != VMStateFDOpened )
-    return -Plex86ErrnoEBUSY;
-
-  if (vm->pages.guest_n_megs != 0)
-    return -Plex86ErrnoEBUSY;
-
-  /* Check that the amount of memory is reasonable. */
-  if ( (registerMemMsg->nMegs > PLEX86_MAX_PHY_MEGS)  ||
-       (registerMemMsg->nMegs < 4) ||
-       (registerMemMsg->nMegs & 0x3) )
-    return -Plex86ErrnoEINVAL;
-
-  /* Check that the guest memory vector is page aligned. */
-  if ( registerMemMsg->guestPhyMemVector & 0xfff )
-    return -Plex86ErrnoEINVAL;
-
-  /* Check that the log buffer area is page aligned. */
-  if ( registerMemMsg->logBufferWindow & 0xfff )
-    return -Plex86ErrnoEINVAL;
-
-  /* Check that the guest CPU area is page aligned. */
-  if ( registerMemMsg->guestCPUWindow & 0xfff )
-    return -Plex86ErrnoEINVAL;
-
-  /* Check that none of the user areas overlap.  In case we have a
-   * number of regions, use some generic code to handle N regions.
-   */
-  {
-#define NumUserRegions 3
-  struct {
-    Bit32u min, max;
-    } userRegion[NumUserRegions];
-  unsigned i,j;
-
-  userRegion[0].min = registerMemMsg->guestPhyMemVector;
-  userRegion[0].max = userRegion[0].min + (registerMemMsg->nMegs<<20) - 1;
-  userRegion[1].min = registerMemMsg->logBufferWindow;
-  userRegion[1].max = userRegion[1].min + LOG_BUFF_SIZE - 1;
-  userRegion[2].min = registerMemMsg->guestCPUWindow;
-  userRegion[2].max = userRegion[2].min + (4096) - 1;
-
-  for (i=1; i<NumUserRegions; i++) {
-    for (j=1; j<NumUserRegions; j++) {
-      if (j == i)
-        continue; /* Don't compare at the same region. */
-      /* Check for min(j) contained in region(i). */
-      if ( (userRegion[j].min >= userRegion[i].min) &&
-           (userRegion[j].min <= userRegion[i].max) )
-        return -Plex86ErrnoEINVAL;
-      /* Check for max(j) contained in region(i). */
-      if ( (userRegion[j].max >= userRegion[i].min) &&
-           (userRegion[j].max <= userRegion[i].max) )
-        return -Plex86ErrnoEINVAL;
-      }
-    }
-  }
-
-
-
-  /* Allocate memory */
-  if ( (error = hostAllocVmPages(vm, registerMemMsg)) != 0 ) {
-    hostOSPrint("plex86: allocVmPages failed at %u\n",
-                error);
-    return -Plex86ErrnoENOMEM;
-    }
-
-  /* Initialize the guests physical memory. */
-  if ( hostInitGuestPhyMem(vm) ) {
-    hostUnallocVmPages(vm);
-    return -Plex86ErrnoEFAULT;
-    }
-
-  /* Initialize the monitor. */
-  if ( !hostInitMonitor(vm) ||
-       !hostMapMonitor(vm) ) {
-    hostUnallocVmPages(vm);
-    return -Plex86ErrnoEFAULT;
-    }
-  return 0;
-}
-
-
-
-/*
- * Allocate various pages/memory needed by monitor.
- */
-
-  int
-hostAllocVmPages(vm_t *vm, plex86IoctlRegisterMem_t *registerMemMsg)
-{
-  vm_pages_t *pg = &vm->pages;
-  vm_addr_t  *ad = &vm->host.addr;
-#warning "Fix these shortcuts"
-  unsigned where = 1;
-
-  /* clear out allocated pages lists */
-  mon_memzero(pg, sizeof(*pg));
-  mon_memzero(ad, sizeof(*ad));
-
-  /* Guest physical memory pages */
-  pg->guest_n_megs  = registerMemMsg->nMegs;
-  pg->guest_n_pages = registerMemMsg->nMegs * 256;
-  pg->guest_n_bytes = registerMemMsg->nMegs * 1024 * 1024;
-  if ( pg->guest_n_pages > MAX_MON_GUEST_PAGES) {
-    /* The size of the user-space allocated guest physical memory must
-     * fit within the maximum number of guest pages that the VM monitor
-     * supports.
-     */
-    goto error;
-    }
-  where++;
-
-  vm->guestPhyMemAddr = registerMemMsg->guestPhyMemVector;
-  vm->vmState |= VMStateRegisteredPhyMem; /* Bogus for now. */
-  where++;
-
-  {
-  Bit32u hostPPI, kernelAddr;
-
-  /* Guest CPU state (malloc()'d in user space). */
-  if ( !hostOSGetAndPinUserPage(vm, registerMemMsg->guestCPUWindow,
-            &pg->guest_cpu_hostOSPtr, &hostPPI, &kernelAddr) ) {
-    goto error;
-    }
-  ad->guest_cpu = (guest_cpu_t *) kernelAddr;
-  pg->guest_cpu = hostPPI;
-vm->vmState |= VMStateRegisteredGuestCPU; /* For now. */
-  where++;
-
-  /* Log buffer area (malloc()'d in user space). */
-  /* LOG_BUFF_PAGES */
-  if ( !hostOSGetAndPinUserPage(vm, registerMemMsg->logBufferWindow,
-            &pg->log_buffer_hostOSPtr[0], &hostPPI, &kernelAddr) ) {
-    goto error;
-    }
-  ad->log_buffer = (Bit8u *) kernelAddr;
-  pg->log_buffer[0] = hostPPI;
-  where++;
-vm->vmState |= VMStateRegisteredPrintBuffer; /* For now. */
-  }
-
-
-  /* Monitor page directory */
-  if ( !(ad->page_dir = (pageEntry_t *) hostOSAllocZeroedPage()) ) {
-    goto error;
-    }
-  where++;
-  if (!(pg->page_dir = hostOSGetAllocedPagePhyPage(ad->page_dir))) {
-    goto error;
-    }
-  where++;
-
-  /* Monitor page tables */
-  if ( !(ad->page_tbl = hostOSAllocZeroedMem(4096 * MON_PAGE_TABLES)) ) {
-    goto error;
-    }
-  where++;
-  if (!hostOSGetAllocedMemPhyPages(pg->page_tbl, MON_PAGE_TABLES, 
-           ad->page_tbl, 4096 * MON_PAGE_TABLES)) {
-    goto error;
-    }
-  where++;
-
-  /* Map of the linear addresses of page tables currently */
-  /* mapped into the monitor space. */
-  if ( !(ad->page_tbl_laddr_map = (unsigned *) hostOSAllocZeroedPage()) ) {
-    goto error;
-    }
-  where++;
-  if ( !(pg->page_tbl_laddr_map =
-         hostOSGetAllocedPagePhyPage(ad->page_tbl_laddr_map)) ) {
-    goto error;
-    }
-  where++;
-
-  /* Nexus page table */
-  if ( !(ad->nexus_page_tbl = (page_t *) hostOSAllocZeroedPage()) ) {
-    goto error;
-    }
-  where++;
-  if ( !(pg->nexus_page_tbl = hostOSGetAllocedPagePhyPage(ad->nexus_page_tbl)) ) {
-    goto error;
-    }
-  where++;
-
-  /* Transition page table */
-  if ( !(ad->transition_PT = (page_t *) hostOSAllocZeroedPage()) ) {
-    goto error;
-    }
-  where++;
-  if ( !(pg->transition_PT = hostOSGetAllocedPagePhyPage(ad->transition_PT)) ) {
-    goto error;
-    }
-  where++;
-
-  /* Nexus page */
-  if ( !(ad->nexus = (nexus_t *) hostOSAllocZeroedPage()) ) {
-    goto error;
-    }
-  where++;
-  if ( !(pg->nexus = hostOSGetAllocedPagePhyPage(ad->nexus)) ) {
-    goto error;
-    }
-  where++;
-
-  /* Monitor IDT */
-  if ( !(ad->idt = hostOSAllocZeroedMem(MON_IDT_PAGES*4096)) ) {
-    goto error;
-    }
-  where++;
-  if (!hostOSGetAllocedMemPhyPages(pg->idt, MON_IDT_PAGES, ad->idt, MON_IDT_SIZE)) {
-    goto error;
-    }
-  where++;
-
-  /* Monitor GDT */
-  if ( !(ad->gdt = hostOSAllocZeroedMem(MON_GDT_PAGES*4096)) ) {
-    goto error;
-    }
-  where++;
-  if (!hostOSGetAllocedMemPhyPages(pg->gdt, MON_GDT_PAGES, ad->gdt, MON_GDT_SIZE)) {
-    goto error;
-    }
-  where++;
-
-  /* Monitor LDT */
-  if ( !(ad->ldt = hostOSAllocZeroedMem(MON_LDT_PAGES*4096)) ) {
-    goto error;
-    }
-  where++;
-  if (!hostOSGetAllocedMemPhyPages(pg->ldt, MON_LDT_PAGES, ad->ldt, MON_LDT_SIZE)) {
-    goto error;
-    }
-  where++;
-
-  /* Monitor TSS */
-  if ( !(ad->tss = hostOSAllocZeroedMem(MON_TSS_PAGES*4096)) ) {
-    goto error;
-    }
-  where++;
-  if (!hostOSGetAllocedMemPhyPages(pg->tss, MON_TSS_PAGES, ad->tss, MON_TSS_SIZE)) {
-    goto error;
-    }
-  where++;
-
-  /* Monitor IDT stubs */
-  if ( !(ad->idt_stubs = hostOSAllocZeroedMem(MON_IDT_STUBS_PAGES*4096)) ) {
-    goto error;
-    }
-  where++;
-  if (!hostOSGetAllocedMemPhyPages(pg->idt_stubs, MON_IDT_STUBS_PAGES, 
-           ad->idt_stubs, MON_IDT_STUBS_SIZE)) {
-    goto error;
-    }
-  where++;
-
-  /* Get the physical pages associated with the vm_t structure. */
-  if (!hostOSGetAllocedMemPhyPages(pg->vm, MAX_VM_STRUCT_PAGES, vm, sizeof(*vm))) {
-    goto error;
-    }
-  where++;
-
-  vm->vmState |= VMStateMemAllocated;
-  return 0; /* OK. */
-
- error:
-    hostUnallocVmPages( vm );
-    return( where );
-}
-
-
-/* */
-/* Unallocate pages/memory used by monitor */
-/* */
-
-  void
-hostUnallocVmPages( vm_t *vm )
-{
-  vm_pages_t *pg = &vm->pages;
-  vm_addr_t  *ad = &vm->host.addr;
-
-  /* Guest physical memory pages */
-  if (vm->guestPhyMemAddr) {
-    hostReleasePinnedUserPages(vm);
-    vm->guestPhyMemAddr = 0;
-    }
-  vm->vmState &= ~VMStateRegisteredPhyMem; /* Bogus for now. */
-
-  /* Monitor page directory */
-  if (ad->page_dir) hostOSFreePage(ad->page_dir);
-
-  /* Monitor page tables */
-  if (ad->page_tbl) hostOSFreeMem(ad->page_tbl);
-
-  /* Map of linear addresses of page tables mapped into monitor. */
-  if (ad->page_tbl_laddr_map) hostOSFreePage(ad->page_tbl_laddr_map);
-
-  /* Nexus page table */
-  if (ad->nexus_page_tbl) hostOSFreePage(ad->nexus_page_tbl);
-
-  /* Guest CPU state. */
-  if (ad->guest_cpu) hostOSFreePage(ad->guest_cpu);
-
-  /* Transition page table */
-  if (ad->transition_PT) hostOSFreePage(ad->transition_PT);
-
-  if (ad->log_buffer) hostOSFreeMem(ad->log_buffer);
-
-  /* Nexus page */
-  if (ad->nexus) hostOSFreePage(ad->nexus);
-
-  /* Monitor IDT */
-  if (ad->idt) hostOSFreeMem(ad->idt);
-
-  /* Monitor GDT */
-  if (ad->gdt) hostOSFreeMem(ad->gdt);
-
-  /* Monitor LDT */
-  if (ad->ldt) hostOSFreeMem(ad->ldt);
-
-  /* Monitor TSS */
-  if (ad->tss) hostOSFreeMem(ad->tss);
-
-  /* Monitor IDT stubs */
-  if (ad->idt_stubs) hostOSFreeMem(ad->idt_stubs);
-
-
-  /* clear out allocated pages lists */
-  mon_memzero(pg, sizeof(*pg));
-  mon_memzero(ad, sizeof(*ad));
-}
-
-  unsigned
-hostGetCpuCapabilities(void)
-{
-  Bit32u eax, ebx, ecx, edx;
-
-  /* Get the highest allowed cpuid level */
-  asm volatile (
-    "xorl %%eax,%%eax\n\t"
-    "cpuid"
-    : "=a" (eax), "=b" (ebx), "=c" (ecx), "=d" (edx)
-    :
-    : "cc"
-    );
-  if (eax < 1)
-    return(0); /* not enough capabilities */
-
-  /* Copy vendor string. */
-  hostCpuIDInfo.vendorDWord0 = ebx;
-  hostCpuIDInfo.vendorDWord1 = edx;
-  hostCpuIDInfo.vendorDWord2 = ecx;
-
-  /* CPUID w/ EAX==1: Processor Signature & Feature Flags */
-  asm volatile (
-    "movl $1,%%eax\n\t"
-    "cpuid"
-    : "=a" (eax), "=b" (ebx), "=c" (ecx), "=d" (edx)
-    :
-    : "cc"
-    );
-  hostCpuIDInfo.procSignature.raw = eax;
-  hostCpuIDInfo.featureFlags.raw = edx;
-  /* Plex86 needs TSC */
-  if (hostCpuIDInfo.featureFlags.fields.tsc==0)
-    return(0);
-
-  return(1);
-}
-
-
-/* Map the monitor and guest into the VM. */
-
-  unsigned
-hostMapMonitor(vm_t *vm)
-{
-  selector_t monCsSel, monSsSel, monTssSel;
-  Bit32u laddr, base;
-  unsigned slot;
-  guest_context_t *guestContext;
-  nexus_t *nexus;
-  descriptor_t *gdt;
-
-  /* For convenience, some pointers. */
-  guestContext = vm->host.addr.guest_context;
-  nexus        = vm->host.addr.nexus;
-  gdt          = vm->host.addr.gdt;
-
-#warning "Is the GDT being cleared of old values?"
-/* +++ should zero out GDT, so prev entries do not remain */
-
-  /* =========================
-   * Map in Monitor structures
-   * =========================
-   */
-
-  /* CS/SS/TSS selectors:
-   * For now, hardcode in monitor descriptors at slots 1,2,3.  As we
-   * are only running user code in the VM, these are likely safe slots
-   * as they are often used guest OSes for kernel descriptors.
-   */
-  monCsSel.raw     = Selector(1, 0, RPL0);
-  monSsSel.raw     = Selector(2, 0, RPL0);
-  monTssSel.raw    = Selector(3, 0, RPL0);
-
-  /* Search for unused PDE for nexus PT  (fixed for now) */
-  laddr = 0x70000000;
-  vm->mon_pde_mask = laddr & 0xffc00000;
-  vm->mon_pdi      = laddr >> 22;
-  base = MON_BASE_FROM_LADDR(laddr);
-
-  /* Map nexus into monitor/guest address space */
-  vm->host.addr.page_dir[laddr >> 22] = vm->host.nexus_pde;
-
-  /* CS/SS/TSS descriptors: Put at fixed GDT location for now. */
-  SET_DESCRIPTOR(gdt[monCsSel.fields.index], base, 0xfffff, 
-                 D_PG, D_D32, D_AVL0, D_PRESENT, D_DPL0, D_CODE | D_READ)
-  SET_DESCRIPTOR(gdt[monSsSel.fields.index], base, 0xfffff, 
-                 D_PG, D_D32, D_AVL0, D_PRESENT, D_DPL0, D_DATA | D_WRITE)
-  SET_DESCRIPTOR(gdt[monTssSel.fields.index],
-                 base + (Bit32u) vm->guest.addr.tss,
-                 sizeof(tss_t)-1,
-                 D_BG, 0, D_AVL0, D_PRESENT, D_DPL0, D_TSS)
-
-
-  /* Fix up the selectors of all IDT entries. */
-  for ( slot = 0; slot < 256; slot++ )
-      vm->host.addr.idt[slot].selector = monCsSel;
-
-  /* The monitor GDT/IDT loading info. */
-  nexus->mon_gdt_info.base  = base + (Bit32u) vm->guest.addr.gdt;
-  nexus->mon_gdt_info.limit = MON_GDT_SIZE;
-  nexus->mon_idt_info.base  = base + (Bit32u) vm->guest.addr.idt;
-  nexus->mon_idt_info.limit = MON_IDT_SIZE;
-
-  /* We don't have a monitor LDT for now. */
-  nexus->mon_ldt_sel = 0;
-
-  /* The monitor TSS. */
-  nexus->mon_tss_sel = monTssSel.raw;
-  vm->host.addr.tss->esp0 = ((Bit32u)vm->guest.addr.nexus) + PAGESIZE;
-  vm->host.addr.tss->ss0  = monSsSel.raw;
-
-  /* Monitor code and stack segments. */
-  nexus->mon_jmp_info.selector   = monCsSel.raw;
-  nexus->mon_stack_info.selector = monSsSel.raw;
-
-  /* Monitor code/data segment base. */
-  nexus->mon_base = base;
-
-  vm->vmState |= VMStateMapMonitor;
-  return(1);
-}
-
-  void
-hostInitShadowPaging(vm_t *vm)
-{
-  pageEntry_t *monPDir;
-  Bit32u pdi;
-/*Bit32u cr3_page_index;*/
-/*phy_page_usage_t *pusage;*/
-
-#if 0
-  cr3_page_index = A20Addr(vm, vm->guest_cpu.cr3) >> 12;
-  if ( cr3_page_index >= vm->pages.guest_n_pages)
-    xxxpanic(vm, "monPagingRemap: CR3 conflicts with monitor space\n");
-#endif
-
-  /* Reset page table heap */
-  vm->ptbl_laddr_map_i = 0;
-
-  /* Clear monitor PD except 4Meg range used by monitor */
-  monPDir = vm->host.addr.page_dir;
-  for (pdi=0; pdi<1024; pdi++) {
-#if ANAL_CHECKS
-    vm->host.addr.page_tbl_laddr_map[pdi] = -1; /* max unsigned */
-#endif
-    if (pdi != vm->mon_pdi)
-      monPDir[pdi].raw = 0;
-    }
-
-  /* Update vpaging timestamp. */
-  vm->vpaging_tsc = vm_rdtsc();
-
-#if 0
-  /* When we remap the monitor page tables, IF guest paging is
-   * enabled, then mark the page containing the guest page directory
-   * as such.  In non-paged mode, there is no page directory.
-   */
-  if (vm->guest_cpu.cr0.fields.pg) {
-    pusage = &vm->pageInfo[cr3_page_index];
-    pusage->tsc = vm->vpaging_tsc;
-    pusage->attr.raw &= PageUsageSticky;
-    pusage->attr.raw |= PageUsagePDir;
-    pusage->attr.fields.access_perm = PagePermNA;
-    if (pusage->attr.raw & PageBadUsage4PDir)
-      xxxpanic(vm, "monPagingRemap: BadUsage4PDir\n");
-    }
-#endif
-}
-
-
-  void
-hostReleasePinnedUserPages(vm_t *vm)
-{
-  unsigned ppi;
-  unsigned dirty;
-  unsigned nPages;
-  Bit32u kernelAddr;
-
-  /* Unpin the pages associate with the guest physical memory. */
-  nPages = vm->pages.guest_n_pages;
-  for (ppi=0; ppi<nPages; ppi++) {
-    if ( vm->pageInfo[ppi].attr.fields.pinned ) {
-      void *osSpecificPtr;
-
-      osSpecificPtr = (void *) vm->hostStructPagePtr[ppi];
-#warning "Conditionalize page dirtying before page release."
-      dirty = 1; /* FIXME: 1 for now. */
-      hostOSUnpinUserPage(vm,
-          vm->guestPhyMemAddr + (ppi<<12),
-          osSpecificPtr,
-          ppi,
-          0 /* There was no host kernel addr mapped for this page. */,
-          dirty);
-      vm->pageInfo[ppi].attr.fields.pinned = 0;
-      }
-    }
-
-  /* Unpin the pages associated with the guest_cpu area. */
-  kernelAddr = (Bit32u) vm->host.addr.guest_cpu;
-  hostOSUnpinUserPage(vm,
-      0, /* User space address. */
-      vm->pages.guest_cpu_hostOSPtr,
-      vm->pages.guest_cpu,
-      &kernelAddr,
-      1 /* Dirty. */);
-
-  /* Unpin the pages associated with the log buffer area. */
-  kernelAddr = (Bit32u) vm->host.addr.log_buffer;
-  hostOSUnpinUserPage(vm,
-      0, /* User space address. */
-      vm->pages.log_buffer_hostOSPtr[0],
-      vm->pages.log_buffer[0],
-      &kernelAddr,
-      1 /* Dirty. */);
-#warning "User space address is passed as 0 for now..."
-}
-
-  unsigned
-hostHandlePagePinRequest(vm_t *vm, Bit32u reqGuestPPI)
-{
-  Bit32u hostPPI;
-  unsigned qIndex;
-
-#warning "We must not unpin open pages (for page walking) here."
-  if (vm->guestPhyPagePinQueue.nEntries < MaxPhyPagesPinned) {
-    /* There is room in the Q for another entry - we have not reached
-     * the upper limit of allowable number of pinned pages.
-     */
-    qIndex = vm->guestPhyPagePinQueue.nEntries;
-    }
-  else {
-    unsigned dirty;
-    Bit32u unpinGuestPPI;
-    /* There is no room in the Q for another entry - we have reached
-     * the upper limit of allowable number of pinned pages.  We must
-     * first unpin a page to free up the limit, then we can pin the
-     * requested page.  This keeps plex86 from pinning an unconstrained
-     * number of pages at one time.
-     */
-    qIndex = vm->guestPhyPagePinQueue.tail;
-    dirty = 1; /* FIXME: 1 for now. */
-    unpinGuestPPI = vm->guestPhyPagePinQueue.ppi[qIndex];
-    hostOSUnpinUserPage(vm,
-        vm->guestPhyMemAddr + (unpinGuestPPI<<12),
-        vm->hostStructPagePtr[unpinGuestPPI],
-        unpinGuestPPI,
-        0 /* There was no host kernel addr mapped for this page. */,
-        dirty);
-    vm->pageInfo[unpinGuestPPI].attr.fields.pinned = 0;
-    }
-
-  /* Pin the requested guest physical page in the host OS. */
-  if ( !hostOSGetAndPinUserPage(vm,
-            vm->guestPhyMemAddr + (reqGuestPPI<<12),
-            &vm->hostStructPagePtr[reqGuestPPI],
-            &hostPPI,
-            0 /* Don't need a host kernel address. */
-            ) ) {
-    hostOSPrint("handlePagePinReq: request to pin failed.\n");
-    return(0); /* Fail. */
-    }
-
-  /* Pinning activities have succeeded.  Mark this physical page as being
-   * pinnned, and store it's physical address.
-   */
-  vm->pageInfo[reqGuestPPI].attr.fields.pinned = 1;
-  vm->pageInfo[reqGuestPPI].hostPPI = hostPPI;
-
-  /* Now add this entry to the Q. */
-  vm->guestPhyPagePinQueue.ppi[qIndex] = reqGuestPPI;
-
-  if (vm->guestPhyPagePinQueue.nEntries < MaxPhyPagesPinned) {
-    vm->guestPhyPagePinQueue.nEntries++;
-    vm->guestPhyPagePinQueue.tail =
-        vm->guestPhyPagePinQueue.nEntries % MaxPhyPagesPinned;
-    }
-  else {
-    /* Leave .nEntries at the maximum value - Q is full. */
-    vm->guestPhyPagePinQueue.tail =
-        (vm->guestPhyPagePinQueue.tail + 1) % MaxPhyPagesPinned;
-    }
-
-  return(1); /* OK. */
-}
diff -Nur bochs-2.0.2+20030829.old/plex86/kernel/monitor-mon.c bochs-2.0.2+20030829/plex86/kernel/monitor-mon.c
--- bochs-2.0.2+20030829.old/plex86/kernel/monitor-mon.c	2003-01-09 04:02:31.000000000 +0000
+++ bochs-2.0.2+20030829/plex86/kernel/monitor-mon.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,63 +0,0 @@
-/*
- *  plex86: run multiple x86 operating systems concurrently
- *  Copyright (C) 1999-2003 Kevin P. Lawton
- *
- *  system-mon.c: The 'motherboard' logic which connects the entire
- *    PC system.
- *
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Lesser General Public
- *  License as published by the Free Software Foundation; either
- *  version 2 of the License, or (at your option) any later version.
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- */
-
-#include "plex86.h"
-#define IN_MONITOR_SPACE
-#include "monitor.h"
-
-  void
-sysFlushPrintBuf(vm_t *vm)
-{
-  CLI();
-  vm->mon_request = MonReqFlushPrintBuf;
-  vm->guest.__mon2host();
-  STI();
-}
-
-  void
-sysRemapMonitor(vm_t *vm)
-{
-  CLI();
-  vm->mon_request = MonReqRemapMonitor;
-  vm->guest.__mon2host();
-  STI();
-}
-
-  void
-toHostGuestFault(vm_t *vm, unsigned fault)
-{
-  CLI();
-  vm->mon_request = MonReqGuestFault;
-  vm->guestFaultNo = fault;
-  vm->guest.__mon2host();
-  STI();
-}
-
-  void
-toHostPinUserPage(vm_t *vm, Bit32u ppi)
-{
-  CLI();
-  vm->mon_request = MonReqPinUserPage;
-  vm->pinReqPPI = ppi;
-  vm->guest.__mon2host();
-  STI();
-}
diff -Nur bochs-2.0.2+20030829.old/plex86/kernel/nexus.S bochs-2.0.2+20030829/plex86/kernel/nexus.S
--- bochs-2.0.2+20030829.old/plex86/kernel/nexus.S	2003-01-01 17:32:04.000000000 +0000
+++ bochs-2.0.2+20030829/plex86/kernel/nexus.S	1970-01-01 00:00:00.000000000 +0000
@@ -1,326 +0,0 @@
-/*
- *  plex86: run multiple x86 operating systems concurrently
- *  Copyright (C) 1999-2001  Kevin P. Lawton
- *
- *  nexus.S: code to transition between host and monitor/guest
- *
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Lesser General Public
- *  License as published by the Free Software Foundation; either
- *  version 2 of the License, or (at your option) any later version.
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- */
-
-
-
-.text
-
-
-/* This module consists of relocatable code and data necessary to
- * effect transitions between the host <--> guest.  This information
- * is purposely stored in this single page, so that we have access
- * to it during our transitions between the monitor interrupt handler,
- * and our host.
- *
- * I coded the relevant parts to use completely relocatable
- * accesses to the following fields.  This is necessary, so that
- * we can float this code page anywhere in the monitor's linear
- * address space.
- */
-
-/* ===============================================================
- * NOTE: If you modify ANY of the following fields, you must also
- * update the corresponding entries in the C typedef 'nexus_t'.
- * That construct is used from C land to access values in this
- * relocatable page.
- */
-
-.globl __nexus_start
-__nexus_start:
-
-__vm:              ;.skip 4, 0
-
-__host_gdt_info:   ;.skip 6, 0
-__host_idt_info:   ;.skip 6, 0
-__host_jmp_info:   ;.skip 6, 0
-__host_stack_info: ;.skip 6, 0
-__host_ldt_sel:    ;.skip 2, 0
-__host_tss_sel:    ;.skip 2, 0
-__host_cr0:        ;.skip 4, 0
-__host_cr2:        ;.skip 4, 0
-__host_cr3:        ;.skip 4, 0
-__host_cr4:        ;.skip 4, 0
-
-__mon_gdt_info:    ;.skip 6, 0
-__mon_idt_info:    ;.skip 6, 0
-__mon_jmp_info:    ;.skip 6, 0
-__mon_stack_info:  ;.skip 6, 0
-__mon_ldt_sel:     ;.skip 2, 0
-__mon_tss_sel:     ;.skip 2, 0
-__mon_base:        ;.skip 4, 0
-__mon_cr0:         ;.skip 4, 0
-__mon_cr3:         ;.skip 4, 0
-__mon_cr4:         ;.skip 4, 0
-__mon_eflags:      ;.skip 4, 0
-
-__transition_pde:        ;.skip 4, 0
-__transition_pde_p_host: ;.skip 4, 0
-__transition_pde_p_mon:  ;.skip 4, 0
-__transition_laddr:      ;.skip 4, 0
-
-/* ===============================================================
- * End NOTE.
- */
-
-#define OFFSET_OF(field)  [field - __nexus_start]
-
-/* These are the offsets of the structures above, from the */
-/* beginning of this section. */
-#define HOST_GDT_INFO       OFFSET_OF(__host_gdt_info)
-#define HOST_IDT_INFO       OFFSET_OF(__host_idt_info)
-#define HOST_JMP_INFO       OFFSET_OF(__host_jmp_info)
-#define HOST_STACK_INFO     OFFSET_OF(__host_stack_info)
-#define HOST_LDT_SEL        OFFSET_OF(__host_ldt_sel)
-#define HOST_TSS_SEL        OFFSET_OF(__host_tss_sel)
-#define HOST_CR0            OFFSET_OF(__host_cr0)
-#define HOST_CR2            OFFSET_OF(__host_cr2)
-#define HOST_CR3            OFFSET_OF(__host_cr3)
-#define HOST_CR4            OFFSET_OF(__host_cr4)
-
-#define MON_GDT_INFO        OFFSET_OF(__mon_gdt_info)
-#define MON_IDT_INFO        OFFSET_OF(__mon_idt_info)
-#define MON_JMP_INFO        OFFSET_OF(__mon_jmp_info)
-#define MON_STACK_INFO      OFFSET_OF(__mon_stack_info)
-#define MON_LDT_SEL         OFFSET_OF(__mon_ldt_sel)
-#define MON_TSS_SEL         OFFSET_OF(__mon_tss_sel)
-#define MON_CR0             OFFSET_OF(__mon_cr0)
-#define MON_CR3             OFFSET_OF(__mon_cr3)
-#define MON_CR4             OFFSET_OF(__mon_cr4)
-#define MON_BASE            OFFSET_OF(__mon_base)
-
-#define TRANSITION_PDE        OFFSET_OF(__transition_pde)
-#define TRANSITION_PDE_P_HOST OFFSET_OF(__transition_pde_p_host)
-#define TRANSITION_PDE_P_MON  OFFSET_OF(__transition_pde_p_mon)
-#define TRANSITION_LADDR      OFFSET_OF(__transition_laddr)
-
-
-/* To make this code page and data accesses to the fields above */
-/* relocatable, I use the following conventions.  I load EBX with */
-/* a pointer to the beginning of this page, to be used with an */
-/* access through the CS: segment.  We can easily get the */
-/* current EIP with a call/pop EBX, so the combination of CS:EBX, */
-/* accesses this page no matter where it is located. */
-
-
-/* ================================================================== */
-.globl __host2mon      /* Start function __host2mon() */
-__host2mon:
-  /* Save host context first, so it can be restored later */
-  pushfl               /* Save host flags */
-  pushal               /* Save host general regs */
-  pushl %es            /* Save host segments */
-  pushl %ds
-  pushl %fs
-  pushl %gs
-
-  /* Put EIP of beginning of this section in EBX to be used to */
-  /* access data. */
-  call null_call
-null_call:
-  popl %ebx
-  subl $(OFFSET_OF(null_call)), %ebx
-
-  /* Create identity mapping of this page into the monitor context */
-  movl  (TRANSITION_PDE_P_HOST)(%ebx), %eax
-  movl  (TRANSITION_PDE)(%ebx), %ebp
-  xchgl %ebp, (%eax)  /* old PDE saved in %ebp to be restored below */
-
-  /* Save host GDT, LDT, IDT, and TSS */
-  sgdt  (HOST_GDT_INFO)(%ebx)
-  sidt  (HOST_IDT_INFO)(%ebx)
-  sldt  (HOST_LDT_SEL)(%ebx)
-  str   (HOST_TSS_SEL)(%ebx)
-  
-  movl  %esp, (HOST_STACK_INFO)(%ebx)    /* Save host SS:ESP */
-  movw  %ss,  (4+HOST_STACK_INFO)(%ebx)  /* for later restore */
-
-  leal  (OFFSET_OF(__host_cs))(%ebx), %eax  /* Save the CS:EIP for monitor to */
-  movl  %eax, (HOST_JMP_INFO)(%ebx)         /* jump to when reloading host CS. */
-  movw  %cs,  (4+HOST_JMP_INFO)(%ebx)       /* See __guest2host below. */
-
-  /* Save host CRx values */
-  movl  %cr0, %eax
-  movl  %cr2, %ecx
-  movl  %cr4, %edx
-  movl  %cr3, %esi
-
-  movl  %eax, (HOST_CR0)(%ebx)
-  movl  %ecx, (HOST_CR2)(%ebx)
-  movl  %edx, (HOST_CR4)(%ebx)
-  movl  %esi, (HOST_CR3)(%ebx)
-
-  /* Compute monitor CRx values */
-  movl (MON_CR0)(%ebx), %eax
-  movl (MON_CR4)(%ebx), %edx
-  movl (MON_CR3)(%ebx), %esi
-
-  /* Before changing the PSE bit in CR4, we have to switch over */
-  /* to the new CR3 (this page identity mapped anyways).  Otherwise */
-  /* the processor could flush the TLB, and reload the entry for */
-  /* this page, only to find it's marked with a 4Meg Page, but we */
-  /* have that support turned off,  before we actually */
-  /* reloaded CR3! */
-  movl %esi, %cr3  /* Set monitor CR3 */
-  movl %eax, %cr0  /* Set monitor CR0 */
-  movl %edx, %cr4  /* Set monitor CR4 */
-  movl %esi, %cr3  /* Set monitor CR3 */
-
-jmp null_jmp0
-null_jmp0:
-
-  /* Switch to monitor GDT, LDT, and IDT */
-  lgdt  (MON_GDT_INFO)(%ebx)
-  lidt  (MON_IDT_INFO)(%ebx)
-  lldt  (MON_LDT_SEL)(%ebx)
-
-  /* Switch to monitor stack and CS */
-  /* and jump to the monitor-side nexus page */
-  lss   (MON_STACK_INFO)(%ebx), %esp
-  ljmp  (MON_JMP_INFO)(%ebx)
-.globl __mon_cs
-__mon_cs:
-
-  /* Reset DS:EBX to point to the monitor-side nexus page */
-  movw  %ss, %ax
-  movw  %ax, %ds /* copy SS to DS */
-  movw  %ax, %es /* copy SS to ES */
-  movl  %esp, %ebx
-  andl  $0xfffff000, %ebx
-
-  /* Clear busy bit of the monitor TSS and switch to it */
-  movzwl (MON_TSS_SEL)(%ebx), %eax
-  andl   $0xfffffff8, %eax
-  addl   (MON_GDT_INFO+2)(%ebx), %eax
-  subl   (MON_BASE)(%ebx), %eax
-  andl   $0xfffffdff, 4(%eax)
-  ltr    (MON_TSS_SEL)(%ebx)
-
-  /* We no longer need the nexus page identity mapped.  Fix the mapping */
-  /* back to the way it should be, in case guest code uses it. */
-  movl   (TRANSITION_PDE_P_MON)(%ebx), %eax
-  movl   %ebp, (%eax)  /* %ebp still contains the original value */
-  movl   (TRANSITION_LADDR)(%ebx), %eax
-  invlpg (%eax) /* Tell TLB about the change */
-/* +++ xxx fix this, need to convert pure laddr to offset */
-movl %cr3, %eax /* +++ xxx */
-movl %eax, %cr3 /* +++ xxx */
-
-  /* */
-  /* We can now restore the monitor context from it's stack. */
-  /* */
-  popl %gs
-  popl %fs
-  popal          /* Restore mon general registers */
-  popfl          /* Restore mon eflags */
-  ret /* Resume execution in monitor exception handler code. */
-
-
-
-/* ================================================================== */
-.globl __mon2host    /* Start function __mon2host() */
-__mon2host:
-  pushfl             /* Save mon flags */
-  pushal             /* Save mon general registers */
-  pushl %fs
-  pushl %gs
-
-  /* Set EBX to point to this nexus page */
-  movl  %esp, %ebx
-  andl  $0xfffff000, %ebx
-
-  movl  %esp, (MON_STACK_INFO)(%ebx)    /* Save mon ESP */
-
-  /* Identity map this code page to host address space. */
-  movl   (TRANSITION_PDE_P_MON)(%ebx), %eax
-  movl   (TRANSITION_PDE)(%ebx), %ebp
-  xchgl  %ebp, (%eax)  /* old PDE saved in %ebp to be restored below */
-  movl   (TRANSITION_LADDR)(%ebx), %eax
-
-  /* Switch EBX to point to the identity mapped copy of  */
-  /* the nexus page, and jump to the copy of this code there. */
-  subl (MON_BASE)(%ebx), %eax
-  invlpg (%eax)        /* Tell TLB about the change */
-  movl %eax, %ebx
-  leal (OFFSET_OF(__mon_nexus_jmp))(%ebx), %eax
-  jmp  *%eax
-__mon_nexus_jmp:
-
-  /* We are still in the monitor context, but are running at the */
-  /* same CS.base+EIP location in either host or monitor context, */
-  /* and this page is identity mapped between the 2 contexts. */
-  /* We can now switch to the host CR3, and be sure that execution */
-  /* will resume at the next instruction. */
-
-  /* NOTE: Don't try to access the stack after CR3 was reloaded */
-  /*       but before we switched back to the host stack! */
-
-  /* Restore host CRx values */
-  movl  (HOST_CR0)(%ebx), %eax
-  movl  (HOST_CR2)(%ebx), %ecx
-  movl  (HOST_CR4)(%ebx), %edx
-  movl  (HOST_CR3)(%ebx), %esi
-
-  movl  %eax, %cr0
-  movl  %ecx, %cr2
-  movl  %edx, %cr4
-  movl  %esi, %cr3
-
-jmp null_jmp1
-null_jmp1:
-
-  /* Switch to host GDT, LDT, and IDT */
-  lgdt   (HOST_GDT_INFO)(%ebx)
-  lidt   (HOST_IDT_INFO)(%ebx)
-  lldt   (HOST_LDT_SEL)(%ebx)
-
-  /* Restore host stack and CS */
-  lss    (HOST_STACK_INFO)(%ebx), %esp
-  ljmp   (HOST_JMP_INFO)(%ebx)
-__host_cs:
-
-  /* Clear busy bit of the host TSS and switch to it */
-  /* Note that DS is still the monitor segment with base (MON_BASE). */
-  movzwl (HOST_TSS_SEL)(%ebx), %eax
-  andl   $0xfffffff8, %eax
-  addl   (HOST_GDT_INFO+2)(%ebx), %eax
-  subl   (MON_BASE)(%ebx), %eax
-  andl   $0xfffffdff, 4(%eax)
-  ltr    (HOST_TSS_SEL)(%ebx)
-
-  /* We no longer need the nexus page identity mapped, so we clean */
-  /* up the monitor page directory in case the host looks at it. */
-  /* Note that SS is already the host segment. */
-  movl   (TRANSITION_PDE_P_HOST)(%ebx), %eax
-  ss; movl %ebp, (%eax)  /* %ebp still contains the original value */
-
-  /* Now we can restore the rest of */
-  /* the host context from the host stack.  Look at __host2guest */
-  /* for the format of the values stored on the host stack. */
-  popl %gs
-  popl %fs
-  popl %ds
-  popl %es
-  popal
-  popfl
-  ret 
-
-.globl __nexus_end
-__nexus_end:
diff -Nur bochs-2.0.2+20030829.old/plex86/kernel/paging-mon.c bochs-2.0.2+20030829/plex86/kernel/paging-mon.c
--- bochs-2.0.2+20030829.old/plex86/kernel/paging-mon.c	2003-01-10 04:27:51.000000000 +0000
+++ bochs-2.0.2+20030829/plex86/kernel/paging-mon.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,767 +0,0 @@
-/*
- *  plex86: run multiple x86 operating systems concurrently
- *  Copyright (C) 1999-2003 Kevin P. Lawton
- *
- *  paging-mon.c:  Virtualized (monitor) paging functionality.
- *
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Lesser General Public
- *  License as published by the Free Software Foundation; either
- *  version 2 of the License, or (at your option) any later version.
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- */
-
-
-#include "plex86.h"
-#define IN_MONITOR_SPACE
-#include "monitor.h"
-
-
-
-static unsigned allocatePT(vm_t *, unsigned pdi);
-static unsigned strengthenPagePermissions(vm_t *, phyPageInfo_t *usage,
-                  unsigned new_access_perm);
-/*static void sanity_check_pdir(vm_t *vm, unsigned id, Bit32u guest_laddr); */
-
-/* +++ fix retrieve mon pages function and .base issue */
-/*     also open_guest_phy_page expects shifted page val */
-/* +++ write_physical() has hack to ignore when perm!=RW, fix! */
-/* +++ add async handling in emulation.c, like in preGuest() */
-
-/* Cases which would generate a mon #PF */
-/* ==================================== */
-/* lazy map */
-/* r/w to current code page */
-/* guest #PF (access checks of cpl,rw) */
-/* w to RO construct */
-/* r/w to NA construct */
-
-/* inhibits */
-
-
-#if 0
-======= Old notes =====================================================
-IDT,GDT,LDT: limit = 64K; TR is a dont care
-What to do with PDir, PTbl?
-What to do about coherence probs with page tables and TLB?
-When are A,D bits copied between monitor and host?
-Need check for mapping of space used by monitor
-
-Code cache probably should not have laddr in it
-
-guest.PG==0, how are phy pages unmarked when constructs move?
-guest.PG transition: dump everything (flush)
-
-remapping descriptor tables after page flush
-make sure to validate phy_attr everywhere before using it.
-
-checks for the phy_attr of page that PDir goes in
-page fault because of monP?E.RW==0, but guestP?E==1
-
-/* +++ what about virtualized linear structs like GDT, IDT, ... */
-#endif
-
-#warning "Have to be careful unpinning a page which is open"
-#warning "  via open_guest_phy_page().  Multiple pages could be"
-#warning "  open in the page walk at one time until D/A bits are set."
-
-
-  static inline Bit32u
-getHostOSPinnedPage(vm_t *vm, Bit32u ppi)
-{
-  /* If physical page is already pinned by host OS, then we already
-   * know the physical address of the page.
-   */
-  if (vm->pageInfo[ppi].attr.fields.pinned)
-    return( vm->pageInfo[ppi].hostPPI );
-
-  /* Page is not already pinned by the host OS.  We need to request
-   * from the host OS, that this page is pinned and find the
-   * physical address.
-   */
-  toHostPinUserPage(vm, ppi);
-  if ( !vm->pageInfo[ppi].attr.fields.pinned )
-    monpanic(vm, "getHostOSPinnedPage: page was not marked pinned.\n");
-  return( vm->pageInfo[ppi].hostPPI );
-}
-
-
-  unsigned
-allocatePT(vm_t *vm, unsigned pdi)
-{
-  unsigned map_i;
-
-  /* Allocate one of the (preallocated) pages for */
-  /* the monitor to use for a page table at the PDI given. */
-
-  map_i = vm->ptbl_laddr_map_i;
-
-  if (map_i >= MON_PAGE_TABLES) {
-    monpanic(vm, "allocatePT: out of page tables\n");
-    }
-#if ANAL_CHECKS
-  if (vm->guest.addr.page_tbl_laddr_map[pdi] != -1) {
-    monprint(vm, "allocatePT: check failed.\n");
-    monpanic(vm, "  pdi=0x%x, laddr_map=0x%x\n",
-      pdi, vm->guest.addr.page_tbl_laddr_map[pdi]);
-    }
-#endif
-  vm->guest.addr.page_tbl_laddr_map[pdi] = map_i;
-  vm->ptbl_laddr_map_i++;
-  return(map_i);
-}
-
-  unsigned
-getMonPTi(vm_t *vm, unsigned pdi, unsigned source)
-{
-  unsigned map_i;
-  map_i = vm->guest.addr.page_tbl_laddr_map[pdi];
-#if ANAL_CHECKS
-  if (map_i == -1) {
-    monprint(vm, "getMonPTi: check failed.\n");
-    monpanic(vm, "  pdi=0x%x, map_i=0x%x, source=%u\n",
-      pdi, map_i, source);
-    }
-  if (map_i >= MON_PAGE_TABLES)
-    monpanic(vm, "getMonPTi: map_i OOB\n");
-#endif
-  return(map_i);
-}
-
-
-/* Invalidate the mapping of a guest page in the monitor.
- * When situations change, such as a change in the permissions
- * necessary to virtualize the page properly, we'll need to do
- * this first, before remapping with the new permissions.
- */
-  unsigned
-strengthenPagePermissions(vm_t *vm, phyPageInfo_t *pusage,
-                     unsigned new_access_perm)
-{
-  pusage->attr.fields.access_perm = new_access_perm;
-
-  if (pusage->attr.fields.lmap_count == 0) {
-    /* No linear addresses are mapped to this phy page yet.
-     * Nothing to do. */
-    return 0;
-    }
-  else if (pusage->attr.fields.lmap_count == 1) {
-    /* One linear address is mapped to this phy page. */
-    Bit32u pdi, pti;
-    pageEntry_t *monPDE, *monPTE;
-    page_t      *monPTbl;
-    unsigned map_i;
-
-    pdi = (pusage->attr.fields.laddr_backlink >> 10);
-    pti = (pusage->attr.fields.laddr_backlink & 0x3ff);
-    monPDE = &vm->guest.addr.page_dir[pdi];
-    if ( !monPDE->fields.P )
-      monpanic(vm, "strengthenPP: monPDE.P==0\n");
-    map_i = getMonPTi(vm,pdi,10);
-    monPTbl = &vm->guest.addr.page_tbl[map_i];
-    monPTE = &monPTbl->pte[pti];
-    if ( !monPTE->fields.P ) {
-
-/*monprint(vm, "strengthenPP: bl=0x%x, AP=%u\n",
- *pusage->attr.fields.laddr_backlink, new_access_perm); */
-
-      /*monpanic(vm, "strengthenPP: monPTE.P==0\n"); */
-      }
-    else if (pusage->attr.fields.access_perm==PagePermNA) {
-      /* Permissions were changed to No Access */
-      monPTE->raw = 0;
-      }
-    else if (pusage->attr.fields.access_perm==PagePermRO) {
-      /* Permissions were changed to RO */
-      monPTE->fields.RW = 0;
-      }
-    else {
-      monpanic(vm, "strengthenPP: PagePermRW\n");
-      }
-    /* Flush the old TLB entry */
-    invlpg_mon_offset(
-      Guest2Monitor(vm, pusage->attr.fields.laddr_backlink<<12)
-      );
-    return 0;
-    }
-  else {
-    /* Multiple linear addresses are mapped to this phy page. */
-    /* Since we dont store enough backlink info to virtualize all */
-    /* linear addresses which point to this phy page, we have to dump */
-    /* all dynamic mappings and start over. */
-monpanic(vm, "strengthenPP: multiple lin addr\n");
-/*monPagingRemap(vm);*/
-    return 1;
-    }
-}
-
-  unsigned
-addPageAttributes(vm_t *vm, Bit32u ppi, Bit32u req_attr)
-{
-  phyPageInfo_t *pusage;
-  unsigned new_access_perm;
-
-  VM_ASSERT(vm, ppi < vm->pages.guest_n_pages);
-
-  pusage = &vm->pageInfo[ppi];
-  if (pusage->tsc < vm->vpaging_tsc) {
-    /* The dynamic attributes for this page are not valid since
-     * the last remap.  getPageUsage() has logic to build attributes.
-     */
-    getPageUsage(vm, ppi);
-    }
-
-  /* Build new attributes based on old ones, and requested ones. */
-  pusage->attr.raw |= req_attr;
-
-  /* Look at strength of new access restrictions */
-  if (pusage->attr.raw & PageUsageCausesNA)
-    new_access_perm = PagePermNA;
-  else if (pusage->attr.raw & PageUsageCausesRO)
-    new_access_perm = PagePermRO;
-  else
-    new_access_perm = PagePermRW;
-
-  if (new_access_perm > pusage->attr.fields.access_perm) {
-    /* New usage causes a stronger access restriction.  Remap them. */
-    return( strengthenPagePermissions(vm, pusage, new_access_perm) );
-    }
-  return 0;
-}
-
-  phyPageInfo_t *
-getPageUsage(vm_t *vm, Bit32u ppi)
-{
-  phyPageInfo_t *pusage;
-
-  VM_ASSERT(vm, ppi < vm->pages.guest_n_pages);
-  pusage = &vm->pageInfo[ppi];
-
-  if (pusage->tsc < vm->vpaging_tsc) {
-    /* The dynamic attributes for this page are not valid since
-     * the last remap.  Clear them out, and timestamp.
-     */
-    pusage->tsc = vm_rdtsc();
-    pusage->attr.raw &= PageUsageSticky;
-    if (pusage->attr.raw & PageUsageCausesNA)
-      pusage->attr.fields.access_perm = PagePermNA;
-    else if (pusage->attr.raw & PageUsageCausesRO)
-      pusage->attr.fields.access_perm = PagePermRO;
-    else
-      pusage->attr.fields.access_perm = PagePermRW;
-    }
-  return(pusage);
-}
-
-
-  void *
-open_guest_phy_page(vm_t *vm, Bit32u ppi, Bit8u *mon_offset)
-{
-  page_t *pageTable;
-  Bit32u  pti, mon_range_offset;
-
-  VM_ASSERT(vm, ppi < vm->pages.guest_n_pages);
-  /* Since we rewind our CS/DS.base so that the beginning of our */
-  /* monitor pages land on the beginning of a new 4Meg boundary */
-  /* (separate PDE), find out what mon_offset is in terms of */
-  /* an offset from the beginning of the PDE boundary. */
-  mon_range_offset = ( ((Bit32u) mon_offset) -
-                       kernelModulePages.startOffsetPageAligned );
-  pti = (mon_range_offset >> 12) & 0x3ff;
-  pageTable = vm->guest.addr.nexus_page_tbl;
-
-  /* Remap the base field.  All the rest of the fields are */
-  /* set previously, and can remain the same. */
-  pageTable->pte[pti].fields.base = getHostOSPinnedPage(vm, ppi);
-  invlpg_mon_offset( (Bit32u) mon_offset );
-  return(mon_offset);
-}
-
-  void
-close_guest_phy_page(vm_t *vm, Bit32u ppi)
-{
-  /* ppi is >> 12 already */
-  /* +++ */
-}
-
-  void
-virtualize_lconstruct(vm_t *vm, Bit32u l0, Bit32u l1, unsigned perm)
-{
-  /* Mark pages for a protected construct in linear space as */
-  /* virtualized (protected), if it is mapped into monitor space. */
-  /* Pages which are not yet mapped in, are virtualized dynamically */
-  /* when they are mapped in. */
-
-  Bit32u pdi, pdi0, pdi1, pti, pti0, pti1;
-  pageEntry_t *monPDE, *monPTE;
-  page_t      *monPTbl;
-
-/* +++ For now, can just dump all page mappings and start over */
-/*     again.  Need to complete this function, so we can virtualize */
-/*     only those pages which need it, and keep the other ones. */
-/* +++ Need to look at perm also. */
-monpanic(vm, "vir_lconstruct: unfinished.\n");
-/*monPagingRemap(vm);*/
-return;
-
-  if (vm->guest.addr.guest_cpu->cr0.fields.pg)
-    monpanic(vm, "virtualize_lconstruct: guest PG==1\n");
-  if (l0 >= l1)
-    monpanic(vm, "virtualize_lconstruct: l0>=l1!\n");
-  if ( (l1-l0) > (64*1024) )
-    monpanic(vm, "virtualize_lconstruct: span is > 64k!\n");
-  pdi0 = l0 >> 22;
-  pdi1 = l1 >> 22;
-  pti0 = (l0 >> 12) & 0x000003ff;
-  for (pdi=pdi0; pdi<=pdi1; pdi++) {
-    if ( pdi == vm->mon_pdi )
-      monpanic(vm, "virtualize_lconstruct: conflict with monitor space\n");
-    monPDE = &vm->guest.addr.page_dir[pdi];
-    if (monPDE->fields.P) {
-      if (pdi<pdi1)
-        pti1 = 0x3ff; /* spans multiple pdi's, use last index of range */
-      else
-        pti1 = (l1 >> 12) & 0x000003ff; /* use index of last address */
-      for (pti=pti0; pti<=pti1; pti++) {
-/* +++ */
-/* +++ FIX THIS!!!, set depending on guest.CR0.PG */
-/* +++ */
-        monPTbl = &vm->guest.addr.page_tbl[pdi];
-        monPTE = &monPTbl->pte[pti];
-        if (monPTE->fields.P) {
-          /* +++ finish this! */
-          /* The physical page for this linear address is allocated */
-          /* and mapped into the monitor.  We can access the attributes */
-          /* for this physical page.  Even if it has been virtualized */
-          /* before, we still need to mark it since it could have been */
-          /* virtualized due to a physical page constraint. */
-          monpanic(vm, "virtualize_lconstruct: finish.\n");
-          }
-        }
-      }
-    pti0 = 0; /* start address at boundary of next PDI */
-    }
-}
-
-  unsigned
-mapGuestLinAddr(vm_t *vm, Bit32u guest_laddr, Bit32u *guest_ppi,
-                unsigned req_us, unsigned req_rw, Bit32u attr,
-                Bit32u *error)
-{
-  Bit32u       pdi, pti;
-  Bit32u       guest_lpage_index, ptbl_ppi;
-  page_t      *monPTbl;
-  pageEntry_t *monPDE, *monPTE;
-  pageEntry_t *guestPDir, guestPDE, *guestPTbl, guestPTE;
-  Bit32u       guest_pdir_page_index;
-  unsigned     pt_index, us, rw;
-  phyPageInfo_t *pusage;
-  unsigned wasRemap = 0;
-
-  guest_lpage_index = guest_laddr >> 12;
-  pdi = guest_lpage_index >> 10;
-  pti = guest_lpage_index & 0x3ff;
-  monPDE = &vm->guest.addr.page_dir[pdi];
-
-  if (vm->guest.addr.guest_cpu->cr0.fields.pg) {
-    /* Check out the guest's mapping of this address to see */
-    /* if would allow for an access. */
-    /* First, get the guest PDE */
-    guest_pdir_page_index = A20Addr(vm, vm->guest.addr.guest_cpu->cr3) >> 12;
-    if (guest_pdir_page_index >= vm->pages.guest_n_pages)
-      monpanic(vm, "mapGuestLinAddr: PG=1 guest PDE OOB\n");
-    /* Open a window into guest physical memory */
-    guestPDir = open_guest_phy_page(vm, guest_pdir_page_index,
-                                    vm->guest.addr.tmp_phy_page0);
-    guestPDE = guestPDir[pdi];
-
-    /* See if present, before fetching PTE */
-    if (guestPDE.fields.P==0) {
-      *error = 0x00000000; /* RSVD=0, P=0 */
-      goto np_exception;
-      }
-
-#if 0
-    if (vm->guestCpuIDInfo.procSignature.fields.family < 6) {
-      /* Update A bit of PDE memory image if not already */
-      if ( guestPDE.fields.A == 0 ) {
-        guestPDE.fields.A = 1;
-        guestPDir[pdi] = guestPDE;
-        }
-      }
-#endif
-
-    /* Second, get the guest PDE */
-    ptbl_ppi = A20PageIndex(vm, guestPDE.fields.base);
-    if (ptbl_ppi >= vm->pages.guest_n_pages)
-      monpanic(vm, "mapGuestLinAddr: PG=1 guest PTE OOB\n");
-    guestPTbl = open_guest_phy_page(vm, ptbl_ppi,
-                                    vm->guest.addr.tmp_phy_page1);
-    guestPTE = guestPTbl[pti];
-
-    if (guestPTE.fields.P==0) {
-      *error = 0x00000000; /* RSVD=0, P=0 */
-      goto np_exception;
-      }
-
-#if 0
-/* +++ */
-    if (guestPDE.raw & PDEUnhandled)
-      monpanic(vm, "mapGuestLinAddr: guestPDE 0x%08x\n", guestPDE.raw);
-#endif
-    /* See if requested guest priv is weaker than guest PDE priv */
-    if (req_us > guestPDE.fields.US) {
-      *error = 0x00000001; /* RSVD=0, P=1 */
-      goto access_exception;
-      }
-    if ( (req_rw > guestPDE.fields.RW) &&
-         (vm->guest.addr.guest_cpu->cr0.fields.wp || req_us) ) {
-      *error = 0x00000001; /* RSVD=0, P=1 */
-      goto access_exception;
-      }
-
-#warning "ignoring PTEUnhandled bits"
-#if 0
-    if (guestPTE.raw & PTEUnhandled)
-      monpanic(vm, "mapGuestLinAddr: guestPTE 0x%08x\n", guestPTE.raw);
-#endif
-    if (req_us > guestPTE.fields.US) {
-      *error = 0x00000001; /* RSVD=0, P=1 */
-      goto access_exception;
-      }
-    if ( (req_rw > guestPTE.fields.RW) &&
-         (vm->guest.addr.guest_cpu->cr0.fields.wp || req_us) ) {
-      *error = 0x00000001; /* RSVD=0, P=1 */
-      goto access_exception;
-      }
-
-#if 0
-    if (vm->guestCpuIDInfo.procSignature.fields.family >= 6) {
-      /* Update A bit of PDE memory image if not already */
-      if ( guestPDE.fields.A == 0 ) {
-        guestPDE.fields.A = 1;
-        guestPDir[pdi] = guestPDE;
-        }
-      }
-
-    /* Update A bit in PTE memory image if not already */
-    if ( (guestPTE.fields.A == 0) ||
-         ((req_rw==1) && !guestPTE.fields.D) ) {
-      guestPTE.fields.A = 1;
-      if (req_rw==1)
-        guestPTE.fields.D = 1;
-      guestPTbl[pti] = guestPTE;
-      }
-#endif
-    
-    *guest_ppi = A20PageIndex(vm, guestPTE.fields.base);
-    }
-  else {
-    /* guest paging is off, linear address is physical address */
-    guest_pdir_page_index = 0; /* keep compiler quiet */
-    *guest_ppi = A20PageIndex(vm, guest_lpage_index);
-    }
-  if (*guest_ppi >= vm->pages.guest_n_pages)
-    return(MapLinPPageOOB);
-
-/* +++ mapping in guest pages, check static phy_attr bits first before */
-/* +++ allowing non-protected. */
-
-
-mapIntoMonitor:
-
-  /* At this point, we know that the guest's paging system
-   * (if enabled) would allow for this access.  Now we have to
-   * see about mapping it into the monitor linear address space.
-   */
-  pusage = getPageUsage(vm, *guest_ppi);
-
-  if (wasRemap > 1)
-    monpanic(vm, "wasRemap>1\n");
-
-  /*
-   * Check monitor PDE
-   */
-  if (monPDE->fields.P == 0) {
-    /* OK, Lazy PT map/allocate */
-    if (vm->guest.addr.guest_cpu->cr0.fields.pg) {
-      phyPageInfo_t *pde_pusage;
-
-      pde_pusage =
-          getPageUsage(vm, A20PageIndex(vm, guestPDE.fields.base));
-      if (pde_pusage->attr.raw & PageBadUsage4PTbl) {
-
-#warning "PDE->PDir hack"
-/*monprint(vm, "PDE.base=0x%x CR3=0x%x\n",
- *  A20PageIndex(vm, guestPDE.fields.base),
- *  A20Addr(vm, vm->guest_cpu.cr3));
- */
-return(MapLinEmulate);
-        }
-
-      if (pde_pusage->attr.raw & PageUsagePTbl) {
-        /* It is possible that multiple PDE entries will point to */
-        /* the same Page Table.  In this case, we need to search to */
-        /* find which one the monitor already mapped in, and get */
-        /* a pointer to the Page Table allocated by the monitor. */
-        Bit32u guest_ptbl_index;
-        unsigned i;
-
-        guestPDir = open_guest_phy_page(vm, guest_pdir_page_index,
-                                    vm->guest.addr.tmp_phy_page0);
-        guest_ptbl_index = A20PageIndex(vm, guestPDir[pdi].fields.base);
-        monPTbl = (void *) 0;
-        pt_index = 0; /* keep compiler quiet */
-        for (i=0; i<1024; i++) {
-          if (i==pdi) continue; /* skip current PDI */
-          guestPDE = guestPDir[i];
-          if ( guestPDE.fields.P &&
-               (A20PageIndex(vm, guestPDE.fields.base)==guest_ptbl_index) ) {
-            /* OK, guest has a PDE which matches.  If it is mapped into */
-            /* the monitor already, then we are done searching. */
-            if (vm->guest.addr.page_dir[i].fields.P) {
-              pt_index = getMonPTi(vm, i, 11);
-              vm->guest.addr.page_tbl_laddr_map[pdi] = pt_index;
-              monPTbl = &vm->guest.addr.page_tbl[pt_index];
-              break;
-              }
-            }
-          }
-        close_guest_phy_page(vm, guest_pdir_page_index);
-        if (i>=1024)
-          monpanic(vm, "mapGuestLinAddr: PDE maps to existing PTbl.\n");
-        }
-      else {
-        /* Allocate PT using paged scheme. */
-        pt_index = allocatePT(vm, pdi);
-        monPTbl = &vm->guest.addr.page_tbl[pt_index];
-        mon_memzero(monPTbl, sizeof(*monPTbl));
-        }
-
-      if (vm->guest.addr.guest_cpu->sreg[SRegCS].des.dpl==3) {
-        /* For user code, we can use the guest US & RW values as-is, */
-        /* since they are honored as such with either CR0.WP value. */
-        us = guestPDE.fields.US;
-        rw = guestPDE.fields.RW;
-        }
-      else { /* guest supervisor code */
-        /* For supervisor code, access rules are different dependent on */
-        /* the value of CR0.WP. */
-        if (vm->guest.addr.guest_cpu->cr0.fields.wp==0) {
-          /* If CR0.WP=0, then supervisor code can write to any page, */
-          /* and permissions are effectively ignored. */
-          us = 1;
-          rw = 1;
-          }
-        else { /* CR0.WP==1 */
-          /* If CR0.WP=0, then supervisor code can read from any page, */
-          /* but write permission depends on the RW bit. */
-          us = 1;
-          rw = guestPDE.fields.RW;
-          }
-        }
-
-
-      /* Base/Avail=0/G=0/PS=0/D=d/A=a/PCD=0/PWT=0/US=us/RW=rw/P=1 */
-      monPDE->raw =
-          (vm->pages.page_tbl[pt_index] << 12) | (guestPDE.raw & 0x60) |
-          (us<<2) | (rw<<1) | 1;
-      if ( addPageAttributes(vm, A20PageIndex(vm, guestPDE.fields.base),
-                             PageUsagePTbl) ) {
-        wasRemap++;
-        goto mapIntoMonitor;
-        }
-      }
-    else {
-      /* Allocate PT using non-paged scheme. */
-      pt_index = allocatePT(vm, pdi);
-      monPTbl = &vm->guest.addr.page_tbl[pt_index];
-      mon_memzero(monPTbl, 4096);
-      /* Base/Avail=0/G=0/PS=0/D=0/A=0/PCD=0/PWT=0/US=1/RW=1/P=1 */
-      monPDE->raw =
-          (vm->pages.page_tbl[pt_index] << 12) | 0x7;
-      }
-    }
-  else {
-    /* monPDE->P == 1 */
-
-    /* Make sure this laddr does not conflict with monitor space */
-    /* This can only happen when monPDE.P==1, since the monitor */
-    /* is always mapped in. */
-    if ( (guest_laddr & 0xffc00000) == vm->mon_pde_mask )
-      return(MapLinMonConflict);
-
-    pt_index = getMonPTi(vm, pdi, 12);
-    monPTbl = &vm->guest.addr.page_tbl[pt_index];
-    }
-
-  monPTE = &monPTbl->pte[pti];
-
-  /*
-   * Check monitor PTE
-   */
-  if (monPTE->fields.P == 0) {
-    if (vm->guest.addr.guest_cpu->cr0.fields.pg) {
-      if (vm->guest.addr.guest_cpu->sreg[SRegCS].des.dpl==3) {
-        /* For user code, we can use the guest US & RW values as-is, */
-        /* since they are honored as such with either CR0.WP value. */
-        us = guestPTE.fields.US;
-        rw = guestPTE.fields.RW;
-        }
-      else { /* guest supervisor code */
-        /* For supervisor code, access rules are different dependent on */
-        /* the value of CR0.WP. */
-        if (vm->guest.addr.guest_cpu->cr0.fields.wp==0) {
-          /* If CR0.WP=0, then supervisor code can write to any page, */
-          /* and permissions are effectively ignored. */
-          us = 1; 
-          rw = 1;
-          }
-        else { /* CR0.WP==1 */
-          /* If CR0.WP=0, then supervisor code can read from any page, */
-          /* but write permission depends on the RW bit. */
-          us = 1;
-          rw = guestPTE.fields.RW;
-          }
-        }
-      if (pusage->attr.fields.access_perm==PagePermRO) {
-        rw = 0;
-        if (req_rw)
-          return(MapLinEmulate);
-        }
-      else if (pusage->attr.fields.access_perm==PagePermNA)
-        return(MapLinEmulate);
-
-      /* Base/Avail=0/G=0/PS=0/D=d/A=a/PCD=0/PWT=0/US=1/RW=rw/P=1 */
-      monPTE->raw =
-          (getHostOSPinnedPage(vm, *guest_ppi) << 12) | (guestPTE.raw & 0x60) |
-          0x5 | (rw<<1);
-      }
-    else { /* CR0.PG==0 */
-      rw = 1; /* Paging off is effectively RW */
-      if (pusage->attr.fields.access_perm==PagePermRO) {
-        rw = 0;
-        if (req_rw)
-          return(MapLinEmulate);
-        }
-      else if (pusage->attr.fields.access_perm==PagePermNA)
-        return(MapLinEmulate);
-      /* Base/Avail=0/G=0/PS=0/D=0/A=0/PCD=0/PWT=0/US=1/RW=rw/P=1 */
-      monPTE->raw =
-          (getHostOSPinnedPage(vm, *guest_ppi) << 12) | 0x5 | (rw<<1);
-      }
-
-    /* Mark physical page as having an unvirtualized linear address
-     * mapped to it.
-     */
-    if (pusage->attr.fields.lmap_count == 0) {
-      pusage->attr.fields.lmap_count = 1;
-      pusage->attr.fields.laddr_backlink = guest_lpage_index;
-      }
-    else if (pusage->attr.fields.lmap_count == 1) {
-      pusage->attr.fields.lmap_count = 2; /* max out count */
-      /* Count maxed out, we only store laddr_backlink of 1st mapping. */
-      }
-    else {
-      /* Count maxed out, we don't store any more info. */
-      }
-
-    invlpg_mon_offset( Guest2Monitor(vm, guest_laddr) );
-    return(MapLinOK);
-    }
-  else {
-    /* PTE.P == 1 */
-    return(MapLinAlreadyMapped);
-    }
-
-np_exception:
-access_exception:
-  *error |= (req_us<<2) | (req_rw<<1);
-  return(MapLinException);
-}
-
-
-  void
-guestPageFault(vm_t *vm, guest_context_t *context, Bit32u cr2)
-{
-  Bit32u   guest_ppi, error, gerror;
-  unsigned us, rw;
-
-  /* Make sure this laddr does not conflict with monitor space */
-  if ( (cr2 & 0xffc00000) == vm->mon_pde_mask )
-    monpanic(vm, "PageFault: guest access to monitor space\n");
-
-  error = context->error;
-  if (error & 0x8) /* If RSVD bits used in PDir */
-    monpanic(vm, "guestPageFault: RSVD\n");
-
-  us = vm->guest.addr.guest_cpu->sreg[SRegCS].des.dpl == 3;
-  rw = (error >> 1) & 1;
-
-/* +++ should base attr (currently 0) on whether this is */
-/* code or data???  only if siv==1 */
-  switch (mapGuestLinAddr(vm, cr2, &guest_ppi, us, rw, 0, &gerror)) {
-    case MapLinOK:
-      return;
-    case MapLinMonConflict:
-      monpanic(vm, "guestPageFault: MapLinMonConflict:\n");
-    case MapLinAlreadyMapped:
-      monpanic(vm, "guestPageFault: MapLinAlreadyMapped:\n");
-      /*emulate_instr(vm, context, 2);*/
-      return;
-    case MapLinPPageOOB:
-      monpanic(vm, "guestPageFault: MapLinPPageOOB (0x%x):\n", cr2);
-    case MapLinEmulate:
-      monpanic(vm, "guestPageFault: MapLinEmulate:\n");
-      /*emulate_instr(vm, context, 3);*/
-      return;
-
-    case MapLinException:
-      /*monpanic(vm, "guestPageFault: emulate_exception was here.\n");*/
-      /*emulate_exception(vm, ExceptionPF, gerror);*/
-      toHostGuestFault(vm, ExceptionPF);
-      return;
-
-    default:
-      monpanic(vm, "guestPageFault: MapLin: default case:\n");
-    }
-}
-
-#if 0
-  void
-sanity_check_pdir(vm_t *vm, unsigned id, Bit32u guest_laddr)
-{
-  pageEntry_t *monPDE;
-  Bit32u       pdi;
-  unsigned     pt_index;
- 
-  for (pdi=0; pdi<1024; pdi++) {
-    monPDE = &vm->guest.addr.page_dir[pdi];
-    if ( (pdi!=vm->mon_pdi) &&
-        monPDE->fields.P ) {
-
-      pt_index = vm->guest.addr.page_tbl_laddr_map[pdi];
-      if (pt_index == -1)
-        monpanic(vm, "sanity_check_pdir: pt_index==-1\n");
-      if (pt_index >= vm->pages.guest_n_pages)
-        monpanic(vm, "sanity_check_pdir: pt_index OOB\n");
-      if ( monPDE->fields.base != vm->pages.page_tbl[pt_index] ) {
-        monprint(vm, "gaddr=0x%x\n", guest_laddr);
-        monprint(vm, "pt_index=%u\n", pt_index);
-        monprint(vm, "map[0x302]=%u\n",
-          vm->guest.addr.page_tbl_laddr_map[0x302]);
-        monpanic(vm, "sanity_check_pdir: id=%u "
-          "pdi=0x%x\n", id, pdi);
-        }
-      }
-    }
-}
-#endif
diff -Nur bochs-2.0.2+20030829.old/plex86/kernel/panic-mon.c bochs-2.0.2+20030829/plex86/kernel/panic-mon.c
--- bochs-2.0.2+20030829.old/plex86/kernel/panic-mon.c	2003-01-01 17:32:04.000000000 +0000
+++ bochs-2.0.2+20030829/plex86/kernel/panic-mon.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,71 +0,0 @@
-/*
- *  plex86: run multiple x86 operating systems concurrently
- *  Copyright (C) 1999-2003 Kevin P. Lawton
- *
- *  panic-mon.c:  Monitor panic facility.
- *
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Lesser General Public
- *  License as published by the Free Software Foundation; either
- *  version 2 of the License, or (at your option) any later version.
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- */
-
-
-#include "plex86.h"
-#define IN_MONITOR_SPACE
-#include "monitor.h"
-
-extern int mon_vprint(vm_t *vm, char *fmt, va_list args);
-
-
-/*======================================== */
-/* Only to be used in monitor/guest space! */
-/*======================================== */
-
-  void
-monpanic(vm_t *vm, char *fmt, ...)
-{
-    monprint(vm, "plex86 panic: ");
-    if (fmt) 
-    {
-        va_list args;
-        va_start(args, fmt);
-        mon_vprint(vm, fmt, args);
-        va_end(args);
-    }
-
-loop:
-
-    CLI();
-
-    vm->mon_request = MonReqPanic;
-    vm->guest.__mon2host();
-
-    /* mon2host() should never return in this case.  In case it ever */
-    /* does because our logic is broken, keep returning back to */
-    /* the host so we at least don't hang the machine. */
-    goto loop;
-}
-
-  void
-monpanic_nomess(vm_t *vm)
-{
-loop:
-    CLI();
-    vm->mon_request = MonReqPanic;
-    vm->guest.__mon2host();
-
-    /* mon2host() should never return in this case.  In case it ever */
-    /* does because our logic is broken, keep returning back to */
-    /* the host so we at least don't hang the machine. */
-    goto loop;
-}
diff -Nur bochs-2.0.2+20030829.old/plex86/kernel/print-mon.c bochs-2.0.2+20030829/plex86/kernel/print-mon.c
--- bochs-2.0.2+20030829.old/plex86/kernel/print-mon.c	2003-01-02 02:09:44.000000000 +0000
+++ bochs-2.0.2+20030829/plex86/kernel/print-mon.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,262 +0,0 @@
-/*
- *  plex86: run multiple x86 operating systems concurrently
- *  Copyright (C) 1999-2003 Kevin P. Lawton
- *
- *  print-nexus.c:  Monitor debug print facility
- *
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Lesser General Public
- *  License as published by the Free Software Foundation; either
- *  version 2 of the License, or (at your option) any later version.
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- */
-
-
-#include "plex86.h"
-#define IN_MONITOR_SPACE
-#include "monitor.h"
-
-int mon_vprint(vm_t *vm, char *fmt, va_list args);
-
-static unsigned int power_of_ten[] = {
-  1,
-  10,
-  100,
-  1000,
-  10000,
-  100000,
-  1000000,
-  10000000,
-  100000000,
-  1000000000,
-  };
-
-  int
-monprint(vm_t *vm, char *fmt, ...)
-{
-  va_list args;
-  int ret;
-
-  va_start(args, fmt);
-  ret = mon_vprint(vm, fmt, args);
-  va_end(args);
-  return(ret);
-}
-
-  int
-mon_vprint(vm_t *vm, char *fmt, va_list args)
-{
-  unsigned offset, size;
-  unsigned char *log_buff_p;
-  int ret;
-
-  if (vm->log_buffer_info.locked)
-    return 0;
-
-  vm->log_buffer_info.locked = 1;
-  vm->log_buffer_info.event = 1;
-  offset = vm->log_buffer_info.offset;
-
-  /* Sanity check */
-  if (offset >= LOG_BUFF_SIZE) {
-    vm->guest.addr.log_buffer[0] = 0; /* Null terminate. */
-    resetPrintBuf(vm);
-    return(0);
-    }
-
-  size = LOG_BUFF_SIZE - offset;
-  log_buff_p = &vm->guest.addr.log_buffer[offset];
-
-  ret = mon_vsnprintf(log_buff_p, size, fmt, args);
-
-  if (ret == -1) {
-    /* Terminate current contents since new print request did not work. */
-    *log_buff_p = 0;
-    /* If we are in the monitor space, then we can request that the
-     * current buffer contents be printed.
-     */
-    resetPrintBuf(vm);
-    sysFlushPrintBuf(vm);
-
-    /* Print request did not fit.  dump buffer contents and try again
-     * using whole buffer.
-     */
-    size = LOG_BUFF_SIZE;
-    log_buff_p = &vm->guest.addr.log_buffer[0];
-    ret = mon_vsnprintf(log_buff_p, size, fmt, args);
-    if (ret == -1) {
-      /* We have serious problems.  This print request will not even
-       * fit in the whole buffer.
-       */
-      vm->guest.addr.log_buffer[0] = 0; /* Null terminate. */
-      resetPrintBuf(vm);
-      /* xxx Put error in buffer here. */
-      return(0);
-      }
-    }
-  vm->log_buffer_info.offset += ret;
-  vm->log_buffer_info.locked = 0;
-#if 0 /* Fri Dec 27 21:43:05 EST 2002 */
-  resetPrintBuf(vm);
-  sysFlushPrintBuf(vm);
-#endif
-  return(ret);
-}
-
-  void
-resetPrintBuf(vm_t *vm)
-{
-  vm->log_buffer_info.event = 0;
-  vm->log_buffer_info.locked = 0;
-  vm->log_buffer_info.offset = 0;
-  vm->log_buffer_info.error = 0;
-}
-
-
-/* For now, this is a simple vsnprintf() type of function.  We need
- * to fill this out a little.
- */
-
-  int
-mon_vsnprintf(char *str, unsigned size, const char *fmt, va_list args)
-{
-  int count = 0;
-  unsigned format_width;
-  unsigned char c;
-
-  while (*fmt) {
-    switch (*fmt) {
-
-      case '%':
-        format_width = 0;
-        fmt++;
-        c = *fmt++;
-        /* Get optional field width */
-        if ( (c>='0') && (c<='9') ) {
-          do {
-            format_width = (format_width * 10) + (c - '0');
-            c = *fmt++;
-            } while ( (c>='0') && (c<='9') );
-          }
-        /* %x: hexadecimal */
-        if ( c == 'x' ) {
-          unsigned int val, leadin;
-          int j;
-          unsigned nibble;
-
-          val = va_arg(args, unsigned int);
-          leadin = 1;
-
-          for (j=7; j>=0; j--) {
-            nibble = (val >> (4 * j)) & 0x0f;
-            if (leadin && j && !format_width && !nibble)
-              continue;
-            if (leadin && j && format_width && ((j+1)>format_width) &&
-                !nibble)
-              continue;
-            leadin = 0;
-            if ( (count+2) >= size ) goto error;
-            if (nibble <= 9)
-              *str++ = nibble + '0';
-            else
-              *str++ = (nibble-10) + 'A';
-            count++;
-            }
-          break;
-          }
-
-        /* %c: character */
-        if ( c == 'c' ) {
-          unsigned char val;
-          val = va_arg(args, unsigned);
-          if ( (count+2) >= size ) goto error;
-          *str++ = val;
-          count++;
-          break;
-          }
-
-        /* %s: string */
-        if ( c == 's' ) {
-          unsigned char *s;
-          s = va_arg(args, unsigned char *);
-          if ( (count+2) >= size ) goto error;
-          count++;
-          while (*s) {
-            if ( (count+2) >= size ) goto error;
-            *str++ = *s++; /* Copy char from string to output buffer. */
-            count++;
-            }
-          break;
-          }
-
-        /* %u: unsigned int */
-        if ( c == 'u' ) {
-          unsigned int val, leadin;
-          int j;
-          unsigned digit;
-
-          val = va_arg(args, unsigned int);
-          leadin = 1;
-
-          for (j=9; j>=0; j--) {
-            if (leadin && j && !format_width && (val < power_of_ten[j]))
-              continue;
-            if (leadin && j && format_width && ((j+1)>format_width) &&
-                (val < power_of_ten[j]))
-              continue;
-            leadin = 0;
-            digit = (val / power_of_ten[j]);
-            if ( (count+2) >= size ) goto error;
-            *str++ = digit + '0';
-            count++;
-            val -= (digit * power_of_ten[j]);
-            }
-          break;
-          }
-        /* %b : binary (non-standard but useful) */
-        if ( c == 'b' ) {
-          unsigned int val, bit, leadin;
-          int j;
-          val = va_arg(args, unsigned int);
-          leadin = 1;
-          for (j=31; j>=0; j--) {
-            bit = (val >> j) & 1;
-            if (leadin && j && !format_width && !bit)
-              continue;
-            if (leadin && j && format_width && ((j+1)>format_width) && !bit)
-              continue;
-            leadin = 0;
-            if ( (count+2) >= size ) goto error;
-            *str++ = bit + '0';
-            count++;
-            }
-          break;
-          }
-
-        /* Error, unrecognized format char */
-        goto error;
-        break;
-
-      default:
-        /* pass char through */
-        if ( (count+2) >= size ) goto error;
-        *str++ = *fmt++;
-        count++;
-        break;
-      }
-    }
-
-  *str = 0; /* Complete string with null char */
-  return(count);
-
-error:
-  return(-1);
-}
diff -Nur bochs-2.0.2+20030829.old/plex86/kernel/util-nexus.c bochs-2.0.2+20030829/plex86/kernel/util-nexus.c
--- bochs-2.0.2+20030829.old/plex86/kernel/util-nexus.c	2003-01-02 02:08:22.000000000 +0000
+++ bochs-2.0.2+20030829/plex86/kernel/util-nexus.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,57 +0,0 @@
-/*
- *  plex86: run multiple x86 operating systems concurrently
- *  Copyright (C) 1999-2003 Kevin P. Lawton
- *
- *  util-nexus.c: convenience routines which can be accessed from
- *    either space.
- *
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Lesser General Public
- *  License as published by the Free Software Foundation; either
- *  version 2 of the License, or (at your option) any later version.
- *
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  Lesser General Public License for more details.
- *
- *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
- */
-
-
-#include "plex86.h"
-/* These functions are available from either space. */
-#define IN_MONITOR_SPACE
-#define IN_HOST_SPACE
-#include "monitor.h"
-
-
-
-  void
-mon_memzero(void *ptr, int size)
-{
-    char *p = ptr;
-    while (size--)
-        *p++ = 0;
-}
-
-  void
-mon_memcpy(void *dst, void *src, int size)
-{
-    char *d = dst;
-    char *s = src;
-    while (size--)
-        *d++ = *s++;
-}
-
-  void *
-mon_memset(void *dst, unsigned c, unsigned n)
-{
-  unsigned char *d = dst;
-  while (n--) {
-    *d++ = c;
-    }
-  return(dst);
-}
diff -Nur bochs-2.0.2+20030829.old/plex86/misc/load_module.sh bochs-2.0.2+20030829/plex86/misc/load_module.sh
--- bochs-2.0.2+20030829.old/plex86/misc/load_module.sh	2003-01-01 17:32:06.000000000 +0000
+++ bochs-2.0.2+20030829/plex86/misc/load_module.sh	1970-01-01 00:00:00.000000000 +0000
@@ -1,55 +0,0 @@
-#! /bin/bash
-#
-# A simple script to load up the kernel module and create the device nodes
-# for it.
-#
-# Note:
-# this must be run as root
-#
-
-# Work out where the module is
-kmodule="`dirname $0`/../kernel/plex86.o"
-
-# Check that root is executing us
-if [ "$EUID" != "0" ]; then
-    echo "Sorry, you need to be root for this script to work."
-    echo "use 'su -c $0' and enter the root password when prompted"
-    exit -1
-fi
-
-# Check if the module exists
-if [ ! -f "$kmodule" ]; then
-    echo "The kernel module ($kmodule) does not exist!"
-    exit -1
-fi
-
-# Check if the module is already loaded
-if [ "x`grep plex86 /proc/devices`" != "x" ]; then
-    echo "The kernel module is already loaded!"
-    exit -1
-fi
-
-# Remove any stale device nodes
-# (extend for any minor devices created in the future)
-rm -f /dev/plex86
-
-# Load up the module with insmod
-/sbin/insmod $kmodule
-
-# Check if the module loaded
-major=`grep plex86 /proc/devices | awk '/plex86/ {print $1;}'`
-if [ "x$major" = "x" ]; then
-    echo "The kernel module failed to load!"
-    exit -1
-fi
-
-# Create the device node and set its permissions
-# (extend for any minor devices created in the future)
-if [ ! -c /dev/plex86 ]; then
-    /bin/mknod /dev/plex86 c $major 0
-fi
-chmod a+rw /dev/plex86
-
-# Job done - Give a little positive feedback
-echo "The kernel module is sucessfully installed."
-exit 0
diff -Nur bochs-2.0.2+20030829.old/plex86/misc/netbsd_post.sh bochs-2.0.2+20030829/plex86/misc/netbsd_post.sh
--- bochs-2.0.2+20030829.old/plex86/misc/netbsd_post.sh	2003-01-01 17:32:06.000000000 +0000
+++ bochs-2.0.2+20030829/plex86/misc/netbsd_post.sh	1970-01-01 00:00:00.000000000 +0000
@@ -1,17 +0,0 @@
-#! /bin/sh
-#
-# This is the post-install script called by modload after it has loaded
-# the module.
-#
-# Sample modload commandline:
-#
-#	modload -e plex86_lkmentry -p netbsd_post.sh plex86.o
-# 
-if [ $# -ne 3 ]; then
-    echo "$0 should only be called from modload(8) with 3 args"
-    exit 1
-fi
-
-rm -f /dev/plex86
-mknod /dev/plex86 c $3 0
-exit 0
diff -Nur bochs-2.0.2+20030829.old/plex86/misc/unload_module.sh bochs-2.0.2+20030829/plex86/misc/unload_module.sh
--- bochs-2.0.2+20030829.old/plex86/misc/unload_module.sh	2003-01-01 17:32:06.000000000 +0000
+++ bochs-2.0.2+20030829/plex86/misc/unload_module.sh	1970-01-01 00:00:00.000000000 +0000
@@ -1,34 +0,0 @@
-#! /bin/bash
-#
-# A simple script to unload the kernel module and remove the old device nodes
-# for it.
-#
-# Note:
-# this must be run as root
-#
-
-# Check that root is executing us
-if [ "$EUID" != "0" ]; then
-    echo "Sorry, you need to be root for this script to work."
-    echo "use 'su -c $0' and enter the root password when prompted"
-    exit -1
-fi
-
-# Check if the module is already loaded
-if [ "x`grep plex86 /proc/devices`" != "x" ]; then
-    /sbin/rmmod plex86
-
-    # Check that it really went (OK - I'm paranoid)
-    if [ "x`grep plex86 /proc/devices`" != "x" ]; then
-	echo "The kernel module failed to unload!"
-	exit -1
-    fi
-fi
-
-# Remove any stale device nodes
-# (extend for any minor devices created in the future)
-rm -f /dev/plex86
-
-# Job done - Give a little positive feedback
-echo "The kernel module is no longer installed."
-exit 0
diff -Nur bochs-2.0.2+20030829.old/plex86/plex86.h bochs-2.0.2+20030829/plex86/plex86.h
--- bochs-2.0.2+20030829.old/plex86/plex86.h	2003-01-10 04:27:51.000000000 +0000
+++ bochs-2.0.2+20030829/plex86/plex86.h	2003-08-29 14:31:40.000000000 +0000
@@ -1,5 +1,5 @@
 /************************************************************************
- * $Id: plex86.h,v 1.6 2003/01/10 04:27:51 kevinlawton Exp $
+ * $Id: plex86.h,v 1.2 2002/07/21 23:14:54 DemonLord Exp $
  ************************************************************************
  *
  *  plex86: run multiple x86 operating systems concurrently
@@ -33,7 +33,7 @@
   selector_t   sel;
   descriptor_t des;
   unsigned     valid;
-  } __attribute__ ((packed)) guest_sreg_t;
+  } guest_sreg_t;
 
 #define SRegES    0
 #define SRegCS    1
@@ -79,48 +79,6 @@
     } __attribute__ ((packed)) fields;
   } __attribute__ ((packed)) cr4_t;
 
-typedef struct {
-  Bit32u vendorDWord0;
-  Bit32u vendorDWord1;
-  Bit32u vendorDWord2;
-  union {
-    Bit32u raw;
-    struct {
-      Bit32u stepping:4;
-      Bit32u model:4;
-      Bit32u family:4;
-      Bit32u procType:2;
-      Bit32u Reserved31_14:18;
-      } __attribute__ ((packed)) fields;
-    } __attribute__ ((packed)) procSignature;
-  union {
-    Bit32u raw;
-    struct {
-      Bit32u fpu:1;
-      Bit32u vme:1;
-      Bit32u de:1;
-      Bit32u pse:1;
-      Bit32u tsc:1;
-      Bit32u msr:1;
-      Bit32u pae:1;
-      Bit32u mce:1;
-      Bit32u cx8:1;
-      Bit32u apic:1;
-      Bit32u Reserved10:1;
-      Bit32u sep:1;
-      Bit32u mtrr:1;
-      Bit32u pge:1;
-      Bit32u mca:1;
-      Bit32u cmov:1;
-      Bit32u pat:1;
-      Bit32u pse36:1;
-      Bit32u Reserved22_18:5;
-      Bit32u mmx:1;
-      Bit32u fxsr:1;
-      Bit32u Reserved31_25:7;
-      } __attribute__ ((packed)) fields;
-    } __attribute__ ((packed)) featureFlags;
-  } __attribute__ ((packed)) cpuid_info_t;
 
 typedef struct {
   Bit32u edi;
@@ -145,7 +103,7 @@
   Bit32u cr1, cr2, cr3;
   cr4_t cr4;
   unsigned a20Enable;
-  } __attribute__ ((packed)) guest_cpu_t;
+  } guest_cpu_t;
 
 
 
@@ -162,32 +120,17 @@
 #else
 #include <sys/ioccom.h>
 #endif
+#define PLEX86_ALLOCVPHYS   _IO('k', 2)
 #define PLEX86_RESET        _IO('k', 3)
 #define PLEX86_TEARDOWN     _IO('k', 4)
 #define PLEX86_EXECUTE      _IO('k', 5)
-#define PLEX86_CPUID        _IO('k', 6)
-#define PLEX86_REGISTER_MEMORY _IO('k', 7)
 #else
+#define PLEX86_ALLOCVPHYS   0x6b02
 #define PLEX86_RESET        0x6b03
 #define PLEX86_TEARDOWN     0x6b04
 #define PLEX86_EXECUTE      0x6b05
-#define PLEX86_CPUID        0x6b06
-#define PLEX86_REGISTER_MEMORY 0x6b07
 #endif
 
-/* Reasons why plex86 could not execute the guest context in the VM. */
-#define Plex86NoExecute_Method    1
-#define Plex86NoExecute_CR0       2
-#define Plex86NoExecute_CR4       3
-#define Plex86NoExecute_CS        4
-#define Plex86NoExecute_A20       5
-#define Plex86NoExecute_Selector  6
-#define Plex86NoExecute_DPL       7
-#define Plex86NoExecute_EFlags    8
-#define Plex86NoExecute_Panic     9
-#define Plex86NoExecute_VMState  10
-
-
 /* Requests that the VM monitor makes to host-kernel space or
  * host-user space.
  */
@@ -196,37 +139,8 @@
 #define MonReqRedirect          4 /* Only to host-kernel. */
 #define MonReqRemapMonitor      5
 #define MonReqGuestFault        6
-#define MonReqPinUserPage       7
 #define MonReqPanic             8
 
-#define VMStateFDOpened               0x001
-#define VMStateMemAllocated           0x002
-#define VMStateGuestCPUID             0x004
-#define VMStateRegisteredPhyMem       0x008
-#define VMStateRegisteredPrintBuffer  0x010
-#define VMStateRegisteredGuestCPU     0x020
-#define VMStateInitMonitor            0x040
-#define VMStateMapMonitor             0x080
-#define VMStatePanic                  0x100
-
-  /* State where the VM/monitor is ready to execute. */
-#define VMStateReady (VMStateFDOpened | \
-                      VMStateMemAllocated | \
-                      VMStateGuestCPUID | \
-                      VMStateRegisteredPhyMem | \
-                      VMStateRegisteredPrintBuffer | \
-                      VMStateRegisteredGuestCPU | \
-                      VMStateInitMonitor | \
-                      VMStateMapMonitor)
-
-  /* State where all user-space memory constructs are registered with
-   * the plex86 kernel module.
-   */
-#define VMStateRegisteredAll \
-                     (VMStateRegisteredPhyMem | \
-                      VMStateRegisteredPrintBuffer | \
-                      VMStateRegisteredGuestCPU)
-
 typedef struct {
   unsigned state;
   unsigned request;
@@ -248,12 +162,4 @@
   plex86MonitorState_t monitorState;
   } plex86IoctlExecute_t;
 
-typedef struct {
-  unsigned nMegs;
-  Bit32u   guestPhyMemVector;
-
-  Bit32u   logBufferWindow;
-  Bit32u   guestCPUWindow;
-  } plex86IoctlRegisterMem_t;
-
 #endif  /* #ifndef __PLEX86_H__ */
diff -Nur bochs-2.0.2+20030829.old/plex86/simple.c bochs-2.0.2+20030829/plex86/simple.c
--- bochs-2.0.2+20030829.old/plex86/simple.c	1970-01-01 00:00:00.000000000 +0000
+++ bochs-2.0.2+20030829/plex86/simple.c	2003-08-29 14:31:40.000000000 +0000
@@ -0,0 +1,20 @@
+#include <stdio.h>
+
+  int
+main(int argc, char *argv[])
+{
+  unsigned i;
+  unsigned a=1, b=2;
+  unsigned count;
+
+  if (argc != 2) return(1);
+  count = atoi(argv[1]);
+
+  for (i=0; i<count; i++) {
+    a += b;
+    b += a;
+    }
+  printf("a = %u, b=%u\n", a, b);
+
+  return(0);
+}
diff -Nur bochs-2.0.2+20030829.old/plex86-interface.cc bochs-2.0.2+20030829/plex86-interface.cc
--- bochs-2.0.2+20030829.old/plex86-interface.cc	2003-01-09 04:03:35.000000000 +0000
+++ bochs-2.0.2+20030829/plex86-interface.cc	1970-01-01 00:00:00.000000000 +0000
@@ -1,468 +0,0 @@
-/////////////////////////////////////////////////////////////////////////
-//// $Id: plex86-interface.cc,v 1.6 2003/01/09 04:03:35 kevinlawton Exp $
-///////////////////////////////////////////////////////////////////////////
-////
-////  Copyright (C) 2002  Kevin P. Lawton
-////
-////  This library is free software; you can redistribute it and/or
-////  modify it under the terms of the GNU Lesser General Public
-////  License as published by the Free Software Foundation; either
-////  version 2 of the License, or (at your option) any later version.
-////
-////  This library is distributed in the hope that it will be useful,
-////  but WITHOUT ANY WARRANTY; without even the implied warranty of
-////  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-////  Lesser General Public License for more details.
-////
-////  You should have received a copy of the GNU Lesser General Public
-////  License along with this library; if not, write to the Free Software
-////  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
-
-
-#include "bochs.h"
-#include <sys/ioctl.h>
-#include <unistd.h>
-#include <sys/mman.h>
-#include "plex86-interface.h"
-
-#define LOG_THIS genlog->
-
-unsigned      plex86State = 0;
-int           plex86FD = -1;
-
-asm (".comm   plex86PrintBufferPage,4096,4096");
-asm (".comm   plex86GuestCPUPage,4096,4096");
-extern Bit8u       plex86PrintBufferPage[];
-extern Bit8u       plex86GuestCPUPage[];
-
-static Bit8u       *plex86MemPtr = 0;
-static size_t       plex86MemSize = 0;
-static Bit8u       *plex86PrintBuffer = plex86PrintBufferPage;
-static guest_cpu_t *plex86GuestCPU = (guest_cpu_t *) plex86GuestCPUPage;
-
-static void copyPlex86StateToBochs(BX_CPU_C *cpu);
-static void copyBochsDescriptorToPlex86(descriptor_t *, bx_descriptor_t *);
-static void copyPlex86DescriptorToBochs(BX_CPU_C *,
-                                        bx_descriptor_t *, descriptor_t *);
-static int  openFD(void);
-
-static unsigned faultCount[32];
-
-
-  int
-openFD(void)
-{
-  if (plex86State) {
-    // This should be the first operation; no state should be set yet.
-    fprintf(stderr, "plex86: openFD: plex86State = 0x%x\n", plex86State);
-    return(0); // Error.
-    }
-
-  // Open a new VM.
-  fprintf(stderr, "plex86: opening VM.\n");
-  fprintf(stderr, "plex86: trying /dev/misc/plex86...");
-  plex86FD = open("/dev/misc/plex86", O_RDWR);
-  if (plex86FD < 0) {
-    fprintf(stderr, "failed.\n");
-    // Try the old name.
-    fprintf(stderr, "plex86: trying /dev/plex86...");
-    plex86FD = open("/dev/plex86", O_RDWR);
-    if (plex86FD < 0) {
-      fprintf(stderr, "failed.\n");
-      fprintf(stderr, "plex86: did you load the kernel module?"
-              "  Read the toplevel README file!\n");
-      perror ("open");
-      return(-1); // Error.
-      }
-    }
-  fprintf(stderr, "OK.\n");
-  return(1); // OK.
-}
-
-  unsigned
-plex86CpuInfo(BX_CPU_C *cpu)
-{
-  cpuid_info_t bochsCPUID;
-
-  if (plex86FD < 0) {
-    // If the plex86 File Descriptor has not been opened yet.
-    if ( !openFD() ) {
-      return(0); // Error.
-      }
-    }
-
-  bochsCPUID.vendorDWord0 = cpu->cpuidInfo.vendorDWord0;
-  bochsCPUID.vendorDWord1 = cpu->cpuidInfo.vendorDWord1;
-  bochsCPUID.vendorDWord2 = cpu->cpuidInfo.vendorDWord2;
-  bochsCPUID.procSignature.raw = cpu->cpuidInfo.procSignature;
-  bochsCPUID.featureFlags.raw  = cpu->cpuidInfo.featureFlags;
-
-  fprintf(stderr, "plex86: passing guest CPUID to plex86.\n");
-  if ( ioctl(plex86FD, PLEX86_CPUID, &bochsCPUID) ) {
-    perror("ioctl CPUID: ");
-    return(0); // Error.
-    }
-
-  return(1); // OK.
-}
-
-  unsigned
-plex86TearDown(void)
-{
-  fprintf(stderr, "plex86: plex86TearDown called.\n");
-
-  fprintf(stderr, "plex86: guest Fault Count (FYI):\n");
-  for (unsigned f=0; f<32; f++) {
-    if (faultCount[f])
-      fprintf(stderr, "plex86:  FC[%u] = %u\n", f, faultCount[f]);
-    }
-
-  if ( plex86FD < 0 ) {
-    fprintf(stderr, "plex86: plex86TearDown: FD not open.\n");
-    return(0);
-    }
-
-  if ( plex86State & Plex86StateMMapPhyMem ) {
-    fprintf(stderr, "plex86: unmapping guest physical memory.\n");
-    }
-  plex86State &= ~Plex86StateMMapPhyMem;
-
-  if ( plex86State & Plex86StateMMapPrintBuffer ) {
-    }
-  plex86State &= ~Plex86StateMMapPrintBuffer;
-
-  if ( plex86State & Plex86StateMMapGuestCPU ) {
-    }
-  plex86State &= ~Plex86StateMMapGuestCPU;
-
-  fprintf(stderr, "plex86: tearing down VM.\n");
-  if (ioctl(plex86FD, PLEX86_TEARDOWN, 0) == -1) {
-    perror("ioctl TEARDOWN: ");
-    return(0); // Failed.
-    }
-  plex86State &= ~Plex86StateMemAllocated;
-
-  // Close the connection to the kernel module.
-  fprintf(stderr, "plex86: closing VM device.\n");
-  if (close(plex86FD) == -1) {
-    perror("close of VM device\n");
-    return(0); // Failed.
-    }
-
-  plex86FD = -1; // File descriptor is now closed.
-
-  plex86State = 0; // For good measure.
-
-  return(1); // OK.
-}
-
-  unsigned
-plex86ExecuteInVM(BX_CPU_C *cpu)
-{
-  plex86IoctlExecute_t executeMsg;
-  int ret;
-
-  if ( plex86State != Plex86StateReady ) {
-    fprintf(stderr, "plex86: plex86ExecuteInVM: not in ready state (0x%x)\n",
-            plex86State);
-    BX_PANIC(("plex86ExecuteInVM: bailing"));
-    return(0);
-    }
-
-  executeMsg.executeMethod = Plex86ExecuteMethodNative;
-  plex86GuestCPU->edi = cpu->gen_reg[BX_32BIT_REG_EDI].dword.erx;
-  plex86GuestCPU->esi = cpu->gen_reg[BX_32BIT_REG_ESI].dword.erx;
-  plex86GuestCPU->ebp = cpu->gen_reg[BX_32BIT_REG_EBP].dword.erx;
-  plex86GuestCPU->esp = cpu->gen_reg[BX_32BIT_REG_ESP].dword.erx;
-  plex86GuestCPU->ebx = cpu->gen_reg[BX_32BIT_REG_EBX].dword.erx;
-  plex86GuestCPU->edx = cpu->gen_reg[BX_32BIT_REG_EDX].dword.erx;
-  plex86GuestCPU->ecx = cpu->gen_reg[BX_32BIT_REG_ECX].dword.erx;
-  plex86GuestCPU->eax = cpu->gen_reg[BX_32BIT_REG_EAX].dword.erx;
-
-  plex86GuestCPU->eflags = cpu->eflags.val32;
-  plex86GuestCPU->eip = cpu->dword.eip;
-
-  // ES/CS/SS/DS/FS/GS
-  for (unsigned s=0; s<6; s++) {
-    plex86GuestCPU->sreg[s].sel.raw = cpu->sregs[s].selector.value;
-    copyBochsDescriptorToPlex86(&plex86GuestCPU->sreg[s].des,
-                                &cpu->sregs[s].cache);
-    plex86GuestCPU->sreg[s].valid = cpu->sregs[s].cache.valid;
-    }
-
-  // LDTR
-  plex86GuestCPU->ldtr.sel.raw = cpu->ldtr.selector.value;
-  copyBochsDescriptorToPlex86(&plex86GuestCPU->ldtr.des, &cpu->ldtr.cache);
-  plex86GuestCPU->ldtr.valid = cpu->ldtr.cache.valid;
-
-  // TR
-  plex86GuestCPU->tr.sel.raw = cpu->tr.selector.value;
-  copyBochsDescriptorToPlex86(&plex86GuestCPU->tr.des, &cpu->tr.cache);
-  plex86GuestCPU->tr.valid = cpu->tr.cache.valid;
-
-  // GDTR/IDTR
-  plex86GuestCPU->gdtr.base  = cpu->gdtr.base;
-  plex86GuestCPU->gdtr.limit = cpu->gdtr.limit;
-  plex86GuestCPU->idtr.base  = cpu->idtr.base;
-  plex86GuestCPU->idtr.limit = cpu->idtr.limit;
-
-  plex86GuestCPU->dr0 = cpu->dr0;
-  plex86GuestCPU->dr1 = cpu->dr1;
-  plex86GuestCPU->dr2 = cpu->dr2;
-  plex86GuestCPU->dr3 = cpu->dr3;
-  plex86GuestCPU->dr6 = cpu->dr6;
-  plex86GuestCPU->dr7 = cpu->dr7;
-
-  plex86GuestCPU->tr3 = 0; // Unimplemented in bochs.
-  plex86GuestCPU->tr4 = 0; // Unimplemented in bochs.
-  plex86GuestCPU->tr5 = 0; // Unimplemented in bochs.
-  plex86GuestCPU->tr6 = 0; // Unimplemented in bochs.
-  plex86GuestCPU->tr7 = 0; // Unimplemented in bochs.
-
-  plex86GuestCPU->cr0.raw = cpu->cr0.val32;
-  plex86GuestCPU->cr1     = cpu->cr1;
-  plex86GuestCPU->cr2     = cpu->cr2;
-  plex86GuestCPU->cr3     = cpu->cr3;
-  plex86GuestCPU->cr4.raw = cpu->cr4.registerValue;
-
-  plex86GuestCPU->a20Enable = BX_GET_ENABLE_A20();
-
-  ret = ioctl(plex86FD, PLEX86_EXECUTE, &executeMsg);
-  if (ret != 0) {
-    fprintf(stderr, "plex86: ioctl(PLEX86_EXECUTE): ");
-    switch (ret) {
-      case Plex86NoExecute_Method:
-        fprintf(stderr, "bad execute method.\n");
-        break;
-      case Plex86NoExecute_CR0:
-        fprintf(stderr, "bad CR0 value.\n");
-        break;
-      case Plex86NoExecute_CR4:
-        fprintf(stderr, "bad CR4 value.\n");
-        break;
-      case Plex86NoExecute_CS:
-        fprintf(stderr, "bad CS value.\n");
-        break;
-      case Plex86NoExecute_A20:
-        fprintf(stderr, "bad A20 enable value.\n");
-        break;
-      case Plex86NoExecute_Selector:
-        fprintf(stderr, "bad selector value.\n");
-        break;
-      case Plex86NoExecute_DPL:
-        fprintf(stderr, "bad descriptor DPL.\n");
-        break;
-      case Plex86NoExecute_EFlags:
-        fprintf(stderr, "bad EFlags.\n");
-        break;
-      case Plex86NoExecute_Panic:
-        fprintf(stderr, "panic.\n");
-        break;
-      case Plex86NoExecute_VMState:
-        fprintf(stderr, "bad VM state.\n");
-        break;
-      default:
-        fprintf(stderr, "ret = %d\n", ret);
-      }
-    }
-  else {
-    switch ( executeMsg.monitorState.request ) {
-      case MonReqFlushPrintBuf:
-        fprintf(stderr, "plex86: MonReqFlushPrintBuf:\n");
-        fprintf(stderr, "::%s\n", plex86PrintBuffer);
-        break;
-      case MonReqPanic:
-        fprintf(stderr, "plex86: MonReqPanic:\n");
-        fprintf(stderr, "::%s\n", plex86PrintBuffer);
-        break;
-      //case MonReqNone:
-      //  copyPlex86StateToBochs(cpu);
-      //  return(0); /* All OK. */
-      case MonReqGuestFault:
-        faultCount[ executeMsg.monitorState.guestFaultNo ]++;
-        copyPlex86StateToBochs(cpu);
-        return(0); /* All OK. */
-      default:
-        fprintf(stderr, "plex86: executeMsg.request = %u\n",
-                executeMsg.monitorState.request);
-        break;
-      }
-    }
-
-  plex86TearDown();
-  BX_PANIC(("plex86ExecuteInVM: bailing"));
-
-  return(0);
-}
-
-  void
-copyPlex86StateToBochs(BX_CPU_C *cpu)
-{
-  cpu->gen_reg[BX_32BIT_REG_EDI].dword.erx = plex86GuestCPU->edi;
-  cpu->gen_reg[BX_32BIT_REG_ESI].dword.erx = plex86GuestCPU->esi;
-  cpu->gen_reg[BX_32BIT_REG_EBP].dword.erx = plex86GuestCPU->ebp;
-  cpu->gen_reg[BX_32BIT_REG_ESP].dword.erx = plex86GuestCPU->esp;
-  cpu->gen_reg[BX_32BIT_REG_EBX].dword.erx = plex86GuestCPU->ebx;
-  cpu->gen_reg[BX_32BIT_REG_EDX].dword.erx = plex86GuestCPU->edx;
-  cpu->gen_reg[BX_32BIT_REG_ECX].dword.erx = plex86GuestCPU->ecx;
-  cpu->gen_reg[BX_32BIT_REG_EAX].dword.erx = plex86GuestCPU->eax;
-
-  cpu->eflags.val32 = plex86GuestCPU->eflags;
-  cpu->dword.eip    = plex86GuestCPU->eip;
-
-  // Set fields used for exception processing.
-  cpu->prev_eip = plex86GuestCPU->eip;
-  cpu->prev_esp = plex86GuestCPU->esp;
-
-  // ES/CS/SS/DS/FS/GS
-  for (unsigned s=0; s<6; s++) {
-    cpu->sregs[s].selector.value = plex86GuestCPU->sreg[s].sel.raw;
-    cpu->sregs[s].cache.valid    = plex86GuestCPU->sreg[s].valid;
-    if ( (cpu->sregs[s].selector.value & 0xfffc) == 0 ) {
-      /* Null selector. */
-      if ( cpu->sregs[s].cache.valid ) {
-        plex86TearDown();
-        BX_PANIC(("copyPlex86StateToBochs: null descriptor [%u] "
-                  "with descriptor cache valid bit set.", s));
-        }
-      /* valid bit == 0, invalidates a bochs descriptor cache. */
-      }
-    else {
-      /* Non-null selector. */
-      if ( cpu->sregs[s].cache.valid==0 ) {
-        plex86TearDown();
-        BX_PANIC(("copyPlex86StateToBochs: non-null descriptor [%u] "
-                  "with descriptor cache valid bit clear.", s));
-        }
-      copyPlex86DescriptorToBochs(cpu, &cpu->sregs[s].cache,
-          &plex86GuestCPU->sreg[s].des);
-      }
-    }
-}
-
-  void
-copyBochsDescriptorToPlex86(descriptor_t *plex86Desc, bx_descriptor_t *bochsDesc)
-{
-  // For now this function is a hack to convert from bochs descriptor
-  // cache fields which are parsed out into separate fields, to
-  // a packed descriptor format as stored in a real segment descriptor.
-  // This is user only for code/data segments and the LDTR/TR.
-  // Ideally, bochs would store the 64-bit segment descriptor when
-  // it loads segment registers.
-
-  if (bochsDesc->valid == 0) {
-    memset(plex86Desc, 0, sizeof(*plex86Desc));
-    return;
-    }
-  plex86Desc->p = bochsDesc->p;
-  plex86Desc->dpl = bochsDesc->dpl;
-  plex86Desc->type = (bochsDesc->segment<<4) | bochsDesc->type;
-  if (bochsDesc->segment) {
-    // Code/Data segment type.
-    Bit32u limit = bochsDesc->u.segment.limit;
-    plex86Desc->limit_low  = limit; // Only lower 16-bits.
-    plex86Desc->limit_high = limit >> 16;
-    Bit32u base = bochsDesc->u.segment.base;
-    plex86Desc->base_low  = base;
-    plex86Desc->base_med  = base >> 16;
-    plex86Desc->base_high = base >> 24;
-    plex86Desc->avl = bochsDesc->u.segment.avl;
-    plex86Desc->reserved = 0;
-    plex86Desc->d_b = bochsDesc->u.segment.d_b;
-    plex86Desc->g   = bochsDesc->u.segment.g;
-    }
-  else if (bochsDesc->type == 2) {
-    // LDT descriptor.
-    plex86Desc->limit_low  = bochsDesc->u.ldt.limit;
-    plex86Desc->limit_high = 0;
-    Bit32u base = bochsDesc->u.ldt.base;
-    plex86Desc->base_low  = base;
-    plex86Desc->base_med  = base >> 16;
-    plex86Desc->base_high = base >> 24;
-    plex86Desc->avl = 0;
-    plex86Desc->reserved = 0;
-    plex86Desc->d_b = 0;
-    plex86Desc->g   = 0;
-    }
-  else if ( (bochsDesc->type == 9) || (bochsDesc->type==1) ) {
-    // TSS
-    Bit32u limit = bochsDesc->u.tss386.limit;
-    plex86Desc->limit_low  = limit; // Only lower 16-bits.
-    plex86Desc->limit_high = limit >> 16;
-    Bit32u base = bochsDesc->u.tss386.base;
-    plex86Desc->base_low  = base;
-    plex86Desc->base_med  = base >> 16;
-    plex86Desc->base_high = base >> 24;
-    plex86Desc->avl = bochsDesc->u.tss386.avl;
-    plex86Desc->reserved = 0;
-    plex86Desc->d_b = 0;
-    plex86Desc->g   = bochsDesc->u.tss386.g;
-    }
-  else {
-    BX_PANIC(("copyBochsDescriptorToPlex86: desc type = %u.",
-              bochsDesc->type));
-    }
-}
-
-  void
-copyPlex86DescriptorToBochs(BX_CPU_C *cpu,
-                            bx_descriptor_t *bochsDesc, descriptor_t *plex86Desc)
-{
-  Bit32u dword1, dword2, *dwordPtr;
-  dwordPtr = (Bit32u *) plex86Desc;
-
-  /* We can assume little endian, since we're running an x86 VM. */
-  dword1 = dwordPtr[0];
-  dword2 = dwordPtr[1];
-  cpu->parse_descriptor(dword1, dword2, bochsDesc);
-}
-
-  unsigned
-plex86RegisterGuestMemory(Bit8u *vector, unsigned bytes)
-{
-  plex86IoctlRegisterMem_t ioctlMsg;
-
-  if (plex86FD < 0) {
-    // If the plex86 File Descriptor has not been opened yet.
-    if ( !openFD() ) {
-      return(0); // Error.
-      }
-    }
-
-  if (bytes & 0x3fffff) {
-    // Memory size must be multiple of 4Meg.
-    fprintf(stderr, "plex86: RegisterGuestMemory: memory size of %u bytes"
-                    "is not a 4Meg increment.\n", bytes);
-    return(0); // Error.
-    }
-  if ( ((unsigned)vector) & 0xfff ) {
-    // Memory vector must be page aligned.
-    fprintf(stderr, "plex86: RegisterGuestMemory: vector not page aligned.");
-    return(0); // Error.
-    }
-  ioctlMsg.nMegs = bytes >> 20;
-  ioctlMsg.guestPhyMemVector = (Bit32u) vector;
-  ioctlMsg.logBufferWindow   = (Bit32u) plex86PrintBuffer;
-  ioctlMsg.guestCPUWindow    = (Bit32u) plex86GuestCPU;
-  if (ioctl(plex86FD, PLEX86_REGISTER_MEMORY, &ioctlMsg) == -1) {
-    return(0); // Error.
-    }
-  plex86MemSize = bytes;
-
-  /* For now... */
-plex86State |= Plex86StateMemAllocated;
-plex86State |= Plex86StateMMapPhyMem;
-plex86State |= Plex86StateMMapPrintBuffer;
-plex86State |= Plex86StateMMapGuestCPU;
-// Zero out printbuffer and guestcpu here?
-
-  fprintf(stderr, "plex86: RegisterGuestMemory: %uMB succeeded.\n",
-          ioctlMsg.nMegs);
-  return(1); // OK.
-}
-
-  unsigned
-plex86UnregisterGuestMemory(Bit8u *vector, unsigned bytes)
-{
-  return(1); // OK.
-}
diff -Nur bochs-2.0.2+20030829.old/plex86-interface.h bochs-2.0.2+20030829/plex86-interface.h
--- bochs-2.0.2+20030829.old/plex86-interface.h	2003-01-09 04:03:36.000000000 +0000
+++ bochs-2.0.2+20030829/plex86-interface.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,37 +0,0 @@
-/////////////////////////////////////////////////////////////////////////
-//// $Id: plex86-interface.h,v 1.4 2003/01/09 04:03:36 kevinlawton Exp $
-///////////////////////////////////////////////////////////////////////////
-////
-////  Copyright (C) 2002  Kevin P. Lawton
-////
-////  This library is free software; you can redistribute it and/or
-////  modify it under the terms of the GNU Lesser General Public
-////  License as published by the Free Software Foundation; either
-////  version 2 of the License, or (at your option) any later version.
-////
-////  This library is distributed in the hope that it will be useful,
-////  but WITHOUT ANY WARRANTY; without even the implied warranty of
-////  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-////  Lesser General Public License for more details.
-////
-////  You should have received a copy of the GNU Lesser General Public
-////  License along with this library; if not, write to the Free Software
-////  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
-
-#include "plex86/plex86.h"
-
-#define Plex86StateMemAllocated     0x01
-#define Plex86StateMMapPhyMem       0x02
-#define Plex86StateMMapPrintBuffer  0x04
-#define Plex86StateMMapGuestCPU     0x08
-#define Plex86StateReady            0x0f /* All bits set. */
-
-
-extern unsigned     plex86State;
-extern int          plex86FD;
-
-extern unsigned plex86CpuInfo(BX_CPU_C *cpu);
-extern unsigned plex86TearDown(void);
-extern unsigned plex86ExecuteInVM(BX_CPU_C *cpu);
-extern unsigned plex86RegisterGuestMemory(Bit8u *vector, unsigned bytes);
-extern unsigned plex86UnregisterGuestMemory(Bit8u *vector, unsigned bytes);
diff -Nur bochs-2.0.2+20030829.old/plex86.cc bochs-2.0.2+20030829/plex86.cc
--- bochs-2.0.2+20030829.old/plex86.cc	1970-01-01 00:00:00.000000000 +0000
+++ bochs-2.0.2+20030829/plex86.cc	2003-08-29 14:31:40.000000000 +0000
@@ -0,0 +1,438 @@
+/////////////////////////////////////////////////////////////////////////
+//// $Id: plex86.cc,v 0.000 2002/12/24 09:14:54 cbothamy Exp $
+///////////////////////////////////////////////////////////////////////////
+////
+////  Copyright (C) 2002  Kevin P. Lawton
+////
+////  This library is free software; you can redistribute it and/or
+////  modify it under the terms of the GNU Lesser General Public
+////  License as published by the Free Software Foundation; either
+////  version 2 of the License, or (at your option) any later version.
+////
+////  This library is distributed in the hope that it will be useful,
+////  but WITHOUT ANY WARRANTY; without even the implied warranty of
+////  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+////  Lesser General Public License for more details.
+////
+////  You should have received a copy of the GNU Lesser General Public
+////  License along with this library; if not, write to the Free Software
+////  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+
+
+#include "bochs.h"
+#include <sys/ioctl.h>
+#include <unistd.h>
+#include <sys/mman.h>
+#include "plex86.h"
+
+#define LOG_THIS genlog->
+
+
+unsigned     plex86State = 0;
+int          plex86FD = -1;
+Bit8u       *plex86MemPtr = 0;
+size_t       plex86MemSize = 0;
+Bit8u       *plex86PrintBuffer = 0;
+guest_cpu_t *plex86GuestCPU = 0;
+
+static void copyPlex86StateToBochs(BX_CPU_C *cpu);
+static void copyBochsDescriptorToPlex86(descriptor_t *, bx_descriptor_t *);
+static void copyPlex86DescriptorToBochs(BX_CPU_C *,
+                                        bx_descriptor_t *, descriptor_t *);
+
+static unsigned faultCount[32];
+
+
+  int
+plex86Open(void)
+{
+  if (plex86State) {
+    // This should be the first operation; no state should be set yet.
+    fprintf(stderr, "plex86Open: plex86State = 0x%x\n", plex86State);
+    return(-1); // Error.
+    }
+
+  // Open a new VM.
+  fprintf(stderr, "Opening VM.\n");
+  fprintf(stderr, "Trying /dev/misc/plex86...");
+  plex86FD = open("/dev/misc/plex86", O_RDWR);
+  if (plex86FD >= 0) {
+    fprintf(stderr, "OK.\n");
+    plex86State |= Plex86StateFDOpened; // Kernel device opened.
+    }
+  else {
+    fprintf(stderr, "failed.\n");
+    // Try the old name.
+    fprintf(stderr, "Trying /dev/plex86...");
+    plex86FD = open("/dev/plex86", O_RDWR);
+    if (plex86FD >= 0) {
+      fprintf(stderr, "OK.\n");
+      plex86State |= Plex86StateFDOpened; // Kernel device opened.
+      }
+    else {
+      fprintf(stderr, "failed.\n");
+      fprintf(stderr, "won't use the Plex86 backend.\n");
+      perror ("open");
+      }
+    }
+
+  return(plex86FD); // File descriptor is return val.
+}
+
+  Bit8u *
+plex86AllocateMemory(unsigned nMegs)
+{
+  Bit8u *ptr;
+
+  plex86MemSize = nMegs * 1024 * 1024;
+
+  if (plex86State != Plex86StateFDOpened) {
+    fprintf(stderr, "plex86AllocateMemory: plex86State = 0x%x\n", plex86State);
+    return(0);
+    }
+
+  // Allocate memory from the host OS for the virtual physical memory.
+  fprintf(stderr, "Allocating %dMB of physical memory in VM.\n", nMegs);
+  if (ioctl(plex86FD, PLEX86_ALLOCVPHYS, nMegs) == -1) {
+    perror("ioctl ALLOCVPHYS: ");
+    plex86TearDown();
+    return(0);
+    }
+  plex86State |= Plex86StateMemAllocated;
+
+  // Map guest virtual physical memory into user address space and zero it.
+  fprintf(stderr, "Mapping virtualized physical memory into monitor.\n");
+  ptr = (Bit8u*) mmap(NULL, plex86MemSize, PROT_READ | PROT_WRITE,
+      MAP_SHARED, plex86FD, 0);
+  if (ptr == (void *) -1) {
+    perror("mmap of physical pages");
+    plex86TearDown();
+    return(0);
+    }
+  plex86State |= Plex86StateMMapPhyMem;
+
+  plex86MemPtr = ptr;
+  fprintf(stderr, "Zeroing virtualized physical memory.\n");
+  memset(ptr, 0, plex86MemSize);
+
+  // Create a memory mapping of the monitor's print buffer into
+  // user memory.  This is used for efficient printing of info that
+  // the monitor prints out.
+  fprintf(stderr, "Mapping monitor print buffer into user mem.\n");
+  plex86PrintBuffer = (Bit8u*) mmap(NULL, 4096, PROT_READ,
+      MAP_SHARED, plex86FD, plex86MemSize + 0*4096);
+  if (plex86PrintBuffer == (void *) -1) {
+    perror("mmap of monitor print buffer");
+    plex86TearDown();
+    return(0);
+    }
+  plex86State |= Plex86StateMMapPrintBuffer;
+
+  // Create a memory mapping of the monitor's guest_cpu structure into
+  // user memory.  This is used for passing the guest_cpu state between
+  // user and kernel/monitor space.
+  fprintf(stderr, "Mapping guest_cpu structure into user mem.\n");
+  plex86GuestCPU = (guest_cpu_t *) mmap(NULL, 4096, PROT_READ | PROT_WRITE,
+      MAP_SHARED, plex86FD, plex86MemSize + 1*4096);
+  if (plex86GuestCPU == (void *) -1) {
+    perror("mmap of guest_cpu structure");
+    plex86TearDown();
+    return(0);
+    }
+  plex86State |= Plex86StateMMapGuestCPU;
+  fprintf(stderr, "Zeroing guest_cpu structure.\n");
+  memset(plex86GuestCPU, 0, 4096);
+
+  // All setup has completed.
+  plex86State |= Plex86StateReady;
+
+  return(ptr);
+}
+
+  unsigned
+plex86TearDown(void)
+{
+  fprintf(stderr, "plex86TearDown called.\n");
+for (unsigned f=0; f<32; f++) {
+  if (faultCount[f])
+    fprintf(stderr, "FC[%u] = %u\n", f, faultCount[f]);
+  }
+
+  if ( !(plex86State & Plex86StateFDOpened) ) {
+    fprintf(stderr, "plex86TearDown: FD not open.\n");
+    return(0);
+    }
+
+  plex86State &= ~Plex86StateReady; // Mark as not ready any more.
+
+  if ( plex86State & Plex86StateMMapPhyMem ) {
+    fprintf(stderr, "Unmapping guest physical memory.\n");
+    if (munmap(plex86MemPtr, plex86MemSize) != 0) {
+      perror ("munmap of guest physical memory");
+      return(0); // Failed.
+      }
+    }
+  plex86State &= ~Plex86StateMMapPhyMem;
+
+  if ( plex86State & Plex86StateMMapPrintBuffer ) {
+    fprintf(stderr, "Unmapping print buffer.\n");
+    if (munmap(plex86PrintBuffer, 4096) != 0) {
+      perror("munmap of print buffer.");
+      return(0); // Failed.
+      }
+    }
+  plex86State &= ~Plex86StateMMapPrintBuffer;
+
+  if ( plex86State & Plex86StateMMapGuestCPU ) {
+    fprintf(stderr, "Unmapping guest_cpu structure.\n");
+    if (munmap(plex86GuestCPU, 4096) != 0) {
+      perror("munmap of guest_cpu structure.");
+      return(0); // Failed.
+      }
+    }
+  plex86State &= ~Plex86StateMMapGuestCPU;
+
+  fprintf(stderr, "Tearing down VM.\n");
+  if (ioctl(plex86FD, PLEX86_TEARDOWN, 0) == -1) {
+    perror("ioctl TEARDOWN: ");
+    return(0); // Failed.
+    }
+  plex86State &= ~Plex86StateMemAllocated;
+
+  // Close the connection to the kernel module.
+  fprintf(stderr, "Closing VM device.\n");
+  if (close(plex86FD) == -1) {
+    perror("close of VM device\n");
+    return(0); // Failed.
+    }
+  plex86State &= ~Plex86StateFDOpened;
+
+  plex86State = 0; // For good measure.
+
+  return(1); // OK.
+}
+
+  unsigned
+plex86ExecuteInVM(BX_CPU_C *cpu)
+{
+  plex86IoctlExecute_t executeMsg;
+  int ret;
+
+  if ( (plex86State & Plex86StateReady) == 0 ) {
+    fprintf(stderr, "plex86ExecuteInVM: not in ready state (0x%x)\n",
+            plex86State);
+    return(0);
+    }
+
+  executeMsg.executeMethod = Plex86ExecuteMethodNative;
+  plex86GuestCPU->edi = cpu->gen_reg[BX_32BIT_REG_EDI].dword.erx;
+  plex86GuestCPU->esi = cpu->gen_reg[BX_32BIT_REG_ESI].dword.erx;
+  plex86GuestCPU->ebp = cpu->gen_reg[BX_32BIT_REG_EBP].dword.erx;
+  plex86GuestCPU->esp = cpu->gen_reg[BX_32BIT_REG_ESP].dword.erx;
+  plex86GuestCPU->ebx = cpu->gen_reg[BX_32BIT_REG_EBX].dword.erx;
+  plex86GuestCPU->edx = cpu->gen_reg[BX_32BIT_REG_EDX].dword.erx;
+  plex86GuestCPU->ecx = cpu->gen_reg[BX_32BIT_REG_ECX].dword.erx;
+  plex86GuestCPU->eax = cpu->gen_reg[BX_32BIT_REG_EAX].dword.erx;
+
+  plex86GuestCPU->eflags = cpu->eflags.val32;
+  plex86GuestCPU->eip = cpu->dword.eip;
+
+  // ES/CS/SS/DS/FS/GS
+  for (unsigned s=0; s<6; s++) {
+    plex86GuestCPU->sreg[s].sel.raw = cpu->sregs[s].selector.value;
+    copyBochsDescriptorToPlex86(&plex86GuestCPU->sreg[s].des,
+                                &cpu->sregs[s].cache);
+    plex86GuestCPU->sreg[s].valid = cpu->sregs[s].cache.valid;
+    }
+
+  // LDTR
+  plex86GuestCPU->ldtr.sel.raw = cpu->ldtr.selector.value;
+  copyBochsDescriptorToPlex86(&plex86GuestCPU->ldtr.des, &cpu->ldtr.cache);
+  plex86GuestCPU->ldtr.valid = cpu->ldtr.cache.valid;
+
+  // TR
+  plex86GuestCPU->tr.sel.raw = cpu->tr.selector.value;
+  copyBochsDescriptorToPlex86(&plex86GuestCPU->tr.des, &cpu->tr.cache);
+  plex86GuestCPU->tr.valid = cpu->tr.cache.valid;
+
+  // GDTR/IDTR
+  plex86GuestCPU->gdtr.base  = cpu->gdtr.base;
+  plex86GuestCPU->gdtr.limit = cpu->gdtr.limit;
+  plex86GuestCPU->idtr.base  = cpu->idtr.base;
+  plex86GuestCPU->idtr.limit = cpu->idtr.limit;
+
+  plex86GuestCPU->dr0 = cpu->dr0;
+  plex86GuestCPU->dr1 = cpu->dr1;
+  plex86GuestCPU->dr2 = cpu->dr2;
+  plex86GuestCPU->dr3 = cpu->dr3;
+  plex86GuestCPU->dr6 = cpu->dr6;
+  plex86GuestCPU->dr7 = cpu->dr7;
+
+  plex86GuestCPU->tr3 = 0; // Unimplemented in bochs.
+  plex86GuestCPU->tr4 = 0; // Unimplemented in bochs.
+  plex86GuestCPU->tr5 = 0; // Unimplemented in bochs.
+  plex86GuestCPU->tr6 = 0; // Unimplemented in bochs.
+  plex86GuestCPU->tr7 = 0; // Unimplemented in bochs.
+
+  plex86GuestCPU->cr0.raw = cpu->cr0.val32;
+  plex86GuestCPU->cr1     = cpu->cr1;
+  plex86GuestCPU->cr2     = cpu->cr2;
+  plex86GuestCPU->cr3     = cpu->cr3;
+  plex86GuestCPU->cr4.raw = cpu->cr4.registerValue;
+
+  plex86GuestCPU->a20Enable = BX_GET_ENABLE_A20();
+
+  ret = ioctl(plex86FD, PLEX86_EXECUTE, &executeMsg);
+  if (ret < 0) {
+    fprintf(stderr, "ioctl(PLEX86_EXECUTE) returns < 0\n");
+    }
+
+  switch ( executeMsg.monitorState.request ) {
+    case MonReqFlushPrintBuf:
+      fprintf(stderr, "MonReqFlushPrintBuf:\n");
+      fprintf(stderr, "::%s\n", plex86PrintBuffer);
+      break;
+    case MonReqPanic:
+      fprintf(stderr, "MonReqPanic:\n");
+      fprintf(stderr, "::%s\n", plex86PrintBuffer);
+      break;
+    //case MonReqNone:
+    //  copyPlex86StateToBochs(cpu);
+    //  return(0); /* All OK. */
+    case MonReqGuestFault:
+      faultCount[ executeMsg.monitorState.guestFaultNo ]++;
+      copyPlex86StateToBochs(cpu);
+      return(0); /* All OK. */
+    default:
+      fprintf(stderr, "executeMsg.request = %u\n",
+              executeMsg.monitorState.request);
+      break;
+    }
+
+  plex86TearDown();
+  BX_PANIC(("plex86ExecuteInVM: bailing"));
+
+  return(0);
+}
+
+  void
+copyPlex86StateToBochs(BX_CPU_C *cpu)
+{
+  cpu->gen_reg[BX_32BIT_REG_EDI].dword.erx = plex86GuestCPU->edi;
+  cpu->gen_reg[BX_32BIT_REG_ESI].dword.erx = plex86GuestCPU->esi;
+  cpu->gen_reg[BX_32BIT_REG_EBP].dword.erx = plex86GuestCPU->ebp;
+  cpu->gen_reg[BX_32BIT_REG_ESP].dword.erx = plex86GuestCPU->esp;
+  cpu->gen_reg[BX_32BIT_REG_EBX].dword.erx = plex86GuestCPU->ebx;
+  cpu->gen_reg[BX_32BIT_REG_EDX].dword.erx = plex86GuestCPU->edx;
+  cpu->gen_reg[BX_32BIT_REG_ECX].dword.erx = plex86GuestCPU->ecx;
+  cpu->gen_reg[BX_32BIT_REG_EAX].dword.erx = plex86GuestCPU->eax;
+
+  cpu->eflags.val32 = plex86GuestCPU->eflags;
+  cpu->dword.eip    = plex86GuestCPU->eip;
+
+  // Set fields used for exception processing.
+  cpu->prev_eip = plex86GuestCPU->eip;
+  cpu->prev_esp = plex86GuestCPU->esp;
+
+  // ES/CS/SS/DS/FS/GS
+  for (unsigned s=0; s<6; s++) {
+    cpu->sregs[s].selector.value = plex86GuestCPU->sreg[s].sel.raw;
+    cpu->sregs[s].cache.valid    = plex86GuestCPU->sreg[s].valid;
+    if ( (cpu->sregs[s].selector.value & 0xfffc) == 0 ) {
+      /* Null selector. */
+      if ( cpu->sregs[s].cache.valid ) {
+        plex86TearDown();
+        BX_PANIC(("copyPlex86StateToBochs: null descriptor [%u] "
+                  "with descriptor cache valid bit set.", s));
+        }
+      /* valid bit == 0, invalidates a bochs descriptor cache. */
+      }
+    else {
+      /* Non-null selector. */
+      if ( cpu->sregs[s].cache.valid==0 ) {
+        plex86TearDown();
+        BX_PANIC(("copyPlex86StateToBochs: non-null descriptor [%u] "
+                  "with descriptor cache valid bit clear.", s));
+        }
+      copyPlex86DescriptorToBochs(cpu, &cpu->sregs[s].cache,
+          &plex86GuestCPU->sreg[s].des);
+      }
+    }
+}
+
+  void
+copyBochsDescriptorToPlex86(descriptor_t *plex86Desc, bx_descriptor_t *bochsDesc)
+{
+  // For now this function is a hack to convert from bochs descriptor
+  // cache fields which are parsed out into separate fields, to
+  // a packed descriptor format as stored in a real segment descriptor.
+  // This is user only for code/data segments and the LDTR/TR.
+  // Ideally, bochs would store the 64-bit segment descriptor when
+  // it loads segment registers.
+
+  if (bochsDesc->valid == 0) {
+    memset(plex86Desc, 0, sizeof(*plex86Desc));
+    return;
+    }
+  plex86Desc->p = bochsDesc->p;
+  plex86Desc->dpl = bochsDesc->dpl;
+  plex86Desc->type = (bochsDesc->segment<<4) | bochsDesc->type;
+  if (bochsDesc->segment) {
+    // Code/Data segment type.
+    Bit32u limit = bochsDesc->u.segment.limit;
+    plex86Desc->limit_low  = limit; // Only lower 16-bits.
+    plex86Desc->limit_high = limit >> 16;
+    Bit32u base = bochsDesc->u.segment.base;
+    plex86Desc->base_low  = base;
+    plex86Desc->base_med  = base >> 16;
+    plex86Desc->base_high = base >> 24;
+    plex86Desc->avl = bochsDesc->u.segment.avl;
+    plex86Desc->reserved = 0;
+    plex86Desc->d_b = bochsDesc->u.segment.d_b;
+    plex86Desc->g   = bochsDesc->u.segment.g;
+    }
+  else if (bochsDesc->type == 2) {
+    // LDT descriptor.
+    plex86Desc->limit_low  = bochsDesc->u.ldt.limit;
+    plex86Desc->limit_high = 0;
+    Bit32u base = bochsDesc->u.ldt.base;
+    plex86Desc->base_low  = base;
+    plex86Desc->base_med  = base >> 16;
+    plex86Desc->base_high = base >> 24;
+    plex86Desc->avl = 0;
+    plex86Desc->reserved = 0;
+    plex86Desc->d_b = 0;
+    plex86Desc->g   = 0;
+    }
+  else if ( (bochsDesc->type == 9) || (bochsDesc->type==1) ) {
+    // TSS
+    Bit32u limit = bochsDesc->u.tss386.limit;
+    plex86Desc->limit_low  = limit; // Only lower 16-bits.
+    plex86Desc->limit_high = limit >> 16;
+    Bit32u base = bochsDesc->u.tss386.base;
+    plex86Desc->base_low  = base;
+    plex86Desc->base_med  = base >> 16;
+    plex86Desc->base_high = base >> 24;
+    plex86Desc->avl = bochsDesc->u.tss386.avl;
+    plex86Desc->reserved = 0;
+    plex86Desc->d_b = 0;
+    plex86Desc->g   = bochsDesc->u.tss386.g;
+    }
+  else {
+    BX_PANIC(("copyBochsDescriptorToPlex86: desc type = %u.",
+              bochsDesc->type));
+    }
+}
+
+  void
+copyPlex86DescriptorToBochs(BX_CPU_C *cpu,
+                            bx_descriptor_t *bochsDesc, descriptor_t *plex86Desc)
+{
+  Bit32u dword1, dword2, *dwordPtr;
+  dwordPtr = (Bit32u *) plex86Desc;
+
+  /* We can assume little endian, since we're running an x86 VM. */
+  dword1 = dwordPtr[0];
+  dword2 = dwordPtr[1];
+  cpu->parse_descriptor(dword1, dword2, bochsDesc);
+}
diff -Nur bochs-2.0.2+20030829.old/plex86.h bochs-2.0.2+20030829/plex86.h
--- bochs-2.0.2+20030829.old/plex86.h	1970-01-01 00:00:00.000000000 +0000
+++ bochs-2.0.2+20030829/plex86.h	2003-08-29 14:31:40.000000000 +0000
@@ -0,0 +1,41 @@
+/////////////////////////////////////////////////////////////////////////
+//// $Id: plex86.h,v 0.000 2002/12/24 09:14:54 cbothamy Exp $
+///////////////////////////////////////////////////////////////////////////
+////
+////  Copyright (C) 2002  Kevin P. Lawton
+////
+////  This library is free software; you can redistribute it and/or
+////  modify it under the terms of the GNU Lesser General Public
+////  License as published by the Free Software Foundation; either
+////  version 2 of the License, or (at your option) any later version.
+////
+////  This library is distributed in the hope that it will be useful,
+////  but WITHOUT ANY WARRANTY; without even the implied warranty of
+////  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+////  Lesser General Public License for more details.
+////
+////  You should have received a copy of the GNU Lesser General Public
+////  License along with this library; if not, write to the Free Software
+////  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+
+#include "plex86/plex86.h"
+
+#define Plex86StateFDOpened         0x01
+#define Plex86StateMemAllocated     0x02
+#define Plex86StateMMapPhyMem       0x04
+#define Plex86StateMMapPrintBuffer  0x08
+#define Plex86StateMMapGuestCPU     0x10
+#define Plex86StateReady            0x20
+
+
+extern unsigned     plex86State;
+extern int          plex86FD;
+extern Bit8u       *plex86MemPtr;
+extern unsigned     plex86MemSize;
+extern Bit8u       *plex86PrintBuffer;
+extern guest_cpu_t *plex86GuestCPU;
+
+extern int      plex86Open(void);
+extern unsigned char * plex86AllocateMemory(unsigned nMegs);
+extern unsigned plex86TearDown(void);
+extern unsigned plex86ExecuteInVM(BX_CPU_C *cpu);

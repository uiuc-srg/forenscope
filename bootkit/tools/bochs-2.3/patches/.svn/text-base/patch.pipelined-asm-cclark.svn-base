----------------------------------------------------------------------
Patch name: patch.pipelined-asm-cclark
Author: Conn Clark
Date: Thu Aug 28 2003
Status: Proposed

Detailed description:

        I have an initial version of my piplined asm patch. I basicaly
        incorporated the flags macros into the inline assembly. This should help
        speed up execution on pentium or newer processors a little bit. In my
        testing some things realy get a boost, others may not get much of one,
        and some programs may suffer a slight decrease in performance. The gains
        out number the losses though. You may not see much of a difference in
        the win95 boot times.

        I have the patch is against a CVS image I pulled down on 8-13-03 . It
        was generated by a "diff -ur" command. I still have some clean ups. I
        get warnings on the arith16.cc and logical16.cc . I don't think I have
        broke the x86-64 code but I'm not sure because I haven't tested it.


Patch was created with:
  cvs diff -u
Apply patch to what version:
  cvs checked out on DATE, release version VER
Instructions:
  To patch, go to main bochs directory.
  Type "patch -p0 < THIS_PATCH_FILE".
----------------------------------------------------------------------
diff -ur bochs/cpu/arith16.cc bochs-modified/cpu/arith16.cc
--- bochs/cpu/arith16.cc	Fri Oct 25 11:26:26 2002
+++ bochs-modified/cpu/arith16.cc	Fri Aug 15 14:59:17 2003
@@ -37,10 +37,7 @@
 BX_CPU_C::INC_RX(bxInstruction_c *i)
 {
 #if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
-  Bit32u flags32;
-
-  asmInc16(BX_CPU_THIS_PTR gen_reg[i->opcodeReg()].word.rx, flags32);
-  setEFlagsOSZAP(flags32);
+  asmInc16PlusFlags(BX_CPU_THIS_PTR gen_reg[i->opcodeReg()].word.rx, BX_CPU_THIS_PTR lf_flags_status, BX_CPU_THIS_PTR eflags.val32);
 #else
   Bit16u rx;
   rx = ++ BX_CPU_THIS_PTR gen_reg[i->opcodeReg()].word.rx;
@@ -53,10 +50,7 @@
 BX_CPU_C::DEC_RX(bxInstruction_c *i)
 {
 #if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
-  Bit32u flags32;
-
-  asmDec16(BX_CPU_THIS_PTR gen_reg[i->opcodeReg()].word.rx, flags32);
-  setEFlagsOSZAP(flags32);
+  asmDec16PlusFlags(BX_CPU_THIS_PTR gen_reg[i->opcodeReg()].word.rx, BX_CPU_THIS_PTR lf_flags_status, BX_CPU_THIS_PTR eflags.val32);
 #else
   Bit16u rx;
 
@@ -70,6 +64,19 @@
   void
 BX_CPU_C::ADD_EwGw(bxInstruction_c *i)
 {
+#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
+  Bit16u op1_16;
+
+  if (i->modC0()) {
+    asmAdd16PlusFlags(BX_READ_16BIT_REG(i->rm()),BX_READ_16BIT_REG(i->nnn()),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    }
+  else {
+    read_RMW_virtual_word(i->seg(), RMAddr(i), &op1_16);
+    asmAdd16PlusFlags(op1_16,BX_READ_16BIT_REG(i->nnn()),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    Write_RMW_virtual_word(op1_16);
+    }
+
+#else
   Bit16u op2_16, op1_16, sum_16;
 
   op2_16 = BX_READ_16BIT_REG(i->nnn());
@@ -86,31 +93,31 @@
     }
 
   SET_FLAGS_OSZAPC_16(op1_16, op2_16, sum_16, BX_INSTR_ADD16);
+#endif
 }
 
 
   void
 BX_CPU_C::ADD_GwEEw(bxInstruction_c *i)
 {
-  Bit16u op1_16, op2_16, sum_16;
-  unsigned nnn = i->nnn();
+  Bit16u op2_16;
 
-  op1_16 = BX_READ_16BIT_REG(nnn);
 
   read_virtual_word(i->seg(), RMAddr(i), &op2_16);
 
 #if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
-  Bit32u flags32;
+asmAdd16PlusFlags(BX_READ_16BIT_REG(i->nnn()),op2_16,BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
 
-  asmAdd16(sum_16, op1_16, op2_16, flags32);
-  setEFlagsOSZAPC(flags32);
 #else
+  Bit16u op1_16, sum_16;
+  unsigned nnn = i->nnn();
+
+  op1_16 = BX_READ_16BIT_REG(nnn);
+
   sum_16 = op1_16 + op2_16;
-#endif
 
   BX_WRITE_16BIT_REG(nnn, sum_16);
 
-#if !(defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
   SET_FLAGS_OSZAPC_16(op1_16, op2_16, sum_16, BX_INSTR_ADD16);
 #endif
 }
@@ -118,24 +125,19 @@
   void
 BX_CPU_C::ADD_GwEGw(bxInstruction_c *i)
 {
+#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
+asmAdd16PlusFlags(BX_READ_16BIT_REG(i->nnn()),BX_READ_16BIT_REG(i->rm()),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+#else
   Bit16u op1_16, op2_16, sum_16;
   unsigned nnn = i->nnn();
 
   op1_16 = BX_READ_16BIT_REG(nnn);
   op2_16 = BX_READ_16BIT_REG(i->rm());
 
-#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
-  Bit32u flags32;
-
-  asmAdd16(sum_16, op1_16, op2_16, flags32);
-  setEFlagsOSZAPC(flags32);
-#else
   sum_16 = op1_16 + op2_16;
-#endif
 
   BX_WRITE_16BIT_REG(nnn, sum_16);
 
-#if !(defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
   SET_FLAGS_OSZAPC_16(op1_16, op2_16, sum_16, BX_INSTR_ADD16);
 #endif
 }
@@ -144,6 +146,9 @@
   void
 BX_CPU_C::ADD_AXIw(bxInstruction_c *i)
 {
+#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
+asmAdd16PlusFlags(AX,i->Iw(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+#else
   Bit16u op1_16, op2_16, sum_16;
 
   op1_16 = AX;
@@ -154,11 +159,36 @@
   AX = sum_16;
 
   SET_FLAGS_OSZAPC_16(op1_16, op2_16, sum_16, BX_INSTR_ADD16);
+#endif
 }
 
   void
 BX_CPU_C::ADC_EwGw(bxInstruction_c *i)
 {
+#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
+  Bit16u op1_16;
+if (getB_CF()){
+  if (i->modC0()) {
+    asmAdc16PlusFlags_carry(BX_READ_16BIT_REG(i->rm()),BX_READ_16BIT_REG(i->nnn()),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    }
+  else {
+    read_RMW_virtual_word(i->seg(), RMAddr(i), &op1_16);
+    asmAdc16PlusFlags_carry(op1_16,BX_READ_16BIT_REG(i->nnn()),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    Write_RMW_virtual_word(op1_16);
+    }
+  }
+else {
+  if (i->modC0()) {
+    asmAdd16PlusFlags(BX_READ_16BIT_REG(i->rm()),BX_READ_16BIT_REG(i->nnn()),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    }
+  else {
+    read_RMW_virtual_word(i->seg(), RMAddr(i), &op1_16);
+    asmAdd16PlusFlags(op1_16,BX_READ_16BIT_REG(i->nnn()),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    Write_RMW_virtual_word(op1_16);
+    }
+  }
+
+#else
   bx_bool temp_CF;
   Bit16u op2_16, op1_16, sum_16;
 
@@ -179,12 +209,34 @@
 
   SET_FLAGS_OSZAPC_16_CF(op1_16, op2_16, sum_16, BX_INSTR_ADC16,
                          temp_CF);
+#endif
 }
 
 
   void
 BX_CPU_C::ADC_GwEw(bxInstruction_c *i)
 {
+#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
+Bit16u op2_16;
+if (getB_CF()) {
+  if (i->modC0()) {
+    op2_16 = BX_READ_16BIT_REG(i->rm());
+    }
+  else {
+    read_virtual_word(i->seg(), RMAddr(i), &op2_16);
+    }
+  asmAdc16PlusFlags_carry(BX_READ_16BIT_REG(i->nnn()),op2_16,BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+  }
+else {
+  if (i->modC0()) {
+    op2_16 = BX_READ_16BIT_REG(i->rm());
+    }
+  else {
+    read_virtual_word(i->seg(), RMAddr(i), &op2_16);
+    }
+  asmAdd16PlusFlags(BX_READ_16BIT_REG(i->nnn()),op2_16,BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+  }
+#else
   bx_bool temp_CF;
   Bit16u op1_16, op2_16, sum_16;
 
@@ -206,12 +258,20 @@
 
   SET_FLAGS_OSZAPC_16_CF(op1_16, op2_16, sum_16, BX_INSTR_ADC16,
                          temp_CF);
+#endif
 }
 
 
   void
 BX_CPU_C::ADC_AXIw(bxInstruction_c *i)
 {
+#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
+if (getB_CF())
+   asmAdc16PlusFlags_carry(AX,i->Iw(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+else
+   asmAdd16PlusFlags(AX,i->Iw(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+
+#else
   bx_bool temp_CF;
   Bit16u op1_16, op2_16, sum_16;
 
@@ -226,6 +286,7 @@
 
   SET_FLAGS_OSZAPC_16_CF(op1_16, op2_16, sum_16, BX_INSTR_ADC16,
                          temp_CF);
+#endif
 }
 
 
@@ -234,6 +295,29 @@
   void
 BX_CPU_C::SBB_EwGw(bxInstruction_c *i)
 {
+#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
+Bit16u op1_16;
+if (getB_CF()){
+  if (i->modC0()) {
+    asmSbb16PlusFlags_borrow(BX_READ_16BIT_REG(i->rm()),BX_READ_16BIT_REG(i->nnn()),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    }
+  else {
+    read_RMW_virtual_word(i->seg(), RMAddr(i), &op1_16);
+    asmSbb16PlusFlags_borrow(op1_16,BX_READ_16BIT_REG(i->nnn()),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    Write_RMW_virtual_word(op1_16);
+    }
+  }
+else {
+  if (i->modC0()) {
+    asmSub16PlusFlags(BX_READ_16BIT_REG(i->rm()),BX_READ_16BIT_REG(i->nnn()),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    }
+  else {
+    read_RMW_virtual_word(i->seg(), RMAddr(i), &op1_16);
+    asmSub16PlusFlags(op1_16,BX_READ_16BIT_REG(i->nnn()),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    Write_RMW_virtual_word(op1_16);
+    }
+  }
+#else
   bx_bool temp_CF;
   Bit16u op2_16, op1_16, diff_16;
 
@@ -254,12 +338,34 @@
 
   SET_FLAGS_OSZAPC_16_CF(op1_16, op2_16, diff_16, BX_INSTR_SBB16,
                          temp_CF);
+#endif
 }
 
 
   void
 BX_CPU_C::SBB_GwEw(bxInstruction_c *i)
 {
+#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
+Bit16u op2_16;
+if (getB_CF()) {
+  if (i->modC0()) {
+    op2_16 = BX_READ_16BIT_REG(i->rm());
+    }
+  else {
+    read_virtual_word(i->seg(), RMAddr(i), &op2_16);
+    }
+  asmSbb16PlusFlags_borrow(BX_READ_16BIT_REG(i->nnn()),op2_16,BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+  }
+else  {
+  if (i->modC0()) {
+    op2_16 = BX_READ_16BIT_REG(i->rm());
+    }
+  else {
+    read_virtual_word(i->seg(), RMAddr(i), &op2_16);
+    }
+  asmSub16PlusFlags(BX_READ_16BIT_REG(i->nnn()),op2_16,BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+  }
+#else
   bx_bool temp_CF;
 
   temp_CF = getB_CF();
@@ -281,12 +387,20 @@
 
   SET_FLAGS_OSZAPC_16_CF(op1_16, op2_16, diff_16, BX_INSTR_SBB16,
                          temp_CF);
+#endif
 }
 
 
   void
 BX_CPU_C::SBB_AXIw(bxInstruction_c *i)
 {
+#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
+if (getB_CF())
+   asmSbb16PlusFlags_borrow(AX,i->Iw(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+else
+   asmSub16PlusFlags(AX,i->Iw(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+
+#else
   bx_bool temp_CF;
   Bit16u op1_16, op2_16, diff_16;
 
@@ -301,6 +415,7 @@
 
   SET_FLAGS_OSZAPC_16_CF(op1_16, op2_16, diff_16, BX_INSTR_SBB16,
                          temp_CF);
+#endif
 }
 
 
@@ -308,6 +423,29 @@
   void
 BX_CPU_C::SBB_EwIw(bxInstruction_c *i)
 {
+#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
+Bit16u op1_16;
+if (getB_CF()){
+  if (i->modC0()) {
+    asmSbb16PlusFlags_borrow(BX_READ_16BIT_REG(i->rm()),i->Iw(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    }
+  else {
+    read_RMW_virtual_word(i->seg(), RMAddr(i), &op1_16);
+    asmSbb16PlusFlags_borrow(op1_16,i->Iw(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    Write_RMW_virtual_word(op1_16);
+    }
+  }
+else {
+  if (i->modC0()) {
+    asmSub16PlusFlags(BX_READ_16BIT_REG(i->rm()),i->Iw(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    }
+  else {
+    read_RMW_virtual_word(i->seg(), RMAddr(i), &op1_16);
+    asmSub16PlusFlags(op1_16,i->Iw(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    Write_RMW_virtual_word(op1_16);
+    }
+  }
+#else
   bx_bool temp_CF;
   Bit16u op2_16, op1_16, diff_16;
 
@@ -328,54 +466,48 @@
 
   SET_FLAGS_OSZAPC_16_CF(op1_16, op2_16, diff_16, BX_INSTR_SBB16,
                          temp_CF);
+#endif
 }
 
 
   void
 BX_CPU_C::SUB_EwGw(bxInstruction_c *i)
 {
-  Bit16u op2_16, op1_16, diff_16;
+  Bit16u op2_16, op1_16;
 
   op2_16 = BX_READ_16BIT_REG(i->nnn());
 
   if (i->modC0()) {
-    op1_16 = BX_READ_16BIT_REG(i->rm());
 #if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
-    Bit32u flags32;
-
-    asmSub16(diff_16, op1_16, op2_16, flags32);
-    setEFlagsOSZAPC(flags32);
+    asmSub16PlusFlags(BX_READ_16BIT_REG(i->rm()),op2_16,BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
 #else
+Bit16u diff_16;
+
+    op1_16 = BX_READ_16BIT_REG(i->rm());
     diff_16 = op1_16 - op2_16;
-#endif
     BX_WRITE_16BIT_REG(i->rm(), diff_16);
+    SET_FLAGS_OSZAPC_16(op1_16, op2_16, diff_16, BX_INSTR_SUB16);
+#endif
     }
   else {
     read_RMW_virtual_word(i->seg(), RMAddr(i), &op1_16);
 #if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
-    Bit32u flags32;
-
-    asmSub16(diff_16, op1_16, op2_16, flags32);
-    setEFlagsOSZAPC(flags32);
+    asmSub16PlusFlags(op1_16,op2_16,BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    Write_RMW_virtual_word(op1_16);
 #else
+Bit16u diff_16;
     diff_16 = op1_16 - op2_16;
-#endif
     Write_RMW_virtual_word(diff_16);
-    }
-
-#if !(defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
-  SET_FLAGS_OSZAPC_16(op1_16, op2_16, diff_16, BX_INSTR_SUB16);
+    SET_FLAGS_OSZAPC_16(op1_16, op2_16, diff_16, BX_INSTR_SUB16);
 #endif
+    }
 }
 
 
   void
 BX_CPU_C::SUB_GwEw(bxInstruction_c *i)
 {
-  Bit16u op1_16, op2_16, diff_16;
-  unsigned nnn = i->nnn();
-
-  op1_16 = BX_READ_16BIT_REG(nnn);
+  Bit16u op2_16;
 
   if (i->modC0()) {
     op2_16 = BX_READ_16BIT_REG(i->rm());
@@ -385,17 +517,17 @@
     }
 
 #if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
-  Bit32u flags32;
-
-  asmSub16(diff_16, op1_16, op2_16, flags32);
-  setEFlagsOSZAPC(flags32);
+asmSub16PlusFlags(BX_READ_16BIT_REG(i->nnn()),op2_16,BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
 #else
+  Bit16u op1_16, diff_16;
+  unsigned nnn = i->nnn();
+
+  op1_16 = BX_READ_16BIT_REG(nnn);
+
   diff_16 = op1_16 - op2_16;
-#endif
 
   BX_WRITE_16BIT_REG(nnn, diff_16);
 
-#if !(defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
   SET_FLAGS_OSZAPC_16(op1_16, op2_16, diff_16, BX_INSTR_SUB16);
 #endif
 }
@@ -403,23 +535,18 @@
   void
 BX_CPU_C::SUB_AXIw(bxInstruction_c *i)
 {
+#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
+asmSub16PlusFlags(AX,i->Iw(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+#else
   Bit16u op1_16, op2_16, diff_16;
 
   op1_16 = AX;
   op2_16 = i->Iw();
 
-#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
-  Bit32u flags32;
-
-  asmSub16(diff_16, op1_16, op2_16, flags32);
-  setEFlagsOSZAPC(flags32);
-#else
   diff_16 = op1_16 - op2_16;
-#endif
 
   AX = diff_16;
 
-#if !(defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
   SET_FLAGS_OSZAPC_16(op1_16, op2_16, diff_16, BX_INSTR_SUB16);
 #endif
 }
@@ -428,9 +555,8 @@
   void
 BX_CPU_C::CMP_EwGw(bxInstruction_c *i)
 {
-  Bit16u op2_16, op1_16;
+  Bit16u op1_16;
 
-  op2_16 = BX_READ_16BIT_REG(i->nnn());
 
   if (i->modC0()) {
     op1_16 = BX_READ_16BIT_REG(i->rm());
@@ -440,12 +566,12 @@
     }
 
 #if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
-  Bit32u flags32;
-
-  asmCmp16(op1_16, op2_16, flags32);
-  setEFlagsOSZAPC(flags32);
+asmCmp16PlusFlags(op1_16,BX_READ_16BIT_REG(i->nnn()),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
 #else
-  Bit16u diff_16;
+  Bit16u op2_16, diff_16;
+
+  op2_16 = BX_READ_16BIT_REG(i->nnn());
+
   diff_16 = op1_16 - op2_16;
 
   SET_FLAGS_OSZAPC_16(op1_16, op2_16, diff_16, BX_INSTR_CMP16);
@@ -453,12 +579,12 @@
 }
 
 
+
   void
 BX_CPU_C::CMP_GwEw(bxInstruction_c *i)
 {
-  Bit16u op1_16, op2_16;
+  Bit16u op2_16;
 
-  op1_16 = BX_READ_16BIT_REG(i->nnn());
 
   if (i->modC0()) {
     op2_16 = BX_READ_16BIT_REG(i->rm());
@@ -468,33 +594,29 @@
     }
 
 #if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
-  Bit32u flags32;
-
-  asmCmp16(op1_16, op2_16, flags32);
-  setEFlagsOSZAPC(flags32);
+asmCmp16PlusFlags(BX_READ_16BIT_REG(i->nnn()),op2_16,BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
 #else
-  Bit16u diff_16;
+  Bit16u op1_16, diff_16;
+
+  op1_16 = BX_READ_16BIT_REG(i->nnn());
+
   diff_16 = op1_16 - op2_16;
 
   SET_FLAGS_OSZAPC_16(op1_16, op2_16, diff_16, BX_INSTR_CMP16);
 #endif
 }
 
-
-  void
+   void
 BX_CPU_C::CMP_AXIw(bxInstruction_c *i)
 {
+#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
+asmCmp16PlusFlags(AX,i->Iw(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+#else
   Bit16u op1_16, op2_16;
 
   op1_16 = AX;
   op2_16 = i->Iw();
 
-#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
-  Bit32u flags32;
-
-  asmCmp16(op1_16, op2_16, flags32);
-  setEFlagsOSZAPC(flags32);
-#else
   Bit16u diff_16;
   diff_16 = op1_16 - op2_16;
 
@@ -569,23 +691,21 @@
   void
 BX_CPU_C::ADD_EEwIw(bxInstruction_c *i)
 {
-  Bit16u op2_16, op1_16, sum_16;
-
-  op2_16 = i->Iw();
+  Bit16u op1_16;
 
   read_RMW_virtual_word(i->seg(), RMAddr(i), &op1_16);
 
 #if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
-  Bit32u flags32;
-
-  asmAdd16(sum_16, op1_16, op2_16, flags32);
-  setEFlagsOSZAPC(flags32);
+asmAdd16PlusFlags(op1_16,i->Iw(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+  Write_RMW_virtual_word(op1_16);
 #else
+  Bit16u op2_16, sum_16;
+
+  op2_16 = i->Iw();
   sum_16 = op1_16 + op2_16;
-#endif
+
   Write_RMW_virtual_word(sum_16);
 
-#if !(defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
   SET_FLAGS_OSZAPC_16(op1_16, op2_16, sum_16, BX_INSTR_ADD16);
 #endif
 }
@@ -593,23 +713,18 @@
   void
 BX_CPU_C::ADD_EGwIw(bxInstruction_c *i)
 {
-  Bit16u op2_16, op1_16, sum_16;
-
-  op2_16 = i->Iw();
+#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
+asmAdd16PlusFlags(BX_READ_16BIT_REG(i->rm()),i->Iw(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+#else
+  Bit16u op1_16, op2_16, sum_16;
 
   op1_16 = BX_READ_16BIT_REG(i->rm());
 
-#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
-  Bit32u flags32;
+  op2_16 = i->Iw();
 
-  asmAdd16(sum_16, op1_16, op2_16, flags32);
-  setEFlagsOSZAPC(flags32);
-#else
   sum_16 = op1_16 + op2_16;
-#endif
   BX_WRITE_16BIT_REG(i->rm(), sum_16);
 
-#if !(defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
   SET_FLAGS_OSZAPC_16(op1_16, op2_16, sum_16, BX_INSTR_ADD16);
 #endif
 }
@@ -617,6 +732,29 @@
   void
 BX_CPU_C::ADC_EwIw(bxInstruction_c *i)
 {
+#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
+Bit16u op1_16;
+if (getB_CF()){
+  if (i->modC0()) {
+    asmAdc16PlusFlags_carry(BX_READ_16BIT_REG(i->rm()),i->Iw(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    }
+  else {
+    read_RMW_virtual_word(i->seg(), RMAddr(i), &op1_16);
+    asmAdc16PlusFlags_carry(op1_16,i->Iw(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    Write_RMW_virtual_word(op1_16);
+    }
+  }
+else {
+  if (i->modC0()) {
+    asmAdd16PlusFlags(BX_READ_16BIT_REG(i->rm()),i->Iw(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    }
+  else {
+    read_RMW_virtual_word(i->seg(), RMAddr(i), &op1_16);
+    asmAdd16PlusFlags(op1_16,i->Iw(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    Write_RMW_virtual_word(op1_16);
+    }
+  }
+#else
   bx_bool temp_CF;
   Bit16u op2_16, op1_16, sum_16;
 
@@ -637,53 +775,46 @@
 
   SET_FLAGS_OSZAPC_16_CF(op1_16, op2_16, sum_16, BX_INSTR_ADC16,
                          temp_CF);
+#endif
 }
 
 
   void
 BX_CPU_C::SUB_EwIw(bxInstruction_c *i)
 {
-  Bit16u op2_16, op1_16, diff_16;
-
-
-  op2_16 = i->Iw();
+  Bit16u  op1_16;
 
   if (i->modC0()) {
-    op1_16 = BX_READ_16BIT_REG(i->rm());
 #if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
-    Bit32u flags32;
-
-    asmSub16(diff_16, op1_16, op2_16, flags32);
-    setEFlagsOSZAPC(flags32);
+    asmSub16PlusFlags(BX_READ_16BIT_REG(i->rm()),i->Iw(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
 #else
+Bit16u op2_16, diff_16;
+    op1_16 = BX_READ_16BIT_REG(i->rm());
+    op2_16 = i->Iw();
     diff_16 = op1_16 - op2_16;
-#endif
     BX_WRITE_16BIT_REG(i->rm(), diff_16);
+    SET_FLAGS_OSZAPC_16(op1_16, op2_16, diff_16, BX_INSTR_SUB16);
+#endif
     }
   else {
     read_RMW_virtual_word(i->seg(), RMAddr(i), &op1_16);
 #if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
-    Bit32u flags32;
-
-    asmSub16(diff_16, op1_16, op2_16, flags32);
-    setEFlagsOSZAPC(flags32);
+    asmSub16PlusFlags(op1_16,i->Iw(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    Write_RMW_virtual_word(op1_16);
 #else
+Bit16u op2_16, diff_16;
+    op2_16 = i->Iw();
     diff_16 = op1_16 - op2_16;
-#endif
     Write_RMW_virtual_word(diff_16);
-    }
-
-#if !(defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
-  SET_FLAGS_OSZAPC_16(op1_16, op2_16, diff_16, BX_INSTR_SUB16);
+    SET_FLAGS_OSZAPC_16(op1_16, op2_16, diff_16, BX_INSTR_SUB16);
 #endif
+    }
 }
 
   void
 BX_CPU_C::CMP_EwIw(bxInstruction_c *i)
 {
-  Bit16u op2_16, op1_16;
-
-  op2_16 = i->Iw();
+  Bit16u op1_16;
 
   if (i->modC0()) {
     op1_16 = BX_READ_16BIT_REG(i->rm());
@@ -693,11 +824,11 @@
     }
 
 #if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
-  Bit32u flags32;
-
-  asmCmp16(op1_16, op2_16, flags32);
-  setEFlagsOSZAPC(flags32);
+asmCmp16PlusFlags(op1_16,i->Iw(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
 #else
+  Bit16u op2_16;
+
+  op2_16 = i->Iw();
   Bit16u diff_16;
   diff_16 = op1_16 - op2_16;
 
@@ -732,6 +863,16 @@
 BX_CPU_C::INC_Ew(bxInstruction_c *i)
 {
   Bit16u op1_16;
+#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
+  if (i->modC0()) {
+    asmInc16PlusFlags(BX_READ_16BIT_REG(i->rm()), BX_CPU_THIS_PTR lf_flags_status, BX_CPU_THIS_PTR eflags.val32);
+    }
+  else {
+    read_RMW_virtual_word(i->seg(), RMAddr(i), &op1_16);
+    asmInc16PlusFlags(op1_16, BX_CPU_THIS_PTR lf_flags_status, BX_CPU_THIS_PTR eflags.val32);
+    Write_RMW_virtual_word(op1_16);
+    }
+#else
 
   if (i->modC0()) {
     op1_16 = BX_READ_16BIT_REG(i->rm());
@@ -745,6 +886,7 @@
     }
 
   SET_FLAGS_OSZAP_16(0, 0, op1_16, BX_INSTR_INC16);
+#endif
 }
 
 
@@ -755,32 +897,25 @@
 
   if (i->modC0()) {
 #if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
-    Bit32u flags32;
-
-    asmDec16(BX_CPU_THIS_PTR gen_reg[i->rm()].word.rx, flags32);
-    setEFlagsOSZAP(flags32);
+    asmDec16PlusFlags(BX_READ_16BIT_REG(i->rm()), BX_CPU_THIS_PTR lf_flags_status, BX_CPU_THIS_PTR eflags.val32);
 #else
     op1_16 = BX_READ_16BIT_REG(i->rm());
     op1_16--;
     BX_WRITE_16BIT_REG(i->rm(), op1_16);
+    SET_FLAGS_OSZAP_16(0, 0, op1_16, BX_INSTR_DEC16);
 #endif
     }
   else {
     read_RMW_virtual_word(i->seg(), RMAddr(i), &op1_16);
 #if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
-    Bit32u flags32;
-
-    asmDec16(op1_16, flags32);
-    setEFlagsOSZAP(flags32);
+    asmDec16PlusFlags(op1_16, BX_CPU_THIS_PTR lf_flags_status, BX_CPU_THIS_PTR eflags.val32);
+    Write_RMW_virtual_word(op1_16);
 #else
     op1_16--;
-#endif
     Write_RMW_virtual_word(op1_16);
-    }
-
-#if !(defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
-  SET_FLAGS_OSZAP_16(0, 0, op1_16, BX_INSTR_DEC16);
+    SET_FLAGS_OSZAP_16(0, 0, op1_16, BX_INSTR_DEC16);
 #endif
+    }
 }
 
 
diff -ur bochs/cpu/arith32.cc bochs-modified/cpu/arith32.cc
--- bochs/cpu/arith32.cc	Sat Apr  5 04:16:48 2003
+++ bochs-modified/cpu/arith32.cc	Mon Aug 18 13:33:56 2003
@@ -44,21 +44,19 @@
 BX_CPU_C::INC_ERX(bxInstruction_c *i)
 {
 #if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
-  Bit32u flags32;
+asmInc32PlusFlags(BX_CPU_THIS_PTR gen_reg[i->opcodeReg()].dword.erx,BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+#if BX_SUPPORT_X86_64
+  BX_CPU_THIS_PTR gen_reg[i->opcodeReg()].dword.hrx = 0;
+#endif
 
-  asmInc32(BX_CPU_THIS_PTR gen_reg[i->opcodeReg()].dword.erx, flags32);
-  setEFlagsOSZAP(flags32);
 #else
   Bit32u erx;
 
   erx = ++ BX_CPU_THIS_PTR gen_reg[i->opcodeReg()].dword.erx;
-#endif
-
 #if BX_SUPPORT_X86_64
   BX_CPU_THIS_PTR gen_reg[i->opcodeReg()].dword.hrx = 0;
 #endif
 
-#if !(defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
   SET_FLAGS_OSZAP_32(0, 0, erx, BX_INSTR_INC32);
 #endif
 }
@@ -67,21 +65,21 @@
 BX_CPU_C::DEC_ERX(bxInstruction_c *i)
 {
 #if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
-  Bit32u flags32;
 
-  asmDec32(BX_CPU_THIS_PTR gen_reg[i->opcodeReg()].dword.erx, flags32);
-  setEFlagsOSZAP(flags32);
+  asmDec32PlusFlags(BX_CPU_THIS_PTR gen_reg[i->opcodeReg()].dword.erx,BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+
+#if BX_SUPPORT_X86_64
+  BX_CPU_THIS_PTR gen_reg[i->opcodeReg()].dword.hrx = 0;
+#endif
+
 #else
   Bit32u erx;
 
   erx = -- BX_CPU_THIS_PTR gen_reg[i->opcodeReg()].dword.erx;
-#endif
-
 #if BX_SUPPORT_X86_64
   BX_CPU_THIS_PTR gen_reg[i->opcodeReg()].dword.hrx = 0;
 #endif
 
-#if !(defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
   SET_FLAGS_OSZAP_32(0, 0, erx, BX_INSTR_DEC32);
 #endif
 }
@@ -92,6 +90,20 @@
   void
 BX_CPU_C::ADD_EdGd(bxInstruction_c *i)
 {
+#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
+  Bit32u op1_32;
+
+  if (i->modC0()) {
+    op1_32 = BX_READ_32BIT_REG(i->rm());
+    asmAdd32PlusFlags(op1_32,BX_READ_32BIT_REG(i->nnn()),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    BX_WRITE_32BIT_REGZ(i->rm(), op1_32);
+    }
+  else {
+    read_RMW_virtual_dword(i->seg(), RMAddr(i), &op1_32);
+    asmAdd32PlusFlags(op1_32,BX_READ_32BIT_REG(i->nnn()),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    Write_RMW_virtual_dword(op1_32);
+    }
+#else
   Bit32u op2_32, op1_32, sum_32;
 
   op2_32 = BX_READ_32BIT_REG(i->nnn());
@@ -108,13 +120,14 @@
     }
 
   SET_FLAGS_OSZAPC_32(op1_32, op2_32, sum_32, BX_INSTR_ADD32);
+#endif
 }
 
 
   void
 BX_CPU_C::ADD_GdEEd(bxInstruction_c *i)
 {
-  Bit32u op1_32, op2_32, sum_32;
+  Bit32u op1_32, op2_32;
   unsigned nnn = i->nnn();
 
   op1_32 = BX_READ_32BIT_REG(nnn);
@@ -122,17 +135,15 @@
   read_virtual_dword(i->seg(), RMAddr(i), &op2_32);
 
 #if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
-  Bit32u flags32;
+  asmAdd32PlusFlags(op1_32,op2_32,BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
 
-  asmAdd32(sum_32, op1_32, op2_32, flags32);
-  setEFlagsOSZAPC(flags32);
+  BX_WRITE_32BIT_REGZ(nnn, op1_32);
 #else
+  Bit32u sum_32;
   sum_32 = op1_32 + op2_32;
-#endif
 
   BX_WRITE_32BIT_REGZ(nnn, sum_32);
 
-#if !(defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
   SET_FLAGS_OSZAPC_32(op1_32, op2_32, sum_32, BX_INSTR_ADD32);
 #endif
 }
@@ -140,24 +151,23 @@
   void
 BX_CPU_C::ADD_GdEGd(bxInstruction_c *i)
 {
-  Bit32u op1_32, op2_32, sum_32;
+  Bit32u op1_32;
   unsigned nnn = i->nnn();
 
   op1_32 = BX_READ_32BIT_REG(nnn);
-  op2_32 = BX_READ_32BIT_REG(i->rm());
 
 #if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
-  Bit32u flags32;
+  asmAdd32PlusFlags(op1_32,BX_READ_32BIT_REG(i->rm()),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
 
-  asmAdd32(sum_32, op1_32, op2_32, flags32);
-  setEFlagsOSZAPC(flags32);
+  BX_WRITE_32BIT_REGZ(nnn, op1_32);
 #else
+  Bit32u op2_32, sum_32;
+
+  op2_32 = BX_READ_32BIT_REG(i->rm());
   sum_32 = op1_32 + op2_32;
-#endif
 
   BX_WRITE_32BIT_REGZ(nnn, sum_32);
 
-#if !(defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
   SET_FLAGS_OSZAPC_32(op1_32, op2_32, sum_32, BX_INSTR_ADD32);
 #endif
 }
@@ -166,6 +176,14 @@
   void
 BX_CPU_C::ADD_EAXId(bxInstruction_c *i)
 {
+#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
+  Bit32u op1_32;
+  op1_32 = EAX;
+
+  asmAdd32PlusFlags(op1_32, i->Id(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+  RAX = op1_32;
+#else
+
   Bit32u op1_32, op2_32, sum_32;
 
   op1_32 = EAX;
@@ -176,11 +194,40 @@
   RAX = sum_32;
 
   SET_FLAGS_OSZAPC_32(op1_32, op2_32, sum_32, BX_INSTR_ADD32);
+#endif
 }
 
   void
 BX_CPU_C::ADC_EdGd(bxInstruction_c *i)
 {
+#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
+  Bit32u op1_32;
+
+  if (getB_CF()){
+    if (i->modC0()) {
+      op1_32 = BX_READ_32BIT_REG(i->rm());
+      asmAdc32PlusFlags_carry(op1_32,BX_READ_32BIT_REG(i->nnn()),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+      BX_WRITE_32BIT_REGZ(i->rm(), op1_32);
+      }
+    else {
+      read_RMW_virtual_dword(i->seg(), RMAddr(i), &op1_32);
+      asmAdc32PlusFlags_carry(op1_32,BX_READ_32BIT_REG(i->nnn()),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+      Write_RMW_virtual_dword(op1_32);
+      }
+    }
+  else {
+    if (i->modC0()) {
+      op1_32 = BX_READ_32BIT_REG(i->rm());
+      asmAdd32PlusFlags(op1_32,BX_READ_32BIT_REG(i->nnn()),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+      BX_WRITE_32BIT_REGZ(i->rm(), op1_32);
+      }
+    else {
+      read_RMW_virtual_dword(i->seg(), RMAddr(i), &op1_32);
+      asmAdd32PlusFlags(op1_32,BX_READ_32BIT_REG(i->nnn()),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+      Write_RMW_virtual_dword(op1_32);
+      }
+    }
+#else
   bx_bool temp_CF;
 
   temp_CF = getB_CF();
@@ -202,12 +249,42 @@
 
   SET_FLAGS_OSZAPC_32_CF(op1_32, op2_32, sum_32, BX_INSTR_ADC32,
                          temp_CF);
+#endif
 }
 
 
   void
 BX_CPU_C::ADC_GdEd(bxInstruction_c *i)
 {
+#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
+  Bit32u op1_32, op2_32;
+
+  if (getB_CF()) {
+    if (i->modC0()) {
+      op2_32 = BX_READ_32BIT_REG(i->rm());
+      }
+    else {
+      read_virtual_dword(i->seg(), RMAddr(i), &op2_32);
+      }
+
+    op1_32 = BX_READ_32BIT_REG(i->nnn());
+
+    asmAdc32PlusFlags_carry(op1_32,op2_32,BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    }
+  else {
+    if (i->modC0()) {
+      op2_32 = BX_READ_32BIT_REG(i->rm());
+      }
+    else {
+      read_virtual_dword(i->seg(), RMAddr(i), &op2_32);
+      }
+
+    op1_32 = BX_READ_32BIT_REG(i->nnn());
+
+    asmAdd32PlusFlags(op1_32,op2_32,BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    }
+  BX_WRITE_32BIT_REGZ(i->nnn(), op1_32);
+#else
   bx_bool temp_CF;
 
   temp_CF = getB_CF();
@@ -229,12 +306,26 @@
 
   SET_FLAGS_OSZAPC_32_CF(op1_32, op2_32, sum_32, BX_INSTR_ADC32,
                          temp_CF);
+#endif
 }
 
 
   void
 BX_CPU_C::ADC_EAXId(bxInstruction_c *i)
 {
+#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
+  Bit32u op1_32;
+
+  if (getB_CF()) {
+      op1_32 = EAX;
+      asmAdc32PlusFlags_carry(op1_32,i->Id(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    }
+  else {
+      op1_32 = EAX;
+      asmAdd32PlusFlags(op1_32,i->Id(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    }
+  RAX = op1_32;
+#else
   bx_bool temp_CF;
 
   temp_CF = getB_CF();
@@ -250,6 +341,7 @@
 
   SET_FLAGS_OSZAPC_32_CF(op1_32, op2_32, sum_32, BX_INSTR_ADC32,
                          temp_CF);
+#endif
 }
 
 
@@ -258,6 +350,34 @@
   void
 BX_CPU_C::SBB_EdGd(bxInstruction_c *i)
 {
+#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
+  Bit32u op1_32;
+
+  if (getB_CF()){
+    if (i->modC0()) {
+      op1_32 = BX_READ_32BIT_REG(i->rm());
+      asmSbb32PlusFlags_borrow(op1_32,BX_READ_32BIT_REG(i->nnn()),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+      BX_WRITE_32BIT_REGZ(i->rm(), op1_32);
+      }
+    else {
+      read_RMW_virtual_dword(i->seg(), RMAddr(i), &op1_32);
+      asmSbb32PlusFlags_borrow(op1_32,BX_READ_32BIT_REG(i->nnn()),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+      Write_RMW_virtual_dword(op1_32);
+      }
+    }
+  else {
+    if (i->modC0()) {
+      op1_32 = BX_READ_32BIT_REG(i->rm());
+      asmSub32PlusFlags(op1_32,BX_READ_32BIT_REG(i->nnn()),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+      BX_WRITE_32BIT_REGZ(i->rm(), op1_32);
+      }
+    else {
+      read_RMW_virtual_dword(i->seg(), RMAddr(i), &op1_32);
+      asmSub32PlusFlags(op1_32,BX_READ_32BIT_REG(i->nnn()),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+      Write_RMW_virtual_dword(op1_32);
+      }
+    }
+#else
   bx_bool temp_CF;
 
   temp_CF = getB_CF();
@@ -279,12 +399,38 @@
 
   SET_FLAGS_OSZAPC_32_CF(op1_32, op2_32, diff_32, BX_INSTR_SBB32,
                          temp_CF);
+#endif
 }
 
 
   void
 BX_CPU_C::SBB_GdEd(bxInstruction_c *i)
 {
+#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
+  Bit32u op1_32, op2_32;
+
+  if (getB_CF()) {
+      if (i->modC0()) {
+        op2_32 = BX_READ_32BIT_REG(i->rm());
+        }
+      else {
+        read_virtual_dword(i->seg(), RMAddr(i), &op2_32);
+        }
+      op1_32 = BX_READ_32BIT_REG(i->nnn());
+      asmSbb32PlusFlags_borrow(op1_32,op2_32,BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    }
+  else {
+      if (i->modC0()) {
+        op2_32 = BX_READ_32BIT_REG(i->rm());
+        }
+      else {
+        read_virtual_dword(i->seg(), RMAddr(i), &op2_32);
+        }
+      op1_32 = BX_READ_32BIT_REG(i->nnn());
+      asmSub32PlusFlags(op1_32,op2_32,BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    }
+  BX_WRITE_32BIT_REGZ(i->nnn(), op1_32);
+#else
   bx_bool temp_CF;
 
   temp_CF = getB_CF();
@@ -306,12 +452,26 @@
 
   SET_FLAGS_OSZAPC_32_CF(op1_32, op2_32, diff_32, BX_INSTR_SBB32,
                          temp_CF);
+#endif
 }
 
 
   void
 BX_CPU_C::SBB_EAXId(bxInstruction_c *i)
 {
+#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
+  Bit32u op1_32;
+
+  if (getB_CF()) {
+      op1_32 = EAX;
+      asmSbb32PlusFlags_borrow(op1_32,i->Id(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    }
+  else {
+      op1_32 = EAX;
+      asmSub32PlusFlags(op1_32,i->Id(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    }
+  RAX = op1_32;
+#else
   bx_bool temp_CF;
 
   temp_CF = getB_CF();
@@ -327,6 +487,7 @@
 
   SET_FLAGS_OSZAPC_32_CF(op1_32, op2_32, diff_32, BX_INSTR_SBB32,
                          temp_CF);
+#endif
 }
 
 
@@ -334,6 +495,34 @@
   void
 BX_CPU_C::SBB_EdId(bxInstruction_c *i)
 {
+#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
+  Bit32u op1_32;
+
+  if (getB_CF()){
+    if (i->modC0()) {
+      op1_32 = BX_READ_32BIT_REG(i->rm());
+      asmSbb32PlusFlags_borrow(op1_32,i->Id(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+      BX_WRITE_32BIT_REGZ(i->rm(), op1_32);
+      }
+    else {
+      read_RMW_virtual_dword(i->seg(), RMAddr(i), &op1_32);
+      asmSbb32PlusFlags_borrow(op1_32,i->Id(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+      Write_RMW_virtual_dword(op1_32);
+      }
+    }
+  else {
+    if (i->modC0()) {
+      op1_32 = BX_READ_32BIT_REG(i->rm());
+      asmSub32PlusFlags(op1_32,i->Id(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+      BX_WRITE_32BIT_REGZ(i->rm(), op1_32);
+      }
+    else {
+      read_RMW_virtual_dword(i->seg(), RMAddr(i), &op1_32);
+      asmSub32PlusFlags(op1_32,i->Id(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+      Write_RMW_virtual_dword(op1_32);
+      }
+    }
+#else
   bx_bool temp_CF;
 
   temp_CF = getB_CF();
@@ -355,12 +544,27 @@
 
   SET_FLAGS_OSZAPC_32_CF(op1_32, op2_32, diff_32, BX_INSTR_SBB32,
                          temp_CF);
+#endif
 }
 
 
   void
 BX_CPU_C::SUB_EdGd(bxInstruction_c *i)
 {
+#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
+  Bit32u op1_32;
+
+  if (i->modC0()) {
+    op1_32 = BX_READ_32BIT_REG(i->rm());
+    asmSub32PlusFlags(op1_32,BX_READ_32BIT_REG(i->nnn()),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    BX_WRITE_32BIT_REGZ(i->rm(), op1_32);
+    }
+  else {
+    read_RMW_virtual_dword(i->seg(), RMAddr(i), &op1_32);
+    asmSub32PlusFlags(op1_32,BX_READ_32BIT_REG(i->nnn()),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    Write_RMW_virtual_dword(op1_32);
+    }
+#else
   Bit32u op2_32, op1_32, diff_32;
 
   op2_32 = BX_READ_32BIT_REG(i->nnn());
@@ -377,13 +581,14 @@
     }
 
   SET_FLAGS_OSZAPC_32(op1_32, op2_32, diff_32, BX_INSTR_SUB32);
+#endif
 }
 
 
   void
 BX_CPU_C::SUB_GdEd(bxInstruction_c *i)
 {
-  Bit32u op1_32, op2_32, diff_32;
+  Bit32u op1_32, op2_32;
   unsigned nnn = i->nnn();
 
   op1_32 = BX_READ_32BIT_REG(nnn);
@@ -396,17 +601,14 @@
     }
 
 #if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
-  Bit32u flags32;
+  asmSub32PlusFlags(op1_32,op2_32,BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+  BX_WRITE_32BIT_REGZ(nnn, op1_32);
 
-  asmSub32(diff_32, op1_32, op2_32, flags32);
-  setEFlagsOSZAPC(flags32);
 #else
-  diff_32 = op1_32 - op2_32;
-#endif
+  Bit32u diff_32;
 
+  diff_32 = op1_32 - op2_32;
   BX_WRITE_32BIT_REGZ(nnn, diff_32);
-
-#if !(defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
   SET_FLAGS_OSZAPC_32(op1_32, op2_32, diff_32, BX_INSTR_SUB32);
 #endif
 }
@@ -414,6 +616,14 @@
   void
 BX_CPU_C::SUB_EAXId(bxInstruction_c *i)
 {
+#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
+  Bit32u op1_32;
+  op1_32 = EAX;
+
+  asmSub32PlusFlags(op1_32,i->Id(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+
+  RAX = op1_32;
+#else
   Bit32u op1_32, op2_32, diff_32;
 
   op1_32 = EAX;
@@ -424,15 +634,15 @@
   RAX = diff_32;
 
   SET_FLAGS_OSZAPC_32(op1_32, op2_32, diff_32, BX_INSTR_SUB32);
+#endif
 }
 
 
   void
 BX_CPU_C::CMP_EdGd(bxInstruction_c *i)
 {
-  Bit32u op2_32, op1_32;
+  Bit32u op1_32;
 
-  op2_32 = BX_READ_32BIT_REG(i->nnn());
 
   if (i->modC0()) {
     op1_32 = BX_READ_32BIT_REG(i->rm());
@@ -442,12 +652,11 @@
     }
 
 #if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
-  Bit32u flags32;
-
-  asmCmp32(op1_32, op2_32, flags32);
-  setEFlagsOSZAPC(flags32);
+  asmCmp32PlusFlags(op1_32,BX_READ_32BIT_REG(i->nnn()),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
 #else
-  Bit32u diff_32;
+  Bit32u op2_32, diff_32;
+
+  op2_32 = BX_READ_32BIT_REG(i->nnn());
   diff_32 = op1_32 - op2_32;
 
   SET_FLAGS_OSZAPC_32(op1_32, op2_32, diff_32, BX_INSTR_CMP32);
@@ -458,9 +667,8 @@
   void
 BX_CPU_C::CMP_GdEd(bxInstruction_c *i)
 {
-  Bit32u op1_32, op2_32;
+  Bit32u op2_32;
 
-  op1_32 = BX_READ_32BIT_REG(i->nnn());
 
   if (i->modC0()) {
     op2_32 = BX_READ_32BIT_REG(i->rm());
@@ -470,12 +678,12 @@
     }
 
 #if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
-  Bit32u flags32;
-
-  asmCmp32(op1_32, op2_32, flags32);
-  setEFlagsOSZAPC(flags32);
+  asmCmp32PlusFlags(BX_READ_32BIT_REG(i->nnn()),op2_32,BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
 #else
-  Bit32u diff_32;
+  Bit32u op1_32, diff_32;
+
+  op1_32 = BX_READ_32BIT_REG(i->nnn());
+
   diff_32 = op1_32 - op2_32;
 
   SET_FLAGS_OSZAPC_32(op1_32, op2_32, diff_32, BX_INSTR_CMP32);
@@ -486,17 +694,14 @@
   void
 BX_CPU_C::CMP_EAXId(bxInstruction_c *i)
 {
+#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
+  asmCmp32PlusFlags(EAX,i->Id(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+#else
   Bit32u op1_32, op2_32;
 
   op1_32 = EAX;
   op2_32 = i->Id();
 
-#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
-  Bit32u flags32;
-
-  asmCmp32(op1_32, op2_32, flags32);
-  setEFlagsOSZAPC(flags32);
-#else
   Bit32u diff_32;
   diff_32 = op1_32 - op2_32;
 
@@ -601,24 +806,21 @@
   void
 BX_CPU_C::ADD_EEdId(bxInstruction_c *i)
 {
-  Bit32u op2_32, op1_32, sum_32;
-
-  op2_32 = i->Id();
+  Bit32u op1_32;
 
   read_RMW_virtual_dword(i->seg(), RMAddr(i), &op1_32);
 
 #if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
-  Bit32u flags32;
-
-  asmAdd32(sum_32, op1_32, op2_32, flags32);
-  setEFlagsOSZAPC(flags32);
+  asmAdd32PlusFlags(op1_32,i->Id(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+  Write_RMW_virtual_dword(op1_32);
 #else
+  Bit32u op2_32, sum_32;
+  op2_32 = i->Id();
+
   sum_32 = op1_32 + op2_32;
-#endif
 
   Write_RMW_virtual_dword(sum_32);
 
-#if !(defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
   SET_FLAGS_OSZAPC_32(op1_32, op2_32, sum_32, BX_INSTR_ADD32);
 #endif
 }
@@ -626,23 +828,21 @@
   void
 BX_CPU_C::ADD_EGdId(bxInstruction_c *i)
 {
-  Bit32u op2_32, op1_32, sum_32;
+  Bit32u op1_32;
 
-  op2_32 = i->Id();
   op1_32 = BX_READ_32BIT_REG(i->rm());
 
 #if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
-  Bit32u flags32;
-
-  asmAdd32(sum_32, op1_32, op2_32, flags32);
-  setEFlagsOSZAPC(flags32);
+  asmAdd32PlusFlags(op1_32,i->Id(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+  BX_WRITE_32BIT_REGZ(i->rm(), op1_32);
 #else
+  Bit32u op2_32, sum_32;
+
+  op2_32 = i->Id();
   sum_32 = op1_32 + op2_32;
-#endif
 
   BX_WRITE_32BIT_REGZ(i->rm(), sum_32);
 
-#if !(defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
   SET_FLAGS_OSZAPC_32(op1_32, op2_32, sum_32, BX_INSTR_ADD32);
 #endif
 }
@@ -650,6 +850,34 @@
   void
 BX_CPU_C::ADC_EdId(bxInstruction_c *i)
 {
+#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
+  Bit32u op1_32;
+
+  if (getB_CF()){
+    if (i->modC0()) {
+      op1_32 = BX_READ_32BIT_REG(i->rm());
+      asmAdc32PlusFlags_carry(op1_32,i->Id(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+      BX_WRITE_32BIT_REGZ(i->rm(), op1_32);
+      }
+    else {
+      read_RMW_virtual_dword(i->seg(), RMAddr(i), &op1_32);
+      asmAdc32PlusFlags_carry(op1_32,i->Id(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+      Write_RMW_virtual_dword(op1_32);
+      }
+    }
+  else {
+    if (i->modC0()) {
+      op1_32 = BX_READ_32BIT_REG(i->rm());
+      asmAdd32PlusFlags(op1_32,i->Id(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+      BX_WRITE_32BIT_REGZ(i->rm(), op1_32);
+      }
+    else {
+      read_RMW_virtual_dword(i->seg(), RMAddr(i), &op1_32);
+      asmAdd32PlusFlags(op1_32,i->Id(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+      Write_RMW_virtual_dword(op1_32);
+      }
+    }
+#else
   bx_bool temp_CF;
 
   temp_CF = getB_CF();
@@ -671,12 +899,27 @@
 
   SET_FLAGS_OSZAPC_32_CF(op1_32, op2_32, sum_32, BX_INSTR_ADC32,
                          temp_CF);
+#endif
 }
 
 
   void
 BX_CPU_C::SUB_EdId(bxInstruction_c *i)
 {
+#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
+  Bit32u op1_32;
+
+  if (i->modC0()) {
+    op1_32 = BX_READ_32BIT_REG(i->rm());
+    asmSub32PlusFlags(op1_32,i->Id(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    BX_WRITE_32BIT_REGZ(i->rm(), op1_32);
+    }
+  else {
+    read_RMW_virtual_dword(i->seg(), RMAddr(i), &op1_32);
+    asmSub32PlusFlags(op1_32,i->Id(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    Write_RMW_virtual_dword(op1_32);
+    }
+#else
   Bit32u op2_32, op1_32, diff_32;
 
   op2_32 = i->Id();
@@ -693,6 +936,7 @@
     }
 
   SET_FLAGS_OSZAPC_32(op1_32, op2_32, diff_32, BX_INSTR_SUB32);
+#endif
 }
 
   void
@@ -700,7 +944,6 @@
 {
   Bit32u op2_32, op1_32;
 
-  op2_32 = i->Id();
 
   if (i->modC0()) {
     op1_32 = BX_READ_32BIT_REG(i->rm());
@@ -710,12 +953,12 @@
     }
 
 #if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
-  Bit32u flags32;
-
-  asmCmp32(op1_32, op2_32, flags32);
-  setEFlagsOSZAPC(flags32);
+  asmCmp32PlusFlags(op1_32,i->Id(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
 #else
   Bit32u diff_32;
+
+  op2_32 = i->Id();
+
   diff_32 = op1_32 - op2_32;
 
   SET_FLAGS_OSZAPC_32(op1_32, op2_32, diff_32, BX_INSTR_CMP32);
@@ -749,6 +992,18 @@
 BX_CPU_C::INC_Ed(bxInstruction_c *i)
 {
   Bit32u op1_32;
+#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
+  if (i->modC0()) {
+    op1_32 = BX_READ_32BIT_REG(i->rm());
+    asmInc32PlusFlags(op1_32,BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    BX_WRITE_32BIT_REGZ(i->rm(), op1_32);
+    }
+  else {
+    read_RMW_virtual_dword(i->seg(), RMAddr(i), &op1_32);
+    asmInc32PlusFlags(op1_32,BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    Write_RMW_virtual_dword(op1_32);
+    }
+#else
 
   if (i->modC0()) {
     op1_32 = BX_READ_32BIT_REG(i->rm());
@@ -762,6 +1017,7 @@
     }
 
   SET_FLAGS_OSZAP_32(0, 0, op1_32, BX_INSTR_INC32);
+#endif
 }
 
 
@@ -769,6 +1025,18 @@
 BX_CPU_C::DEC_Ed(bxInstruction_c *i)
 {
   Bit32u op1_32;
+#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
+  if (i->modC0()) {
+    op1_32 = BX_READ_32BIT_REG(i->rm());
+    asmDec32PlusFlags(op1_32,BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    BX_WRITE_32BIT_REGZ(i->rm(), op1_32);
+    }
+  else {
+    read_RMW_virtual_dword(i->seg(), RMAddr(i), &op1_32);
+    asmDec32PlusFlags(op1_32,BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    Write_RMW_virtual_dword(op1_32);
+    }
+#else
 
   if (i->modC0()) {
     op1_32 = BX_READ_32BIT_REG(i->rm());
@@ -782,6 +1050,7 @@
     }
 
   SET_FLAGS_OSZAP_32(0, 0, op1_32, BX_INSTR_DEC32);
+#endif
 }
 
 
diff -ur bochs/cpu/cpu.h bochs-modified/cpu/cpu.h
--- bochs/cpu/cpu.h	Mon Aug  4 09:18:15 2003
+++ bochs-modified/cpu/cpu.h	Fri Aug 15 13:57:54 2003
@@ -3300,7 +3300,7 @@
 #if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
 
 // This section defines some convience inline functions which do the
-// dirty work of asm() statements for arithmetic instructions on x86 hosts. 
+// dirty work of asm() statements for arithmetic instructions on x86 hosts.
 // Essentially these speed up eflags processing since the value of the
 // eflags register can be read directly on x86 hosts, after the
 // arithmetic operations.
@@ -3331,6 +3331,86 @@
     );
 }
 
+
+   static inline void
+asmAdd16PlusFlags(Bit16u &op1_16, Bit16u op2_16, Bit32u &lflags32, Bit32u &flags_val)
+{
+  asm (
+    "addw    %3, %2\n\t"
+    "pushfl   \n\t"
+    "movl     $0, %0\n\t"
+    "popl     %3\n\t"
+    "andl     $-2262,%1\n\t"
+    "andl     $2261,%3\n\t"
+    "orl      %3,%1\n\t"
+
+    : "=m" (lflags32), "=g" (flags_val), "=g" (op1_16)
+    :  "r" (op2_16), "2" (op1_16)
+    : "cc"
+    );
+}
+
+
+   static inline void
+asmAdd32PlusFlags(Bit32u &op1_32, Bit32u op2_32, Bit32u &lflags32, Bit32u &flags_val)
+{
+  asm (
+    "addl    %3, %2\n\t"
+    "pushfl   \n\t"
+    "movl     $0, %0\n\t"
+    "popl     %3\n\t"
+    "andl     $-2262,%1\n\t"
+    "andl     $2261,%3\n\t"
+    "orl      %3,%1\n\t"
+
+    : "=m" (lflags32), "=g" (flags_val), "=g" (op1_32)
+    :  "r" (op2_32), "2" (op1_32)
+    : "cc"
+    );
+}
+
+
+
+   static inline void
+asmAdc16PlusFlags_carry(Bit16u &op1_16, Bit16u op2_16, Bit32u &lflags32, Bit32u &flags_val)
+{
+
+  asm (
+    "stc\n\t"
+    "adcw    %3, %2\n\t"
+    "pushfl   \n\t"
+    "movl     $0, %0\n\t"
+    "popl     %3\n\t"
+    "andl     $-2262,%1\n\t"
+    "andl     $2261,%3\n\t"
+    "orl      %3,%1\n\t"
+
+    : "=m" (lflags32), "=g" (flags_val), "=g" (op1_16)
+    :  "r" (op2_16), "2" (op1_16)
+    : "cc"
+    );
+}
+
+    static inline void
+asmAdc32PlusFlags_carry(Bit32u &op1_32, Bit32u op2_32, Bit32u &lflags32, Bit32u &flags_val)
+{
+  asm (
+    "stc\n\t"
+    "adcl    %3, %2\n\t"
+    "pushfl   \n\t"
+    "movl     $0, %0\n\t"
+    "popl     %3\n\t"
+    "andl     $-2262,%1\n\t"
+    "andl     $2261,%3\n\t"
+    "orl      %3,%1\n\t"
+
+    : "=m" (lflags32), "=g" (flags_val), "=g" (op1_32)
+    :  "r" (op2_32), "2" (op1_32)
+    : "cc"
+    );
+}
+
+
   static inline void
 asmSub16(Bit16u &diff_16, Bit16u op1_16, Bit16u op2_16, Bit32u &flags32)
 {
@@ -3357,6 +3437,84 @@
     );
 }
 
+
+
+
+  static inline void
+asmSub16PlusFlags(Bit16u &op1_16, Bit16u op2_16, Bit32u &lflags32, Bit32u &flags_val)
+{
+  asm (
+    "subw    %3, %2\n\t"
+    "pushfl   \n\t"
+    "movl     $0, %0\n\t"
+    "popl     %3\n\t"
+    "andl     $-2262,%1\n\t"
+    "andl     $2261,%3\n\t"
+    "orl      %3,%1\n\t"
+
+    : "=m" (lflags32), "=g" (flags_val), "=g" (op1_16)
+    :  "r" (op2_16), "2" (op1_16)
+    : "cc"
+    );
+}
+
+  static inline void
+asmSub32PlusFlags(Bit32u &op1_32, Bit32u op2_32, Bit32u &lflags32, Bit32u &flags_val)
+{
+  asm (
+    "subl    %3, %2\n\t"
+    "pushfl   \n\t"
+    "movl     $0, %0\n\t"
+    "popl     %3\n\t"
+    "andl     $-2262,%1\n\t"
+    "andl     $2261,%3\n\t"
+    "orl      %3,%1\n\t"
+
+    : "=m" (lflags32), "=g" (flags_val), "=g" (op1_32)
+    :  "r" (op2_32), "2" (op1_32)
+    : "cc"
+    );
+}
+
+  static inline void
+asmSbb16PlusFlags_borrow(Bit16u &op1_16, Bit16u op2_16, Bit32u &lflags32, Bit32u &flags_val)
+{
+  asm (
+    "stc\n\t"
+    "sbbw    %3, %2\n\t"
+    "pushfl   \n\t"
+    "movl     $0, %0\n\t"
+    "popl     %3\n\t"
+    "andl     $-2262,%1\n\t"
+    "andl     $2261,%3\n\t"
+    "orl      %3,%1\n\t"
+
+    : "=m" (lflags32), "=g" (flags_val), "=g" (op1_16)
+    :  "r" (op2_16), "2" (op1_16)
+    : "cc"
+    );
+}
+
+  static inline void
+asmSbb32PlusFlags_borrow(Bit32u &op1_32, Bit32u op2_32, Bit32u &lflags32, Bit32u &flags_val)
+{
+  asm (
+    "stc\n\t"
+    "sbbl    %3, %2\n\t"
+    "pushfl   \n\t"
+    "movl     $0, %0\n\t"
+    "popl     %3\n\t"
+    "andl     $-2262,%1\n\t"
+    "andl     $2261,%3\n\t"
+    "orl      %3,%1\n\t"
+
+    : "=m" (lflags32), "=g" (flags_val), "=g" (op1_32)
+    :  "r" (op2_32), "2" (op1_32)
+    : "cc"
+    );
+}
+
+
   static inline void
 asmCmp8(Bit8u op1_8, Bit8u op2_8, Bit32u &flags32)
 {
@@ -3396,6 +3554,43 @@
     );
 }
 
+
+   static inline void
+asmCmp16PlusFlags(Bit16u op1_16, Bit16u op2_16, Bit32u &lflags32, Bit32u &flags_val)
+{
+  asm (
+    "cmpw    %3, %2\n\t"
+    "pushfl   \n\t"
+    "movl     $0, %0\n\t"
+    "popl     %3\n\t"
+    "andl     $-2262,%1\n\t"
+    "andl     $2261,%3\n\t"
+    "orl      %3,%1"
+    : "=m" (lflags32), "=g" (flags_val)
+    : "r" (op1_16), "r" (op2_16), "1"(flags_val)
+    : "cc"
+    );
+}
+
+      static inline void
+asmCmp32PlusFlags(Bit32u op1_32, Bit32u op2_32, Bit32u &lflags32, Bit32u &flags_val)
+{
+  asm (
+    "cmpl    %3, %2\n\t"
+    "pushfl   \n\t"
+    "movl     $0, %0\n\t"
+    "popl     %3\n\t"
+    "andl     $-2262,%1\n\t"
+    "andl     $2261,%3\n\t"
+    "orl      %3,%1"
+    : "=m" (lflags32), "=g" (flags_val)
+    : "r" (op1_32), "r" (op2_32), "1"(flags_val)
+    : "cc"
+    );
+}
+
+
+
   static inline void
 asmInc16(Bit16u &op1_16, Bit32u &flags32)
 {
@@ -3422,6 +3617,45 @@
     );
 }
 
+
+
+  static inline void
+asmInc16PlusFlags(Bit16u &op1_16, Bit32u &lflags32, Bit32u &flags_val)
+{
+  asm (
+    "incw     %2\n\t"
+    "pushfl   \n\t"
+    "andl     $15, %0\n\t"
+    "popl     %%eax\n\t"
+    "andl     $-2261,%1\n\t"
+    "andl     $2260,%%eax\n\t"
+    "orl      %%eax,%1\n\t"
+    : "=m" (lflags32), "=g" (flags_val), "=q" (op1_16)
+    : "g"(flags_val), "2" (op1_16)
+    : "cc", "eax"
+    );
+}
+
+  static inline void
+asmInc32PlusFlags(Bit32u &op1_32, Bit32u &lflags32, Bit32u &flags_val)
+{
+  asm (
+    "incl     %2\n\t"
+    "pushfl   \n\t"
+    "andl     $15, %0\n\t"
+    "popl     %%eax\n\t"
+    "andl     $-2261,%1\n\t"
+    "andl     $2260,%%eax\n\t"
+    "orl      %%eax,%1\n\t"
+    : "=m" (lflags32), "=g" (flags_val), "=q" (op1_32)
+    : "g"(flags_val), "2" (op1_32)
+    : "cc", "eax"
+    );
+}
+
+
+
+
   static inline void
 asmDec16(Bit16u &op1_16, Bit32u &flags32)
 {
@@ -3448,6 +3682,45 @@
     );
 }
 
+
+
+  static inline void
+asmDec16PlusFlags(Bit16u &op1_16, Bit32u &lflags32, Bit32u &flags_val)
+{
+  asm (
+    "decw     %2\n\t"
+    "pushfl   \n\t"
+    "andl     $15, %0\n\t"
+    "popl     %%eax\n\t"
+    "andl     $-2261,%1\n\t"
+    "andl     $2260,%%eax\n\t"
+    "orl      %%eax,%1\n\t"
+    : "=m" (lflags32), "=g" (flags_val), "=q" (op1_16)
+    : "g"(flags_val), "2" (op1_16)
+    : "cc", "eax"
+    );
+}
+
+  static inline void
+asmDec32PlusFlags(Bit32u &op1_32, Bit32u &lflags32, Bit32u &flags_val)
+{
+  asm (
+    "decl     %2\n\t"
+    "pushfl   \n\t"
+    "andl     $15, %0\n\t"
+    "popl     %%eax\n\t"
+    "andl     $-2261,%1\n\t"
+    "andl     $2260,%%eax\n\t"
+    "orl      %%eax,%1\n\t"
+    : "=m" (lflags32), "=g" (flags_val), "=q" (op1_32)
+    : "g"(flags_val), "2" (op1_32)
+    : "cc", "eax"
+    );
+}
+
+
+
+
   static inline void
 asmXor16(Bit16u &result_16, Bit16u op1_16, Bit16u op2_16, Bit32u &flags32)
 {
@@ -3474,6 +3747,45 @@
     );
 }
 
+
+  static inline void
+asmXor16PlusFlags(Bit16u &op1_16, Bit16u op2_16, Bit32u &lflags32, Bit32u &flags_val)
+{
+  asm (
+    "xorw    %3, %2\n\t"
+    "pushfl   \n\t"
+    "movl     $0, %0\n\t"
+    "popl     %3\n\t"
+    "andl     $-2262,%1\n\t"
+    "andl     $2261,%3\n\t"
+    "orl      %3,%1\n\t"
+
+    : "=m" (lflags32), "=g" (flags_val), "=g" (op1_16)
+    :  "r" (op2_16), "2" (op1_16)
+    : "cc"
+    );
+}
+
+    static inline void
+asmXor32PlusFlags(Bit32u &op1_32, Bit32u op2_32, Bit32u &lflags32, Bit32u &flags_val)
+{
+  asm (
+    "xorl    %3, %2\n\t"
+    "pushfl   \n\t"
+    "movl     $0, %0\n\t"
+    "popl     %3\n\t"
+    "andl     $-2262,%1\n\t"
+    "andl     $2261,%3\n\t"
+    "orl      %3,%1\n\t"
+
+    : "=m" (lflags32), "=g" (flags_val), "=g" (op1_32)
+    :  "r" (op2_32), "2" (op1_32)
+    : "cc"
+    );
+}
+
+
+
   static inline void
 asmOr8(Bit8u &result_8, Bit8u op1_8, Bit8u op2_8, Bit32u &flags32)
 {
@@ -3513,6 +3825,45 @@
     );
 }
 
+
+  static inline void
+asmOr16PlusFlags(Bit16u &op1_16, Bit16u op2_16, Bit32u &lflags32, Bit32u &flags_val)
+{
+  asm (
+    "orw    %3, %2\n\t"
+    "pushfl   \n\t"
+    "movl     $0, %0\n\t"
+    "popl     %3\n\t"
+    "andl     $-2262,%1\n\t"
+    "andl     $2261,%3\n\t"
+    "orl      %3,%1\n\t"
+
+    : "=m" (lflags32), "=g" (flags_val), "=g" (op1_16)
+    :  "r" (op2_16), "2" (op1_16)
+    : "cc"
+    );
+}
+
+    static inline void
+asmOr32PlusFlags(Bit32u &op1_32, Bit32u op2_32, Bit32u &lflags32, Bit32u &flags_val)
+{
+  asm (
+    "orl    %3, %2\n\t"
+    "pushfl   \n\t"
+    "movl     $0, %0\n\t"
+    "popl     %3\n\t"
+    "andl     $-2262,%1\n\t"
+    "andl     $2261,%3\n\t"
+    "orl      %3,%1\n\t"
+
+    : "=m" (lflags32), "=g" (flags_val), "=g" (op1_32)
+    :  "r" (op2_32), "2" (op1_32)
+    : "cc"
+    );
+}
+
+
+
   static inline void
 asmAnd8(Bit8u &result_8, Bit8u op1_8, Bit8u op2_8, Bit32u &flags32)
 {
@@ -3552,6 +3903,45 @@
     );
 }
 
+
+
+  static inline void
+asmAnd16PlusFlags(Bit16u &op1_16, Bit16u op2_16, Bit32u &lflags32, Bit32u &flags_val)
+{
+  asm (
+    "andw    %3, %2\n\t"
+    "pushfl   \n\t"
+    "movl     $0, %0\n\t"
+    "popl     %3\n\t"
+    "andl     $-2262,%1\n\t"
+    "andl     $2261,%3\n\t"
+    "orl      %3,%1\n\t"
+
+    : "=m" (lflags32), "=g" (flags_val), "=g" (op1_16)
+    :  "r" (op2_16), "2" (op1_16)
+    : "cc"
+    );
+}
+
+  static inline void
+asmAnd32PlusFlags(Bit32u &op1_32, Bit32u op2_32, Bit32u &lflags32, Bit32u &flags_val)
+{
+  asm (
+    "andl    %3, %2\n\t"
+    "pushfl   \n\t"
+    "movl     $0, %0\n\t"
+    "popl     %3\n\t"
+    "andl     $-2262,%1\n\t"
+    "andl     $2261,%3\n\t"
+    "orl      %3,%1\n\t"
+
+    : "=m" (lflags32), "=g" (flags_val), "=g" (op1_32)
+    :  "r" (op2_32), "2" (op1_32)
+    : "cc"
+    );
+}
+
+
   static inline void
 asmTest8(Bit8u op1_8, Bit8u op2_8, Bit32u &flags32)
 {
@@ -3590,6 +3980,61 @@
     : "cc"
     );
 }
+
+  static inline void
+asmTest8PlusFlags(Bit8u op1_8, Bit8u op2_8, Bit32u &lflags32, Bit32u &flags_val)
+{
+  asm (
+    "testb    %3, %2\n\t"
+    "pushfl   \n\t"
+    "movl     $0, %0\n\t"
+    "popl     %%eax\n\t"
+    "andl     $-2262,%1\n\t"
+    "andl     $2261,%%eax\n\t"
+    "orl      %%eax,%1\n\t"
+
+    : "=m" (lflags32), "=g" (flags_val)
+    :  "q" (op1_8), "q" (op2_8)
+    : "cc", "eax"
+    );
+}
+
+  static inline void
+asmTest16PlusFlags(Bit16u op1_16, Bit16u op2_16, Bit32u &lflags32, Bit32u &flags_val)
+{
+  asm (
+    "testw    %3, %2\n\t"
+    "pushfl   \n\t"
+    "movl     $0, %0\n\t"
+    "popl     %%eax\n\t"
+    "andl     $-2262,%1\n\t"
+    "andl     $2261,%%eax\n\t"
+    "orl      %%eax,%1\n\t"
+
+    : "=m" (lflags32), "=g" (flags_val)
+    :  "q" (op1_16), "q" (op2_16)
+    : "cc", "eax"
+    );
+}
+
+  static inline void
+asmTest32PlusFlags(Bit32u op1_32, Bit32u op2_32, Bit32u &lflags32, Bit32u &flags_val)
+{
+  asm (
+    "testl    %3, %2\n\t"
+    "pushfl   \n\t"
+    "movl     $0, %0\n\t"
+    "popl     %3\n\t"
+    "andl     $-2262,%1\n\t"
+    "andl     $2261,%3\n\t"
+    "orl      %3,%1\n\t"
+
+    : "=m" (lflags32), "=g" (flags_val)
+    :  "q" (op1_32), "r" (op2_32)
+    : "cc"
+    );
+}
+
 
   static inline void
 asmShr16(Bit16u &result_16, Bit16u op1_16, unsigned count, Bit32u &flags32)
diff -ur bochs/cpu/logical16.cc bochs-modified/cpu/logical16.cc
--- bochs/cpu/logical16.cc	Fri Oct 25 11:26:28 2002
+++ bochs-modified/cpu/logical16.cc	Mon Aug 18 15:45:38 2003
@@ -39,37 +39,33 @@
   void
 BX_CPU_C::XOR_EwGw(bxInstruction_c *i)
 {
+#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
+  Bit16u  op1_16;
+  if (i->modC0()) {
+    op1_16 = BX_READ_16BIT_REG(i->rm());
+    asmXor16PlusFlags( op1_16, BX_READ_16BIT_REG(i->nnn()),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    BX_WRITE_16BIT_REG(i->rm(), op1_16);
+    }
+  else {
+    read_RMW_virtual_word(i->seg(), RMAddr(i), &op1_16);
+    asmXor16PlusFlags( op1_16, BX_READ_16BIT_REG(i->nnn()),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    Write_RMW_virtual_word(op1_16);
+    }
+#else
   Bit16u op2_16, op1_16, result_16;
 
   op2_16 = BX_READ_16BIT_REG(i->nnn());
 
   if (i->modC0()) {
     op1_16 = BX_READ_16BIT_REG(i->rm());
-
-#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
-    Bit32u flags32;
-
-    asmXor16(result_16, op1_16, op2_16, flags32);
-    setEFlagsOSZAPC(flags32);
-#else
     result_16 = op1_16 ^ op2_16;
-#endif
     BX_WRITE_16BIT_REG(i->rm(), result_16);
     }
   else {
     read_RMW_virtual_word(i->seg(), RMAddr(i), &op1_16);
-#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
-    Bit32u flags32;
-
-    asmXor16(result_16, op1_16, op2_16, flags32);
-    setEFlagsOSZAPC(flags32);
-#else
     result_16 = op1_16 ^ op2_16;
-#endif
     Write_RMW_virtual_word(result_16);
     }
-
-#if !(defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
   SET_FLAGS_OSZAPC_16(op1_16, op2_16, result_16, BX_INSTR_XOR16);
 #endif
 }
@@ -78,10 +74,7 @@
   void
 BX_CPU_C::XOR_GwEw(bxInstruction_c *i)
 {
-  Bit16u op1_16, op2_16, result_16;
-  unsigned nnn = i->nnn();
-
-  op1_16 = BX_READ_16BIT_REG(nnn);
+  Bit16u op2_16;
 
   if (i->modC0()) {
     op2_16 = BX_READ_16BIT_REG(i->rm());
@@ -89,18 +82,32 @@
   else {
     read_virtual_word(i->seg(), RMAddr(i), &op2_16);
     }
+#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
+asmXor16PlusFlags( BX_READ_16BIT_REG(i->nnn()), op2_16,BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+
+#else
+  Bit16u op1_16, result_16;
+
+  unsigned nnn = i->nnn();
+
+  op1_16 = BX_READ_16BIT_REG(nnn);
 
   result_16 = op1_16 ^ op2_16;
 
   BX_WRITE_16BIT_REG(nnn, result_16);
 
   SET_FLAGS_OSZAPC_16(op1_16, op2_16, result_16, BX_INSTR_XOR16);
+#endif
 }
 
 
   void
 BX_CPU_C::XOR_AXIw(bxInstruction_c *i)
 {
+#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
+asmXor16PlusFlags( AX, i->Iw(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+
+#else
   Bit16u op1_16, op2_16, sum_16;
 
   op1_16 = AX;
@@ -111,11 +118,25 @@
   AX = sum_16;
 
   SET_FLAGS_OSZAPC_16(op1_16, op2_16, sum_16, BX_INSTR_XOR16);
+#endif
 }
 
   void
 BX_CPU_C::XOR_EwIw(bxInstruction_c *i)
 {
+#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
+  Bit16u  op1_16;
+  if (i->modC0()) {
+    op1_16 = BX_READ_16BIT_REG(i->rm());
+    asmXor16PlusFlags( op1_16, i->Iw(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    BX_WRITE_16BIT_REG(i->rm(), op1_16);
+    }
+  else {
+    read_RMW_virtual_word(i->seg(), RMAddr(i), &op1_16);
+    asmXor16PlusFlags( op1_16, i->Iw(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    Write_RMW_virtual_word(op1_16);
+    }
+#else
   Bit16u op2_16, op1_16, result_16;
 
 
@@ -133,12 +154,26 @@
     }
 
   SET_FLAGS_OSZAPC_16(op1_16, op2_16, result_16, BX_INSTR_XOR16);
+#endif
 }
 
 
   void
 BX_CPU_C::OR_EwIw(bxInstruction_c *i)
 {
+#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
+  Bit16u  op1_16;
+  if (i->modC0()) {
+    op1_16 = BX_READ_16BIT_REG(i->rm());
+    asmOr16PlusFlags( op1_16, i->Iw(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    BX_WRITE_16BIT_REG(i->rm(), op1_16);
+    }
+  else {
+    read_RMW_virtual_word(i->seg(), RMAddr(i), &op1_16);
+    asmOr16PlusFlags( op1_16, i->Iw(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    Write_RMW_virtual_word(op1_16);
+    }
+#else
   Bit16u op2_16, op1_16, result_16;
 
 
@@ -156,6 +191,7 @@
     }
 
   SET_FLAGS_OSZAPC_16(op1_16, op2_16, result_16, BX_INSTR_OR16);
+#endif
 }
 
 
@@ -180,6 +216,19 @@
   void
 BX_CPU_C::OR_EwGw(bxInstruction_c *i)
 {
+#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
+  Bit16u  op1_16;
+  if (i->modC0()) {
+    op1_16 = BX_READ_16BIT_REG(i->rm());
+    asmOr16PlusFlags( op1_16, BX_READ_16BIT_REG(i->nnn()),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    BX_WRITE_16BIT_REG(i->rm(), op1_16);
+    }
+  else {
+    read_RMW_virtual_word(i->seg(), RMAddr(i), &op1_16);
+    asmOr16PlusFlags( op1_16, BX_READ_16BIT_REG(i->nnn()),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    Write_RMW_virtual_word(op1_16);
+    }
+#else
   Bit16u op2_16, op1_16, result_16;
 
   op2_16 = BX_READ_16BIT_REG(i->nnn());
@@ -196,15 +245,14 @@
     }
 
   SET_FLAGS_OSZAPC_16(op1_16, op2_16, result_16, BX_INSTR_OR16);
+#endif
 }
 
 
   void
 BX_CPU_C::OR_GwEw(bxInstruction_c *i)
 {
-  Bit16u op1_16, op2_16, result_16;
-
-  op1_16 = BX_READ_16BIT_REG(i->nnn());
+  Bit16u op2_16;
 
   if (i->modC0()) {
     op2_16 = BX_READ_16BIT_REG(i->rm());
@@ -214,17 +262,16 @@
     }
 
 #if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
-  Bit32u flags32;
+asmOr16PlusFlags( BX_READ_16BIT_REG(i->nnn()), op2_16,BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
 
-  asmOr16(result_16, op1_16, op2_16, flags32);
-  setEFlagsOSZAPC(flags32);
 #else
+  Bit16u op1_16, result_16;
+
+  op1_16 = BX_READ_16BIT_REG(i->nnn());
   result_16 = op1_16 | op2_16;
-#endif
 
   BX_WRITE_16BIT_REG(i->nnn(), result_16);
 
-#if !(defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
   SET_FLAGS_OSZAPC_16(op1_16, op2_16, result_16, BX_INSTR_OR16);
 #endif
 }
@@ -233,6 +280,10 @@
   void
 BX_CPU_C::OR_AXIw(bxInstruction_c *i)
 {
+#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
+asmOr16PlusFlags( AX, i->Iw(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+
+#else
   Bit16u op1_16, op2_16, sum_16;
 
   op1_16 = AX;
@@ -243,6 +294,7 @@
   AX = sum_16;
 
   SET_FLAGS_OSZAPC_16(op1_16, op2_16, sum_16, BX_INSTR_OR16);
+#endif
 }
 
 
@@ -250,41 +302,35 @@
   void
 BX_CPU_C::AND_EwGw(bxInstruction_c *i)
 {
-  Bit16u op2_16, op1_16, result_16;
+#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
+  Bit16u  op1_16;
+  if (i->modC0()) {
+    op1_16 = BX_READ_16BIT_REG(i->rm());
+    asmAnd16PlusFlags( op1_16, BX_READ_16BIT_REG(i->nnn()),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    BX_WRITE_16BIT_REG(i->rm(), op1_16);
+    }
+  else {
+    read_RMW_virtual_word(i->seg(), RMAddr(i), &op1_16);
+    asmAnd16PlusFlags( op1_16, BX_READ_16BIT_REG(i->nnn()),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    Write_RMW_virtual_word(op1_16);
+    }
+#else
+  Bit16u op2_16, op1_16, result_16;;
 
   op2_16 = BX_READ_16BIT_REG(i->nnn());
 
   if (i->modC0()) {
     op1_16 = BX_READ_16BIT_REG(i->rm());
-
-#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
-    Bit32u flags32;
-
-    asmAnd16(result_16, op1_16, op2_16, flags32);
-    setEFlagsOSZAPC(flags32);
-#else
     result_16 = op1_16 & op2_16;
-#endif
-
     BX_WRITE_16BIT_REG(i->rm(), result_16);
+    SET_FLAGS_OSZAPC_16(op1_16, op2_16, result_16, BX_INSTR_AND16);
     }
   else {
     read_RMW_virtual_word(i->seg(), RMAddr(i), &op1_16);
-
-#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
-    Bit32u flags32;
-
-    asmAnd16(result_16, op1_16, op2_16, flags32);
-    setEFlagsOSZAPC(flags32);
-#else
     result_16 = op1_16 & op2_16;
-#endif
-
+    SET_FLAGS_OSZAPC_16(op1_16, op2_16, result_16, BX_INSTR_AND16);
     Write_RMW_virtual_word(result_16);
     }
-
-#if !(defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
-  SET_FLAGS_OSZAPC_16(op1_16, op2_16, result_16, BX_INSTR_AND16);
 #endif
 }
 
@@ -292,9 +338,8 @@
   void
 BX_CPU_C::AND_GwEw(bxInstruction_c *i)
 {
-  Bit16u op1_16, op2_16, result_16;
+  Bit16u op2_16;
 
-  op1_16 = BX_READ_16BIT_REG(i->nnn());
 
   if (i->modC0()) {
     op2_16 = BX_READ_16BIT_REG(i->rm());
@@ -304,83 +349,74 @@
     }
 
 #if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
-  Bit32u flags32;
-
-  asmAnd16(result_16, op1_16, op2_16, flags32);
-  setEFlagsOSZAPC(flags32);
+asmAnd16PlusFlags( BX_READ_16BIT_REG(i->nnn()), op2_16,BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
 #else
+  Bit16u op1_16, result_16;
+
+  op1_16 = BX_READ_16BIT_REG(i->nnn());
   result_16 = op1_16 & op2_16;
-#endif
 
   BX_WRITE_16BIT_REG(i->nnn(), result_16);
 
-#if !(defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
   SET_FLAGS_OSZAPC_16(op1_16, op2_16, result_16, BX_INSTR_AND16);
 #endif
 }
 
 
-  void
+
+   void
 BX_CPU_C::AND_AXIw(bxInstruction_c *i)
 {
+#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
+asmAnd16PlusFlags( AX, i->Iw(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+#else
+
   Bit16u op1_16, op2_16, result_16;
 
   op1_16 = AX;
   op2_16 = i->Iw();
 
-#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
-  Bit32u flags32;
-
-  asmAnd16(result_16, op1_16, op2_16, flags32);
-  setEFlagsOSZAPC(flags32);
-#else
   result_16 = op1_16 & op2_16;
-#endif
 
   AX = result_16;
 
-#if !(defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
   SET_FLAGS_OSZAPC_16(op1_16, op2_16, result_16, BX_INSTR_AND16);
 #endif
 }
 
+
+
   void
 BX_CPU_C::AND_EwIw(bxInstruction_c *i)
 {
+#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
+  Bit16u  op1_16;
+  if (i->modC0()) {
+    op1_16 = BX_READ_16BIT_REG(i->rm());
+    asmAnd16PlusFlags( op1_16, i->Iw(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    BX_WRITE_16BIT_REG(i->rm(), op1_16);
+    }
+  else {
+    read_RMW_virtual_word(i->seg(), RMAddr(i), &op1_16);
+    asmAnd16PlusFlags( op1_16, i->Iw(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    Write_RMW_virtual_word(op1_16);
+    }
+#else
   Bit16u op2_16, op1_16, result_16;
 
   op2_16 = i->Iw();
 
   if (i->modC0()) {
     op1_16 = BX_READ_16BIT_REG(i->rm());
-
-#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
-    Bit32u flags32;
-
-    asmAnd16(result_16, op1_16, op2_16, flags32);
-    setEFlagsOSZAPC(flags32);
-#else
     result_16 = op1_16 & op2_16;
-#endif
-
     BX_WRITE_16BIT_REG(i->rm(), result_16);
     }
   else {
     read_RMW_virtual_word(i->seg(), RMAddr(i), &op1_16);
-
-#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
-    Bit32u flags32;
-
-    asmAnd16(result_16, op1_16, op2_16, flags32);
-    setEFlagsOSZAPC(flags32);
-#else
     result_16 = op1_16 & op2_16;
-#endif
-
     Write_RMW_virtual_word(result_16);
     }
 
-#if !(defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
   SET_FLAGS_OSZAPC_16(op1_16, op2_16, result_16, BX_INSTR_AND16);
 #endif
 }
@@ -401,10 +437,9 @@
     }
 
 #if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
-  Bit32u flags32;
 
-  asmTest16(op1_16, op2_16, flags32);
-  setEFlagsOSZAPC(flags32);
+  asmTest16PlusFlags(op1_16,op2_16,BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+
 #else
   Bit16u result_16;
   result_16 = op1_16 & op2_16;
@@ -424,10 +459,9 @@
   op2_16 = i->Iw();
 
 #if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
-  Bit32u flags32;
 
-  asmTest16(op1_16, op2_16, flags32);
-  setEFlagsOSZAPC(flags32);
+  asmTest16PlusFlags(op1_16,op2_16,BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+
 #else
   Bit16u result_16;
   result_16 = op1_16 & op2_16;
@@ -452,10 +486,9 @@
     }
 
 #if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
-  Bit32u flags32;
 
-  asmTest16(op1_16, op2_16, flags32);
-  setEFlagsOSZAPC(flags32);
+  asmTest16PlusFlags(op1_16,op2_16,BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+
 #else
   Bit16u result_16;
   result_16 = op1_16 & op2_16;
diff -ur bochs/cpu/logical32.cc bochs-modified/cpu/logical32.cc
--- bochs/cpu/logical32.cc	Fri Oct 25 11:26:28 2002
+++ bochs-modified/cpu/logical32.cc	Mon Aug 18 15:06:13 2003
@@ -39,6 +39,19 @@
   void
 BX_CPU_C::XOR_EdGd(bxInstruction_c *i)
 {
+#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
+  Bit32u  op1_32;
+  if (i->modC0()) {
+    op1_32 = BX_READ_32BIT_REG(i->rm());
+    asmXor32PlusFlags( op1_32, BX_READ_32BIT_REG(i->nnn()),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    BX_WRITE_32BIT_REGZ(i->rm(), op1_32);
+    }
+  else {
+    read_RMW_virtual_dword(i->seg(), RMAddr(i), &op1_32);
+    asmXor32PlusFlags( op1_32, BX_READ_32BIT_REG(i->nnn()),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    Write_RMW_virtual_dword(op1_32);
+    }
+#else
   Bit32u op2_32, op1_32, result_32;
 
   op2_32 = BX_READ_32BIT_REG(i->nnn());
@@ -55,17 +68,16 @@
     }
 
   SET_FLAGS_OSZAPC_32(op1_32, op2_32, result_32, BX_INSTR_XOR32);
+#endif
 }
 
 
   void
 BX_CPU_C::XOR_GdEd(bxInstruction_c *i)
 {
-  Bit32u op1_32, op2_32, result_32;
+  Bit32u op1_32, op2_32;
   unsigned nnn = i->nnn();
 
-  op1_32 = BX_READ_32BIT_REG(nnn);
-
   if (i->modC0()) {
     op2_32 = BX_READ_32BIT_REG(i->rm());
     }
@@ -73,17 +85,38 @@
     read_virtual_dword(i->seg(), RMAddr(i), &op2_32);
     }
 
+  op1_32 = BX_READ_32BIT_REG(nnn);
+
+#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
+  asmXor32PlusFlags( op1_32, op2_32,BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+  BX_WRITE_32BIT_REGZ(nnn, op1_32);
+#else
+  Bit32u result_32;
+
   result_32 = op1_32 ^ op2_32;
 
   BX_WRITE_32BIT_REGZ(nnn, result_32);
 
   SET_FLAGS_OSZAPC_32(op1_32, op2_32, result_32, BX_INSTR_XOR32);
+#endif
 }
 
 
   void
 BX_CPU_C::XOR_EAXId(bxInstruction_c *i)
 {
+#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
+
+ #if BX_SUPPORT_X86_64
+  Bit32u op1_32;
+  op1_32 = EAX;
+  asmXor32PlusFlags( op1_32, i->Id(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+  RAX = op1_32;
+ #else
+  asmXor32PlusFlags( EAX, i->Id(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+ #endif
+
+#else
   Bit32u op1_32, op2_32, sum_32;
 
   op1_32 = EAX;
@@ -91,18 +124,32 @@
 
   sum_32 = op1_32 ^ op2_32;
 
-#if BX_SUPPORT_X86_64
+ #if BX_SUPPORT_X86_64
   RAX = sum_32;
-#else
+ #else
   EAX = sum_32;
-#endif
+ #endif
 
   SET_FLAGS_OSZAPC_32(op1_32, op2_32, sum_32, BX_INSTR_XOR32);
+#endif
 }
 
   void
 BX_CPU_C::XOR_EdId(bxInstruction_c *i)
 {
+#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
+  Bit32u  op1_32;
+  if (i->modC0()) {
+    op1_32 = BX_READ_32BIT_REG(i->rm());
+    asmXor32PlusFlags( op1_32, i->Id(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    BX_WRITE_32BIT_REGZ(i->rm(), op1_32);
+    }
+  else {
+    read_RMW_virtual_dword(i->seg(), RMAddr(i), &op1_32);
+    asmXor32PlusFlags( op1_32, i->Id(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    Write_RMW_virtual_dword(op1_32);
+    }
+#else
   Bit32u op2_32, op1_32, result_32;
 
   op2_32 = i->Id();
@@ -119,12 +166,26 @@
     }
 
   SET_FLAGS_OSZAPC_32(op1_32, op2_32, result_32, BX_INSTR_XOR32);
+#endif
 }
 
 
   void
 BX_CPU_C::OR_EdId(bxInstruction_c *i)
 {
+#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
+  Bit32u  op1_32;
+  if (i->modC0()) {
+    op1_32 = BX_READ_32BIT_REG(i->rm());
+    asmOr32PlusFlags( op1_32, i->Id(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    BX_WRITE_32BIT_REGZ(i->rm(), op1_32);
+    }
+  else {
+    read_RMW_virtual_dword(i->seg(), RMAddr(i), &op1_32);
+    asmOr32PlusFlags( op1_32, i->Id(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    Write_RMW_virtual_dword(op1_32);
+    }
+#else
   Bit32u op2_32, op1_32, result_32;
 
   op2_32 = i->Id();
@@ -141,6 +202,7 @@
     }
 
   SET_FLAGS_OSZAPC_32(op1_32, op2_32, result_32, BX_INSTR_OR32);
+#endif
 }
 
   void
@@ -164,6 +226,19 @@
   void
 BX_CPU_C::OR_EdGd(bxInstruction_c *i)
 {
+#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
+  Bit32u  op1_32;
+  if (i->modC0()) {
+    op1_32 = BX_READ_32BIT_REG(i->rm());
+    asmOr32PlusFlags( op1_32, BX_READ_32BIT_REG(i->nnn()),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    BX_WRITE_32BIT_REGZ(i->rm(), op1_32);
+    }
+  else {
+    read_RMW_virtual_dword(i->seg(), RMAddr(i), &op1_32);
+    asmOr32PlusFlags( op1_32, BX_READ_32BIT_REG(i->nnn()),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    Write_RMW_virtual_dword(op1_32);
+    }
+#else
   Bit32u op2_32, op1_32, result_32;
 
   op2_32 = BX_READ_32BIT_REG(i->nnn());
@@ -180,15 +255,14 @@
     }
 
   SET_FLAGS_OSZAPC_32(op1_32, op2_32, result_32, BX_INSTR_OR32);
+#endif
 }
 
 
   void
 BX_CPU_C::OR_GdEd(bxInstruction_c *i)
 {
-  Bit32u op1_32, op2_32, result_32;
-
-  op1_32 = BX_READ_32BIT_REG(i->nnn());
+  Bit32u op1_32, op2_32;
 
   if (i->modC0()) {
     op2_32 = BX_READ_32BIT_REG(i->rm());
@@ -197,18 +271,18 @@
     read_virtual_dword(i->seg(), RMAddr(i), &op2_32);
     }
 
-#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
-  Bit32u flags32;
+  op1_32 = BX_READ_32BIT_REG(i->nnn());
 
-  asmOr32(result_32, op1_32, op2_32, flags32);
-  setEFlagsOSZAPC(flags32);
+#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
+  asmOr32PlusFlags( op1_32, op2_32,BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+  BX_WRITE_32BIT_REGZ(i->nnn(), op1_32);
 #else
+  Bit32u result_32;
+
   result_32 = op1_32 | op2_32;
-#endif
 
   BX_WRITE_32BIT_REGZ(i->nnn(), result_32);
 
-#if !(defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
   SET_FLAGS_OSZAPC_32(op1_32, op2_32, result_32, BX_INSTR_OR32);
 #endif
 }
@@ -217,6 +291,18 @@
   void
 BX_CPU_C::OR_EAXId(bxInstruction_c *i)
 {
+#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
+
+ #if BX_SUPPORT_X86_64
+  Bit32u op1_32;
+  op1_32 = EAX;
+  asmOr32PlusFlags( op1_32, i->Id(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+  RAX = op1_32;
+ #else
+  asmOr32PlusFlags( EAX, i->Id(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+ #endif
+
+#else
   Bit32u op1_32, op2_32, sum_32;
 
   op1_32 = EAX;
@@ -224,13 +310,14 @@
 
   sum_32 = op1_32 | op2_32;
 
-#if BX_SUPPORT_X86_64
+ #if BX_SUPPORT_X86_64
   RAX = sum_32;
-#else
+ #else
   EAX = sum_32;
-#endif
+ #endif
 
   SET_FLAGS_OSZAPC_32(op1_32, op2_32, sum_32, BX_INSTR_OR32);
+#endif
 }
 
 
@@ -238,40 +325,34 @@
   void
 BX_CPU_C::AND_EdGd(bxInstruction_c *i)
 {
+#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
+  Bit32u  op1_32;
+  if (i->modC0()) {
+    op1_32 = BX_READ_32BIT_REG(i->rm());
+    asmAnd32PlusFlags( op1_32, BX_READ_32BIT_REG(i->nnn()),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    BX_WRITE_32BIT_REGZ(i->rm(), op1_32);
+    }
+  else {
+    read_RMW_virtual_dword(i->seg(), RMAddr(i), &op1_32);
+    asmAnd32PlusFlags( op1_32, BX_READ_32BIT_REG(i->nnn()),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    Write_RMW_virtual_dword(op1_32);
+    }
+#else
   Bit32u op2_32, op1_32, result_32;
 
   op2_32 = BX_READ_32BIT_REG(i->nnn());
 
   if (i->modC0()) {
     op1_32 = BX_READ_32BIT_REG(i->rm());
-
-#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
-    Bit32u flags32;
-
-    asmAnd32(result_32, op1_32, op2_32, flags32);
-    setEFlagsOSZAPC(flags32);
-#else
     result_32 = op1_32 & op2_32;
-#endif
-
     BX_WRITE_32BIT_REGZ(i->rm(), result_32);
     }
   else {
     read_RMW_virtual_dword(i->seg(), RMAddr(i), &op1_32);
-
-#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
-    Bit32u flags32;
-
-    asmAnd32(result_32, op1_32, op2_32, flags32);
-    setEFlagsOSZAPC(flags32);
-#else
     result_32 = op1_32 & op2_32;
-#endif
-
     Write_RMW_virtual_dword(result_32);
     }
 
-#if !(defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
   SET_FLAGS_OSZAPC_32(op1_32, op2_32, result_32, BX_INSTR_AND32);
 #endif
 }
@@ -280,9 +361,7 @@
   void
 BX_CPU_C::AND_GdEd(bxInstruction_c *i)
 {
-  Bit32u op1_32, op2_32, result_32;
-
-  op1_32 = BX_READ_32BIT_REG(i->nnn());
+  Bit32u op1_32, op2_32;
 
   if (i->modC0()) {
     op2_32 = BX_READ_32BIT_REG(i->rm());
@@ -291,18 +370,17 @@
     read_virtual_dword(i->seg(), RMAddr(i), &op2_32);
     }
 
-#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
-  Bit32u flags32;
+  op1_32 = BX_READ_32BIT_REG(i->nnn());
 
-  asmAnd32(result_32, op1_32, op2_32, flags32);
-  setEFlagsOSZAPC(flags32);
+#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
+  asmAnd32PlusFlags( op1_32, op2_32,BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+  BX_WRITE_32BIT_REGZ(i->nnn(), op1_32);
 #else
+  Bit32u result_32;
   result_32 = op1_32 & op2_32;
-#endif
 
   BX_WRITE_32BIT_REGZ(i->nnn(), result_32);
 
-#if !(defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
   SET_FLAGS_OSZAPC_32(op1_32, op2_32, result_32, BX_INSTR_AND32);
 #endif
 }
@@ -311,27 +389,30 @@
   void
 BX_CPU_C::AND_EAXId(bxInstruction_c *i)
 {
-  Bit32u op1_32, op2_32, result_32;
+#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
 
+ #if BX_SUPPORT_X86_64
+  Bit32u op1_32;
   op1_32 = EAX;
-  op2_32 = i->Id();
-
-#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
-  Bit32u flags32;
+  asmAnd32PlusFlags( op1_32, i->Id(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+  RAX = op1_32;
+ #else
+  asmAnd32PlusFlags( EAX, i->Id(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+ #endif
 
-  asmAnd32(result_32, op1_32, op2_32, flags32);
-  setEFlagsOSZAPC(flags32);
 #else
+  Bit32u op1_32, op2_32, result_32;
+
+  op2_32 = i->Id();
+
   result_32 = op1_32 & op2_32;
-#endif
 
-#if BX_SUPPORT_X86_64
+ #if BX_SUPPORT_X86_64
   RAX = result_32;
-#else
+ #else
   EAX = result_32;
-#endif
+ #endif
 
-#if !(defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
   SET_FLAGS_OSZAPC_32(op1_32, op2_32, result_32, BX_INSTR_AND32);
 #endif
 }
@@ -339,40 +420,34 @@
   void
 BX_CPU_C::AND_EdId(bxInstruction_c *i)
 {
+#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
+  Bit32u  op1_32;
+  if (i->modC0()) {
+    op1_32 = BX_READ_32BIT_REG(i->rm());
+    asmAnd32PlusFlags( op1_32, i->Id(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    BX_WRITE_32BIT_REGZ(i->rm(), op1_32);
+    }
+  else {
+    read_RMW_virtual_dword(i->seg(), RMAddr(i), &op1_32);
+    asmAnd32PlusFlags( op1_32, i->Id(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+    Write_RMW_virtual_dword(op1_32);
+    }
+#else
   Bit32u op2_32, op1_32, result_32;
 
   op2_32 = i->Id();
 
   if (i->modC0()) {
     op1_32 = BX_READ_32BIT_REG(i->rm());
-
-#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
-    Bit32u flags32;
-
-    asmAnd32(result_32, op1_32, op2_32, flags32);
-    setEFlagsOSZAPC(flags32);
-#else
     result_32 = op1_32 & op2_32;
-#endif
-
     BX_WRITE_32BIT_REGZ(i->rm(), result_32);
     }
   else {
     read_RMW_virtual_dword(i->seg(), RMAddr(i), &op1_32);
-
-#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
-    Bit32u flags32;
-
-    asmAnd32(result_32, op1_32, op2_32, flags32);
-    setEFlagsOSZAPC(flags32);
-#else
     result_32 = op1_32 & op2_32;
-#endif
-
     Write_RMW_virtual_dword(result_32);
     }
 
-#if !(defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
   SET_FLAGS_OSZAPC_32(op1_32, op2_32, result_32, BX_INSTR_AND32);
 #endif
 }
@@ -381,9 +456,7 @@
   void
 BX_CPU_C::TEST_EdGd(bxInstruction_c *i)
 {
-  Bit32u op2_32, op1_32;
-
-  op2_32 = BX_READ_32BIT_REG(i->nnn());
+  Bit32u op1_32;
 
   if (i->modC0()) {
     op1_32 = BX_READ_32BIT_REG(i->rm());
@@ -393,12 +466,11 @@
     }
 
 #if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
-  Bit32u flags32;
-
-  asmTest32(op1_32, op2_32, flags32);
-  setEFlagsOSZAPC(flags32);
+  asmTest32PlusFlags(op1_32,BX_READ_32BIT_REG(i->nnn()),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
 #else
-  Bit32u result_32;
+  Bit32u op2_32, result_32;
+
+  op2_32 = BX_READ_32BIT_REG(i->nnn());
   result_32 = op1_32 & op2_32;
 
   SET_FLAGS_OSZAPC_32(op1_32, op2_32, result_32, BX_INSTR_TEST32);
@@ -410,17 +482,14 @@
   void
 BX_CPU_C::TEST_EAXId(bxInstruction_c *i)
 {
+#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
+  asmTest32PlusFlags(EAX,i->Id(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+#else
   Bit32u op2_32, op1_32;
 
   op1_32 = EAX;
   op2_32 = i->Id();
 
-#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
-  Bit32u flags32;
-
-  asmTest32(op1_32, op2_32, flags32);
-  setEFlagsOSZAPC(flags32);
-#else
   Bit32u result_32;
   result_32 = op1_32 & op2_32;
 
@@ -432,9 +501,7 @@
   void
 BX_CPU_C::TEST_EdId(bxInstruction_c *i)
 {
-  Bit32u op2_32, op1_32;
-
-  op2_32 = i->Id();
+  Bit32u op1_32;
 
   if (i->modC0()) {
     op1_32 = BX_READ_32BIT_REG(i->rm());
@@ -444,12 +511,13 @@
     }
 
 #if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
-  Bit32u flags32;
 
-  asmTest32(op1_32, op2_32, flags32);
-  setEFlagsOSZAPC(flags32);
+  asmTest32PlusFlags(op1_32,i->Id(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+
 #else
-  Bit32u result_32;
+  Bit32u op2_32, result_32;
+
+  op2_32 = i->Id();
   result_32 = op1_32 & op2_32;
 
   SET_FLAGS_OSZAPC_32(op1_32, op2_32, result_32, BX_INSTR_TEST32);
diff -ur bochs/cpu/logical8.cc bochs-modified/cpu/logical8.cc
--- bochs/cpu/logical8.cc	Fri Oct 25 11:26:28 2002
+++ bochs-modified/cpu/logical8.cc	Wed Aug 13 11:48:53 2003
@@ -383,9 +383,8 @@
   void
 BX_CPU_C::TEST_EbGb(bxInstruction_c *i)
 {
-  Bit8u op2, op1;
+  Bit8u op1;
 
-  op2 = BX_READ_8BIT_REGx(i->nnn(),i->extend8bitL());
 
   if (i->modC0()) {
     op1 = BX_READ_8BIT_REGx(i->rm(),i->extend8bitL());
@@ -395,12 +394,15 @@
     }
 
 #if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
-  Bit32u flags32;
 
-  asmTest8(op1, op2, flags32);
-  setEFlagsOSZAPC(flags32);
+asmTest8PlusFlags(op1,BX_READ_8BIT_REGx(i->nnn(),i->extend8bitL()),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+
 #else
-  Bit8u result;
+  Bit8u op2, result;
+
+  op2 = BX_READ_8BIT_REGx(i->nnn(),i->extend8bitL());
+
+
   result = op1 & op2;
 
   SET_FLAGS_OSZAPC_8(op1, op2, result, BX_INSTR_TEST8);
@@ -411,18 +413,17 @@
   void
 BX_CPU_C::TEST_ALIb(bxInstruction_c *i)
 {
+#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
+
+asmTest8PlusFlags(AL,i->Ib(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+
+#else
+  Bit8u result;
   Bit8u op2, op1;
 
   op1 = AL;
   op2 = i->Ib();
 
-#if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
-  Bit32u flags32;
-
-  asmTest8(op1, op2, flags32);
-  setEFlagsOSZAPC(flags32);
-#else
-  Bit8u result;
   result = op1 & op2;
 
   SET_FLAGS_OSZAPC_8(op1, op2, result, BX_INSTR_TEST8);
@@ -434,9 +435,7 @@
   void
 BX_CPU_C::TEST_EbIb(bxInstruction_c *i)
 {
-  Bit8u op2, op1;
-
-  op2 = i->Ib();
+  Bit8u op1;
 
   if (i->modC0()) {
     op1 = BX_READ_8BIT_REGx(i->rm(),i->extend8bitL());
@@ -446,12 +445,14 @@
     }
 
 #if (defined(__i386__) && defined(__GNUC__) && BX_SupportHostAsms)
-  Bit32u flags32;
 
-  asmTest8(op1, op2, flags32);
-  setEFlagsOSZAPC(flags32);
+asmTest8PlusFlags(op1,i->Ib(),BX_CPU_THIS_PTR lf_flags_status,BX_CPU_THIS_PTR eflags.val32);
+
 #else
-  Bit8u result;
+  Bit8u op2, result;
+
+  op2 = i->Ib();
+
   result = op1 & op2;
 
   SET_FLAGS_OSZAPC_8(op1, op2, result, BX_INSTR_TEST8);

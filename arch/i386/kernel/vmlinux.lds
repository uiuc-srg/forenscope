

/*
 * Automatically generated C config: don't edit
 * Linux kernel version: 2.6.22.6
 * Wed Sep 21 10:33:17 2011
 */
/* ld script to make i386 Linux kernel
 * Written by Martin Mares <mj@atrey.karlin.mff.cuni.cz>;
 *
 * Don't define absolute symbols until and unless you know that symbol
 * value is should remain constant even if kernel image is relocated
 * at run time. Absolute symbols are not relocated. If symbol value should
 * change if kernel is relocated, make the symbol section relative and
 * put it inside the section definition.
 */
/* Don't define absolute symbols until and unless you know that symbol
 * value is should remain constant even if kernel image is relocated
 * at run time. Absolute symbols are not relocated. If symbol value should
 * change if kernel is relocated, make the symbol section relative and
 * put it inside the section definition.
 */
/* Align . to a 8 byte boundary equals to maximum function alignment. */
/* .data section */
/* RODATA provided for backward compatibility.
 * All archs are supposed to use RO_DATA() */
/* .text section. Map to function alignment to avoid address changes
 * during second ld run in second ld pass when generating System.map */
/* sched.text is aling to function alignment to secure we have same
 * address even at second ld pass when generating System.map */
/* spinlock.text is aling to function alignment to secure we have same
 * address even at second ld pass when generating System.map */
  /* DWARF debug sections.
		Symbols in the DWARF debugging sections are relative to
		the beginning of the section so we begin them at 0.  */
  /* Stabs debugging sections.  */
/* thread_info.h: i386 low-level thread information
 *
 * Copyright (C) 2002  David Howells (dhowells@redhat.com)
 * - Incorporating suggestions made by Linus Torvalds and Dave Miller
 */
/*
 * Allow us to mark functions as 'deprecated' and have gcc emit a nice
 * warning for each use, in hopes of speeding the functions removal.
 * Usage is:
 * 		int __deprecated foo(void)
 */
/*
 * Allow us to avoid 'defined but not used' warnings on functions and data,
 * as well as force them to be emitted to the assembly file.
 *
 * As of gcc 3.4, static functions that are not marked with attribute((used))
 * may be elided from the assembly file.  As of gcc 3.4, static data not so
 * marked will not be elided, but this may change in a future gcc version.
 *
 * NOTE: Because distributions shipped with a backported unit-at-a-time
 * compiler in gcc 3.3, we must define __used to be __attribute__((used))
 * for gcc >=3.3 instead of 3.4.
 *
 * In prior versions of gcc, such functions and data would be emitted, but
 * would be warned about except with attribute((unused)).
 *
 * Mark functions that are referenced only in inline assembly as __used so
 * the code is emitted even though it appears to be unreferenced.
 */
/*
 * From the GCC manual:
 *
 * Many functions have no effects except the return value and their
 * return value depends only on the parameters and/or global
 * variables.  Such a function can be subject to common subexpression
 * elimination and loop optimization just as an arithmetic operator
 * would be.
 * [...]
 */
/*
 * From the GCC manual:
 *
 * Many functions do not examine any values except their arguments,
 * and have no effects except the return value.  Basically this is
 * just slightly more strict class than the `pure' attribute above,
 * since function is not allowed to read global memory.
 *
 * Note that a function that has pointer arguments and examines the
 * data pointed to must _not_ be declared `const'.  Likewise, a
 * function that calls a non-`const' function usually must not be
 * `const'.  It does not make sense for a `const' function to return
 * `void'.
 */
/* PAGE_SHIFT determines the page size */
/* to align the pointer to the (next) page boundary */
/*
 * This handles the memory map.. We could make this a config
 * option, but too many people screw it up, and too few need
 * it.
 *
 * A __PAGE_OFFSET of 0xC0000000 means that the kernel has
 * a virtual address space of one gigabyte, which limits the
 * amount of physical memory you can use to about 950MB. 
 *
 * If you want more physical memory than this then see the CONFIG_HIGHMEM4G
 * and CONFIG_HIGHMEM64G options in the kernel configuration.
 */
/* __pa_symbol should be used for C visible symbols.
   This seems to be the official gcc blessed way to do such arithmetic. */
/*
 * low level task data that entry.S needs immediate access to
 * - this struct should fit entirely inside of one cache line
 * - this struct shares the supervisor stack pages
 * - if the contents of this structure are changed, the assembly constants must also be changed
 */
/*
 * DO NOT MODIFY.
 *
 * This file was generated by Kbuild
 *
 */
/*
 * macros/functions for gaining access to the thread information structure
 *
 * preempt_count needs to be 1 initially, until the scheduler is functional.
 */
/* how to get the thread information struct from ASM */
/* use this one if reg already contains %esp */
/*
 * thread information flags
 * - these are process state flags that various assembly files may need to access
 * - pending work-to-be-done flags are in LSW
 * - other flags in MSW
 */
/* work to do on interrupt/exception return */
/* work to do on any return to u-space */
/* flags to check in __switch_to() */
/*
 * Thread-synchronous status.
 *
 * This is different from the flags in that nobody else
 * ever touches our thread-synchronous status, so we don't
 * have to worry about atomic accesses.
 */
/*
 * include/asm-i386/cache.h
 */
/* L1 cache line size */
/* Don't touch these, unless you really know what you're doing. */
/* Internal svga startup constants */
/* Physical address where kernel should be loaded. */
OUTPUT_FORMAT("elf32-i386", "elf32-i386", "elf32-i386")
OUTPUT_ARCH(i386)
ENTRY(phys_startup_32)
jiffies = jiffies_64;
PHDRS {
 text PT_LOAD FLAGS(5); /* R_E */
 data PT_LOAD FLAGS(7); /* RWE */
 note PT_NOTE FLAGS(0); /* ___ */
}
SECTIONS
{
  . = 0xC0000000 + ((0x00800000 + (0x100000 - 1)) & ~(0x100000 - 1));
  phys_startup_32 = startup_32 - 0xC0000000;
  .text.head : AT(ADDR(.text.head) - 0xC0000000) {
   _text = .; /* Text and read-only data */
 *(.text.head)
  } :text = 0x9090
  /* read-only */
  .text : AT(ADDR(.text) - 0xC0000000) {
 . = ALIGN(8); *(.text) *(.text.init.refok)
 . = ALIGN(8); __sched_text_start = .; *(.sched.text) __sched_text_end = .;
 . = ALIGN(8); __lock_text_start = .; *(.spinlock.text) __lock_text_end = .;
 . = ALIGN(8); __kprobes_text_start = .; *(.kprobes.text) __kprobes_text_end = .;
 *(.fixup)
 *(.gnu.warning)
   _etext = .; /* End of text section */
  } :text = 0x9090
  . = ALIGN(16); /* Exception table */
  __ex_table : AT(ADDR(__ex_table) - 0xC0000000) {
   __start___ex_table = .;
  *(__ex_table)
   __stop___ex_table = .;
  }
  . = ALIGN(8); __bug_table : AT(ADDR(__bug_table) - 0xC0000000) { __start___bug_table = .; *(__bug_table) __stop___bug_table = .; }
  . = ALIGN(4);
  .tracedata : AT(ADDR(.tracedata) - 0xC0000000) {
   __tracedata_start = .;
 *(.tracedata)
   __tracedata_end = .;
  }
  . = ALIGN((4096)); .rodata : AT(ADDR(.rodata) - 0xC0000000) { __start_rodata = .; *(.rodata) *(.rodata.*) *(__vermagic) } .rodata1 : AT(ADDR(.rodata1) - 0xC0000000) { *(.rodata1) } .pci_fixup : AT(ADDR(.pci_fixup) - 0xC0000000) { __start_pci_fixups_early = .; *(.pci_fixup_early) __end_pci_fixups_early = .; __start_pci_fixups_header = .; *(.pci_fixup_header) __end_pci_fixups_header = .; __start_pci_fixups_final = .; *(.pci_fixup_final) __end_pci_fixups_final = .; __start_pci_fixups_enable = .; *(.pci_fixup_enable) __end_pci_fixups_enable = .; __start_pci_fixups_resume = .; *(.pci_fixup_resume) __end_pci_fixups_resume = .; } .rio_route : AT(ADDR(.rio_route) - 0xC0000000) { __start_rio_route_ops = .; *(.rio_route_ops) __end_rio_route_ops = .; } __ksymtab : AT(ADDR(__ksymtab) - 0xC0000000) { __start___ksymtab = .; *(__ksymtab) __stop___ksymtab = .; } __ksymtab_gpl : AT(ADDR(__ksymtab_gpl) - 0xC0000000) { __start___ksymtab_gpl = .; *(__ksymtab_gpl) __stop___ksymtab_gpl = .; } __ksymtab_unused : AT(ADDR(__ksymtab_unused) - 0xC0000000) { __start___ksymtab_unused = .; *(__ksymtab_unused) __stop___ksymtab_unused = .; } __ksymtab_unused_gpl : AT(ADDR(__ksymtab_unused_gpl) - 0xC0000000) { __start___ksymtab_unused_gpl = .; *(__ksymtab_unused_gpl) __stop___ksymtab_unused_gpl = .; } __ksymtab_gpl_future : AT(ADDR(__ksymtab_gpl_future) - 0xC0000000) { __start___ksymtab_gpl_future = .; *(__ksymtab_gpl_future) __stop___ksymtab_gpl_future = .; } __kcrctab : AT(ADDR(__kcrctab) - 0xC0000000) { __start___kcrctab = .; *(__kcrctab) __stop___kcrctab = .; } __kcrctab_gpl : AT(ADDR(__kcrctab_gpl) - 0xC0000000) { __start___kcrctab_gpl = .; *(__kcrctab_gpl) __stop___kcrctab_gpl = .; } __kcrctab_unused : AT(ADDR(__kcrctab_unused) - 0xC0000000) { __start___kcrctab_unused = .; *(__kcrctab_unused) __stop___kcrctab_unused = .; } __kcrctab_unused_gpl : AT(ADDR(__kcrctab_unused_gpl) - 0xC0000000) { __start___kcrctab_unused_gpl = .; *(__kcrctab_unused_gpl) __stop___kcrctab_unused_gpl = .; } __kcrctab_gpl_future : AT(ADDR(__kcrctab_gpl_future) - 0xC0000000) { __start___kcrctab_gpl_future = .; *(__kcrctab_gpl_future) __stop___kcrctab_gpl_future = .; } __ksymtab_strings : AT(ADDR(__ksymtab_strings) - 0xC0000000) { *(__ksymtab_strings) } __param : AT(ADDR(__param) - 0xC0000000) { __start___param = .; *(__param) __stop___param = .; __end_rodata = .; } . = ALIGN((4096));
  /* writeable */
  . = ALIGN(4096);
  .data : AT(ADDR(.data) - 0xC0000000) { /* Data */
 *(.data) *(.data.init.refok)
 CONSTRUCTORS
 } :data
  . = ALIGN(4096);
  .data_nosave : AT(ADDR(.data_nosave) - 0xC0000000) {
   __nosave_begin = .;
 *(.data.nosave)
   . = ALIGN(4096);
   __nosave_end = .;
  }
  . = ALIGN(4096);
  .data.page_aligned : AT(ADDR(.data.page_aligned) - 0xC0000000) {
 *(.data.idt)
  }
  . = ALIGN(32);
  .data.cacheline_aligned : AT(ADDR(.data.cacheline_aligned) - 0xC0000000) {
 *(.data.cacheline_aligned)
  }
  /* rarely changed data like cpu maps */
  . = ALIGN(32);
  .data.read_mostly : AT(ADDR(.data.read_mostly) - 0xC0000000) {
 *(.data.read_mostly)
 _edata = .; /* End of data section */
  }
  . = ALIGN((4096)); /* init_task */
  .data.init_task : AT(ADDR(.data.init_task) - 0xC0000000) {
 *(.data.init_task)
  }
  /* might get freed after init */
  . = ALIGN(4096);
  .smp_locks : AT(ADDR(.smp_locks) - 0xC0000000) {
   __smp_locks = .;
 *(.smp_locks)
 __smp_locks_end = .;
  }
  /* will be freed after init
   * Following ALIGN() is required to make sure no other data falls on the
   * same page where __smp_alt_end is pointing as that page might be freed
   * after boot. Always make sure that ALIGN() directive is present after
   * the section which contains __smp_alt_end.
   */
  . = ALIGN(4096);
  /* will be freed after init */
  . = ALIGN(4096); /* Init code and data */
  .init.text : AT(ADDR(.init.text) - 0xC0000000) {
   __init_begin = .;
 _sinittext = .;
 *(.init.text)
 _einittext = .;
  }
  .init.data : AT(ADDR(.init.data) - 0xC0000000) { *(.init.data) }
  . = ALIGN(16);
  .init.setup : AT(ADDR(.init.setup) - 0xC0000000) {
   __setup_start = .;
 *(.init.setup)
   __setup_end = .;
   }
  .initcall.init : AT(ADDR(.initcall.init) - 0xC0000000) {
   __initcall_start = .;
 *(.initcall0.init) *(.initcall0s.init) *(.initcall1.init) *(.initcall1s.init) *(.initcall2.init) *(.initcall2s.init) *(.initcall3.init) *(.initcall3s.init) *(.initcall4.init) *(.initcall4s.init) *(.initcall5.init) *(.initcall5s.init) *(.initcallrootfs.init) *(.initcall6.init) *(.initcall6s.init) *(.initcall7.init) *(.initcall7s.init)
   __initcall_end = .;
  }
  .con_initcall.init : AT(ADDR(.con_initcall.init) - 0xC0000000) {
   __con_initcall_start = .;
 *(.con_initcall.init)
   __con_initcall_end = .;
  }
  .security_initcall.init : AT(ADDR(.security_initcall.init) - 0xC0000000) { __security_initcall_start = .; *(.security_initcall.init) __security_initcall_end = .; }
  . = ALIGN(4);
  .altinstructions : AT(ADDR(.altinstructions) - 0xC0000000) {
   __alt_instructions = .;
 *(.altinstructions)
 __alt_instructions_end = .;
  }
  .altinstr_replacement : AT(ADDR(.altinstr_replacement) - 0xC0000000) {
 *(.altinstr_replacement)
  }
  . = ALIGN(4);
  .parainstructions : AT(ADDR(.parainstructions) - 0xC0000000) {
   __parainstructions = .;
 *(.parainstructions)
   __parainstructions_end = .;
  }
  /* .exit.text is discard at runtime, not link time, to deal with references
     from .altinstructions and .eh_frame */
  .exit.text : AT(ADDR(.exit.text) - 0xC0000000) { *(.exit.text) }
  .exit.data : AT(ADDR(.exit.data) - 0xC0000000) { *(.exit.data) }
  . = ALIGN(4096);
  .init.ramfs : AT(ADDR(.init.ramfs) - 0xC0000000) {
 __initramfs_start = .;
 *(.init.ramfs)
 __initramfs_end = .;
  }
  . = ALIGN(4096);
  .data.percpu : AT(ADDR(.data.percpu) - 0xC0000000) {
 __per_cpu_start = .;
 *(.data.percpu)
 __per_cpu_end = .;
  }
  . = ALIGN(4096);
  /* freed after init ends here */
  .bss : AT(ADDR(.bss) - 0xC0000000) {
 __init_end = .;
 __bss_start = .; /* BSS */
 *(.bss.page_aligned)
 *(.bss)
 . = ALIGN(4);
 __bss_stop = .;
   _end = . ;
 /* This is where the kernel creates the early boot page tables */
 . = ALIGN(4096);
 pg0 = . ;
  }
  /* Sections to be discarded */
  /DISCARD/ : {
 *(.exitcall.exit)
 }
  .stab 0 : { *(.stab) } .stabstr 0 : { *(.stabstr) } .stab.excl 0 : { *(.stab.excl) } .stab.exclstr 0 : { *(.stab.exclstr) } .stab.index 0 : { *(.stab.index) } .stab.indexstr 0 : { *(.stab.indexstr) } .comment 0 : { *(.comment) }
  .debug 0 : { *(.debug) } .line 0 : { *(.line) } .debug_srcinfo 0 : { *(.debug_srcinfo) } .debug_sfnames 0 : { *(.debug_sfnames) } .debug_aranges 0 : { *(.debug_aranges) } .debug_pubnames 0 : { *(.debug_pubnames) } .debug_info 0 : { *(.debug_info .gnu.linkonce.wi.*) } .debug_abbrev 0 : { *(.debug_abbrev) } .debug_line 0 : { *(.debug_line) } .debug_frame 0 : { *(.debug_frame) } .debug_str 0 : { *(.debug_str) } .debug_loc 0 : { *(.debug_loc) } .debug_macinfo 0 : { *(.debug_macinfo) } .debug_weaknames 0 : { *(.debug_weaknames) } .debug_funcnames 0 : { *(.debug_funcnames) } .debug_typenames 0 : { *(.debug_typenames) } .debug_varnames 0 : { *(.debug_varnames) }
  .notes : { *(.note.*) } :note
}
